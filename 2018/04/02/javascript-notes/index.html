<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="javascript," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="现在的前端框架层出不穷，3个月就要重新入门一次前端的现状，让我们来不及学好基础就开始上手框架。常常就因为这样，我们会很快到达基础技术瓶颈，基础是所有技术的核心，在跳槽季重新温故了一遍 javascript 基础，有收获，整理出来分享给大家。

对象变量可以当对象使用javascript 中所有的变量都可以当做对象使用，除了undefined 和 null ，我们测试下
1234567false.">
<meta property="og:type" content="article">
<meta property="og:title" content="你需要知道的 javascript 的细节">
<meta property="og:url" content="https://bailinlin.github.com/2018/04/02/javascript-notes/index.html">
<meta property="og:site_name" content="白霸天的博客">
<meta property="og:description" content="现在的前端框架层出不穷，3个月就要重新入门一次前端的现状，让我们来不及学好基础就开始上手框架。常常就因为这样，我们会很快到达基础技术瓶颈，基础是所有技术的核心，在跳槽季重新温故了一遍 javascript 基础，有收获，整理出来分享给大家。

对象变量可以当对象使用javascript 中所有的变量都可以当做对象使用，除了undefined 和 null ，我们测试下
1234567false.">
<meta property="og:updated_time" content="2018-04-03T07:44:44.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="你需要知道的 javascript 的细节">
<meta name="twitter:description" content="现在的前端框架层出不穷，3个月就要重新入门一次前端的现状，让我们来不及学好基础就开始上手框架。常常就因为这样，我们会很快到达基础技术瓶颈，基础是所有技术的核心，在跳槽季重新温故了一遍 javascript 基础，有收获，整理出来分享给大家。

对象变量可以当对象使用javascript 中所有的变量都可以当做对象使用，除了undefined 和 null ，我们测试下
1234567false.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://bailinlin.github.com/2018/04/02/javascript-notes/"/>





  <title> 你需要知道的 javascript 的细节 | 白霸天的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">白霸天的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2018/04/02/javascript-notes/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                你需要知道的 javascript 的细节
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-02T17:27:29+08:00">
                2018-04-02
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2018/04/02/javascript-notes/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/04/02/javascript-notes/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>现在的前端框架层出不穷，3个月就要重新入门一次前端的现状，让我们来不及学好基础就开始上手框架。常常就因为这样，我们会很快到达基础<code>技术瓶颈</code>，基础是所有技术的核心，在跳槽季重新温故了一遍 javascript 基础，有收获，整理出来分享给大家。</p>
</blockquote>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="变量可以当对象使用"><a href="#变量可以当对象使用" class="headerlink" title="变量可以当对象使用"></a>变量可以当对象使用</h4><p><code>javascript</code> 中所有的变量都可以当做对象使用，除了<code>undefined</code> 和 <code>null</code> ，我们测试下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">false.toString() // &quot;false&quot;</div><div class="line"></div><div class="line">[1,2,3].toString() //&quot;1,2,3&quot;</div><div class="line"></div><div class="line">1..toString() //&quot;1&quot;</div><div class="line"></div><div class="line">(&#123;a:&apos;33&apos;&#125;).toString() //&quot;[object Object]&quot;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">undefined.toString() //Uncaught TypeError</div><div class="line"></div><div class="line">null.toString()   //Uncaught TypeError</div></pre></td></tr></table></figure>
<p>数值和对象虽然能调用 <code>toString</code> 方法，但是在写法上需要注意下</p>
<p><code>number</code> 调用时不能直接数值后面直接调用<code>toString</code> 方法，因为 <code>js</code> 会将点运算符解析为数值的小数点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.toString() //Uncaught SyntaxError</div><div class="line"></div><div class="line">1..toString() //&quot;1&quot;</div></pre></td></tr></table></figure>
<p>对象直接调用<code>toString</code> 方法时，需要用小括号包裹起来，不然<code>js</code> 会将对象的花括号识别成块，从而报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;a:&apos;33&apos;&#125;.toString()  // Uncaught SyntaxError</div><div class="line"></div><div class="line">(&#123;a:&apos;33&apos;&#125;).toString() // &quot;[object Object]&quot;</div></pre></td></tr></table></figure>
<h4 id="对象删除属性"><a href="#对象删除属性" class="headerlink" title="对象删除属性"></a>对象删除属性</h4><blockquote>
<p>删除对象的属性唯一的方法是使用 <code>delete</code> 操作符，设置元素属性为 <code>undefined</code> 或则 <code>null</code> 并不能真正删除，只是移除了属性和值的关联</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var test = &#123;</div><div class="line">	name:&apos;bbt&apos;,</div><div class="line">	age:&apos;18&apos;,</div><div class="line">	love:&apos;dog&apos;</div><div class="line">&#125;</div><div class="line"></div><div class="line">test.name = undefined</div><div class="line">test.age = null</div><div class="line">delete test.love</div><div class="line"></div><div class="line">for (var i in test)&#123;</div><div class="line">  console.log(i+&apos;:&apos;+test[i])</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">name:undefined</div><div class="line">age:null</div><div class="line">undefined</div></pre></td></tr></table></figure>
<p>只有 <code>love</code> 被正则删除，<code>name</code> 和 <code>age</code> 还是能被遍历到</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><blockquote>
<p>在 <code>javascript</code> 中，通过关键字 <code>new</code> 调用的函数就被认为是构造函数，我们可以通过构造函数创建对象实例</p>
</blockquote>
<p>但是在使用过程中你一定发现了，每实例化一个对象，都会在实例对象上创造构造函数的方法和属性。倘若创建的实例比较多，重复创建同一个方法去开辟内存空间就会显得十分浪费，我们可以通过把被经常复用的方法放在原型链上。</p>
<h4 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h4><blockquote>
<p><code>javascript</code> 和一些我们所了解的面向对象编程的语言不太一样，在 <code>es6</code> 语法以前，我们是通过原型链来实现方法和属性的继承</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">function Child()&#123;</div><div class="line">  this.name = &apos;bbt&apos;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Child.prototype = &#123;</div><div class="line">	title:&apos;baba&apos;,</div><div class="line">    method: function() &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function Grandson()&#123;&#125;</div><div class="line"></div><div class="line">//设置 Grandson 的 prototype 为 Child 的实例</div><div class="line">Grandson.prototype = new Child()</div><div class="line"></div><div class="line">//为 Grandson 的原型添加添加属性 age</div><div class="line">Grandson.prototype.age = 40</div><div class="line"></div><div class="line">// 修正 Grandson.prototype.constructor 为 Grandson 本身</div><div class="line">Grandson.prototype.constructor = Grandson;</div><div class="line"></div><div class="line">var xiaomin = new Grandson()</div><div class="line"></div><div class="line">//原型链如下</div><div class="line">xiaomin // Grandson的实例</div><div class="line">    Grandson.prototype // Child的实例</div><div class="line">         Grandson.prototype //&#123;title:&apos;baba&apos;,...&#125;</div><div class="line">            Object.prototype</div><div class="line">                &#123;toString: ... /* etc. */&#125;;</div></pre></td></tr></table></figure>
<p>对象的属性查找，<code>javascript</code> 会在原型链上向上查找属性，直到查到 原型链顶部，所以，属性在原型链的越上端，查找的时间会越长，查找性能和复用属性方面需要开发者自己衡量下。</p>
<h4 id="获取自身对象属性"><a href="#获取自身对象属性" class="headerlink" title="获取自身对象属性"></a>获取自身对象属性</h4><p><code>hasOwnProperty</code> 方法能够判断一个对象是否包含自定义属性，而不是在原型链上的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var test = &#123;hello:&apos;123&apos;&#125;</div><div class="line"></div><div class="line">Object.prototype.name = &apos;bbt&apos;</div><div class="line"></div><div class="line">test.name  //&apos;bbt&apos;</div><div class="line">test.hasOwnProperty(&apos;hello&apos;) //true</div><div class="line">test.hasOwnProperty(&apos;name&apos;) //false</div></pre></td></tr></table></figure>
<p><code>for in</code> 循环可以遍历对象原型链上的所有属性，如此我们将 <code>hasOwnProperty</code>结合循环<code>for in</code> 能够获取到对象自定义属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var test = &#123;hello:&apos;222&apos;&#125;</div><div class="line">Object.prototype.name = &apos;bbt&apos;</div><div class="line"></div><div class="line">for(var i in test)&#123;</div><div class="line">  console.log(i) // 输出两个属性，hello ，name</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">for(var i in test)&#123;</div><div class="line">  if(test.hasOwnProperty(i))&#123;</div><div class="line">    console.log(i)//只输出 hello</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了上面的方法，<code>getOwnPropertyNames</code> 和 <code>Object.keys</code> 方法，能够返回对象自身的所有属性名，也是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有属性名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var test = &#123;hello:&apos;222&apos;&#125;</div><div class="line">Object.prototype.name = &apos;bbt&apos;</div><div class="line"></div><div class="line">Object.keys(test) //[&quot;hello&quot;]</div><div class="line">Object.getOwnPropertyNames(test) //[&quot;hello&quot;]</div></pre></td></tr></table></figure>
<p>那 <code>getOwnPropertyNames</code> 和 <code>Object.keys</code> 的用法有什么区别呢</p>
<p><code>Object.keys</code>方法只返回可枚举的属性，<code>Object.getOwnPropertyNames</code>  方法还返回不可枚举的属性名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var a = [&apos;Hello&apos;, &apos;World&apos;];</div><div class="line"></div><div class="line">Object.keys(a) // [&quot;0&quot;, &quot;1&quot;]</div><div class="line"></div><div class="line">Object.getOwnPropertyNames(a) // [&quot;0&quot;, &quot;1&quot;, &quot;length&quot;]  // length 是不可枚举属性</div></pre></td></tr></table></figure>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="函数声明的变量提升"><a href="#函数声明的变量提升" class="headerlink" title="函数声明的变量提升"></a>函数声明的变量提升</h4><p>我们通常会使用函数声明或函数赋值表达式来定义一个函数，函数声明和变量声明一样都存在提升的情况，函数可以在声明前调用，但是不可以在赋值前调用</p>
<p>函数声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">foo(); // 正常运行，因为foo在代码运行前已经被创建</div><div class="line">function foo() &#123;&#125;</div></pre></td></tr></table></figure>
<p>函数表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">foo; // &apos;undefined&apos;</div><div class="line">foo(); // 出错：TypeError</div><div class="line">var foo = function() &#123;&#125;;</div></pre></td></tr></table></figure>
<p>变量提升是在代码解析的时候进行的，foo() 方法调用的时候，已经在解析阶段将 foo 定义过了。赋值语句只在代码运行时才进行，所以在赋值前调用会报错</p>
<p>一种比较少用的函数赋值操作，将命名函数赋值给一个变量，此时的函数名只对函数内部可见</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var test = function foo()&#123;</div><div class="line">  console.log(foo) //正常输出</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log(foo) //Uncaught ReferenceError</div></pre></td></tr></table></figure>
<h4 id="this-的工作原理"><a href="#this-的工作原理" class="headerlink" title="this 的工作原理"></a>this 的工作原理</h4><blockquote>
<p>在 <code>javascript</code> 中 ，<code>this</code> 是一个比较难理解的点，不同的调用环境会导致 <code>this</code> 的不同指向，但是唯一不变的是 <code>this</code> 总是指向一个对象</p>
</blockquote>
<p>简单的说，<code>this</code> 就是属性和方法当前所在的对象（函数执行坐在的作用域），平时使用的 <code>this</code>  的情况可以大致分为5种</p>
<table>
<thead>
<tr>
<th>调用方式</th>
<th>指向</th>
</tr>
</thead>
<tbody>
<tr>
<td>1. 全局范围调用</td>
<td>指向 window 全局对象</td>
</tr>
<tr>
<td>2. 函数调用</td>
<td>指向 window 全局变量</td>
</tr>
<tr>
<td>3. 对象的方法调用</td>
<td>指向方法调用的对象</td>
</tr>
<tr>
<td>4. 构造函数调用</td>
<td>指向构造函数创建的实例</td>
</tr>
<tr>
<td>5. 通过，call ，apply ，bind 显示的指定 this指向</td>
<td>和传参有关</td>
</tr>
</tbody>
</table>
<p>Function.call</p>
<blockquote>
<p>语法：function.call(thisArg, arg1, arg2, …)，<code>thisArg</code>表示希望函数被调用的作用域，<code>arg1, arg2, …</code>表示希望被传入函数额参数 , 如果参数为空、<code>null</code>和<code>undefined</code>，则默认传入全局对象。</p>
</blockquote>
<p>代码示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var name = &apos;xiaomin&apos;</div><div class="line">var test = &#123;name : &apos;bbt&apos;&#125;</div><div class="line"></div><div class="line">function hello( _name )&#123;</div><div class="line">  _name ?console.log(this.name,_name): console.log(this.name)</div><div class="line">&#125;</div><div class="line"></div><div class="line">hello() //xiaomin</div><div class="line">hello.call(test) //bbt</div><div class="line">hello.call(test,&apos;xiaohong&apos;) //bbt xiaohong</div><div class="line">hello.call() //xiaomin</div><div class="line">hello.call(null) //xiaomin</div><div class="line">hello.call(undefined) //xiaomin</div></pre></td></tr></table></figure>
<p>Function.apply</p>
<blockquote>
<p>语法和<code>call</code> 方法类似，不同的是，传入调用函数的参数变成以数组的形式传入，即 func.apply(thisArg, [argsArray])</p>
</blockquote>
<p>改造上面的示例就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hello.apply(test,[&apos;xiaomin&apos;])</div></pre></td></tr></table></figure>
<p>Function.bind</p>
<blockquote>
<p><code>bind</code>方法用于将函数体内的<code>this</code>绑定到某个对象，然后返回一个新函数。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var d = new Date();</div><div class="line">d.getTime()</div><div class="line"></div><div class="line">var print = d.getTime; //赋值后 getTime 已经不指向 d 实例</div><div class="line">print() // Uncaught TypeError</div></pre></td></tr></table></figure>
<p>解决方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var print = d.getTime.bind(d)</div></pre></td></tr></table></figure>
<p>容易出错的地方</p>
<p>容易出错的地方，函数调用，<code>this</code> 总是指向 <code>window</code> 全局变量，所以在对象的方法里如果有函数的调用的话（闭包的情况），<code>this</code> 是会指向 全局对象的，不会指向调用的对象，具体示例如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var name = &apos;xiaomin&apos;</div><div class="line">var test = &#123;</div><div class="line">  name : &apos;bbt&apos;</div><div class="line">&#125;</div><div class="line">test.method = function()&#123;</div><div class="line">  function hello()&#123;</div><div class="line">      console.log(this.name)</div><div class="line">    &#125;</div><div class="line">    hello()</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 调用</div><div class="line">test.method() // 输出 xiaomin</div></pre></td></tr></table></figure>
<p>如果需要将 <code>this</code> 指向调用的对象，可以将对象的 <code>this</code> 指向存储起来，通常我们使用 <code>that</code> 变量来做这个存储。改进之后的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var name = &apos;xiaomin&apos;</div><div class="line">var test = &#123;</div><div class="line">  name : &apos;bbt&apos;</div><div class="line">&#125;</div><div class="line">test.method = function()&#123;</div><div class="line">  var that = this</div><div class="line">  function hello()&#123;</div><div class="line">      console.log(that.name)</div><div class="line">    &#125;</div><div class="line">    hello()</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 调用</div><div class="line">test.method() // 输出 bbt</div></pre></td></tr></table></figure>
<p>####闭包和引用</p>
<blockquote>
<p>闭包我们可以理解成是在函数内部定义的函数</p>
</blockquote>
<p>在 <code>javascript</code> 中，内部作用域可以访问到外部作用域的变量，但是外部作用域不能访问内部作用域，需要访问的时候，我们需要通过创建闭包，来操作内部变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function test(_count)&#123;</div><div class="line">  var count = _count</div><div class="line"></div><div class="line">  return &#123;</div><div class="line">    inc:function()&#123;</div><div class="line">      count++</div><div class="line">    &#125;,</div><div class="line">    get:function()&#123;</div><div class="line">      return count</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var a = test(4)</div><div class="line">a.get()//4</div><div class="line">a.inc()</div><div class="line">a.get()//5</div></pre></td></tr></table></figure>
<p>闭包中常会出错的面试题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for(var i = 0; i &lt; 10; i++) &#123;</div><div class="line">    setTimeout(function() &#123;</div><div class="line">        console.log(i);</div><div class="line">    &#125;, 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很多同学会觉得，上面的代码会正常输出0到9，但是实际是输出十次10。遇到这个题目，除了闭包的概念要理解清楚，你还需要知道，<code>setTimeout</code> 内的代码会被异步执行，代码会先执行所有的同步代码，即上面的这段代码会先将 <code>for</code> 循环执行，此时 <code>i</code> 的值为 10，console.log(i) 一直引用着全局变量的 i  所以会输出十次 10</p>
<p> 改进代码，我们在 <code>for</code> 循环里创建一个闭包，把循环自增的 <code>i</code> 作为参数传入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for(var i = 0; i &lt; 10; i++) &#123;</div><div class="line">    (function(e) &#123;</div><div class="line">        setTimeout(function() &#123;</div><div class="line">            console.log(e);</div><div class="line">        &#125;, 1000);</div><div class="line">    &#125;)(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="setTimeout-amp-amp-setInterval"><a href="#setTimeout-amp-amp-setInterval" class="headerlink" title="setTimeout &amp;&amp; setInterval"></a>setTimeout &amp;&amp; setInterval</h4><blockquote>
<p><code>javascript</code> 是异步的单线程运行语言，其他代码运行的时候可能会阻塞 <code>setTimeout</code> &amp;&amp; <code>setInterval</code> 的运行</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">console.log(1)</div><div class="line">setTimeout(function()&#123;</div><div class="line">  console.log(2)</div><div class="line">&#125;, 0);</div><div class="line">console.log(3)</div><div class="line"></div><div class="line">输出结果： 1，3，2  //setTimeout 被阻塞</div></pre></td></tr></table></figure>
<p>处理阻塞的方法是将<code>setTimeout</code> 和 <code>setInterval</code>放在回调函数里执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function test()&#123;</div><div class="line">  	setTimeout(function()&#123;</div><div class="line">  		console.log(2)</div><div class="line">	&#125;, 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>setTimeout</code> 和 <code>setInterval</code> 被调用时会返回一个 ID 用来清除定时器</p>
<p>手工清除某个定时器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var id = setTimeout(foo, 1000);</div><div class="line">clearTimeout(id);</div></pre></td></tr></table></figure>
<p>清楚所有的定时器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var lastId = setTimeout(function()&#123;</div><div class="line">  console.log(&apos;11&apos;)</div><div class="line">&#125;, 0);</div><div class="line"></div><div class="line">for(var i=0;i&lt;lastId;i++;)&#123;</div><div class="line">  clearTimeout(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>获取最后一个定时器的id，遍历清除定时器，可以清除所有的定时器。</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>####包装对象</p>
<blockquote>
<p>数值、字符串、布尔值——在一定条件下，也会自动转为对象，也就是原始类型的“包装对象”。</p>
</blockquote>
<p>我们可以通过构造函数，将原始类型转化为对应的对象即包装对象，从而是原始类型能够方便的调用某些方法</p>
<p>数值，字符串，布尔值的类型转换函数分别是 <code>Number，String，Boolean</code>，在调用的时候在函数前面加上New 就变成了构造函数，能够蒋对应的原始类型转化为“包装对象”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var v1 = new Number(123);</div><div class="line">var v2 = new String(&apos;abc&apos;);</div><div class="line">var v3 = new Boolean(true);</div><div class="line"></div><div class="line">typeof v1 // &quot;object&quot;</div><div class="line">typeof v2 // &quot;object&quot;</div><div class="line">typeof v3 // &quot;object&quot;</div><div class="line"></div><div class="line">v1 === 123 // false</div><div class="line">v2 === &apos;abc&apos; // false</div><div class="line">v3 === true // false</div></pre></td></tr></table></figure>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>类型转换分为强制类型转换和自动转换，<code>javascript</code> 是动态类型语言，在到吗解析运行时，需要的数据类型和传入的数据类型不一致的时候，<code>javascript</code> 会进行自动类型转化。当然，你也可以通过类型转换方法进行强制类型装换。</p>
<p>日常开发中，我们最常用的数据类型自动转换不过就下面三种情况</p>
<p>不同数据类型之间相互运算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&apos;2&apos;+4 // &apos;24&apos;</div></pre></td></tr></table></figure>
<p>对非布尔值进行布尔运算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if(&apos;22&apos;)&#123;</div><div class="line">  console.log(&apos;hello&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对非数据类型使用一元运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+&apos;12&apos;  //12</div></pre></td></tr></table></figure>
<p>我们也通过<code>Number ，String，Boolean</code> 来进行强制数据类型转换。强制类型转化的规则有点复杂，我们来了解一下。</p>
<p>Number 转换  <a href="http://javascript.ruanyifeng.com/grammar/conversion.html" target="_blank" rel="external">引用阮老师的详细解释</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">第一步，调用对象自身的valueOf方法。如果返回原始类型的值，则直接对该值使用Number函数，不再进行后续步骤。</div><div class="line"></div><div class="line">第二步，如果 valueOf 方法返回的还是对象，则改为调用对象自身的 toString 方法。如果 toString 方法返回原始类型的值，则对该值使用 Number 函数，不再进行后续步骤。</div><div class="line"></div><div class="line">第三步，如果 toString 方法返回的是对象，就报错。</div></pre></td></tr></table></figure>
<p><code>String</code> 转换方法同样也是通过调用原对象的 <code>toString</code> 方法和 <code>valueOf</code> 方法，但是不同的是 <code>String</code> 函数会先调用 <code>toString</code> 方法进行转换</p>
<p><code>Boolean</code> 的转换规则会相对简单一些，除了几个特殊的值，都会被转化为 <code>true</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">undefined</div><div class="line">null</div><div class="line">+0或-0</div><div class="line">NaN</div><div class="line">&apos;&apos;（空字符串）</div></pre></td></tr></table></figure>
<p>但是要注意</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Boolean(&apos;false&apos;) //true</div></pre></td></tr></table></figure>
<h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><blockquote>
<p><code>typeof</code> 操作符返回数据类型，但是由于 <code>javascript</code> 设计的历史原因，<code>typeof</code> 现已经不能满足我们现在对于类型判断的要求了</p>
</blockquote>
<table>
<thead>
<tr>
<th>Value</th>
<th>Class</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>“foo”</td>
<td>String</td>
<td>string</td>
</tr>
<tr>
<td>new String(“foo”)</td>
<td>String</td>
<td>object</td>
</tr>
<tr>
<td>1.2</td>
<td>Number</td>
<td>number</td>
</tr>
<tr>
<td>new Number(1.2)</td>
<td>Number</td>
<td>object</td>
</tr>
<tr>
<td>true</td>
<td>Boolean</td>
<td>boolean</td>
</tr>
<tr>
<td>new Boolean(true)</td>
<td>Boolean</td>
<td>object</td>
</tr>
<tr>
<td>new Date()</td>
<td>Date</td>
<td>object</td>
</tr>
<tr>
<td>new Error()</td>
<td>Error</td>
<td>object</td>
</tr>
<tr>
<td>[1,2,3]</td>
<td>Array</td>
<td>object</td>
</tr>
<tr>
<td>new Array(1, 2, 3)</td>
<td>Array</td>
<td>object</td>
</tr>
<tr>
<td>new Function(“”)</td>
<td>Function</td>
<td>functio</td>
</tr>
<tr>
<td>/abc/g</td>
<td>RegExp</td>
<td>object (function in Nitro/V8)</td>
</tr>
<tr>
<td>new RegExp(“meow”)</td>
<td>RegExp</td>
<td>object (function in Nitro/V8)</td>
</tr>
<tr>
<td>{}</td>
<td>Object</td>
<td>object</td>
</tr>
<tr>
<td>new Object()</td>
<td>Object</td>
<td>object</td>
</tr>
<tr>
<td>null</td>
<td>null</td>
<td>object</td>
</tr>
</tbody>
</table>
<p>我们可以看到，<code>typeof</code> 不能区分对象的数组和日期，还会把 <code>null</code> 判断成对象，那我们一般是什么时候用 <code>typeof</code> 呢。我们可以用来判断一个已经定义的变量是否被赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a</div><div class="line">if(typeof a == &apos;undefined&apos;)&#123;</div><div class="line">  console.log(&apos;a 已经被定义&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><blockquote>
<p><code>instanceof</code> 操作符通常用来判断，一个对象是否在另一个对象的原型链上，需要注意的是 <code>instanceof</code> 的左值是对象，右值是构造函数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// defining constructors</div><div class="line">function C() &#123;&#125;</div><div class="line">function D() &#123;&#125;</div><div class="line"></div><div class="line">var o = new C();</div><div class="line"></div><div class="line">// true, because: Object.getPrototypeOf(o) === C.prototype</div><div class="line">o instanceof C;</div><div class="line"></div><div class="line">// false, because D.prototype is nowhere in o&apos;s prototype chain</div><div class="line">o instanceof D;</div></pre></td></tr></table></figure>
<h4 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a>Object.prototype.toString</h4><blockquote>
<p>那么我们有没有可以用来区分变量数据类型的方法呢，有，<code>Object.prototype.toString</code></p>
</blockquote>
<p>一些原始数据类型也有 <code>toString</code> 方法，但是通常他们的 <code>toString</code> 方法都是改造过的，不能进行 数据类型判断，所以我们需要用 <code>Object</code> 原型链上的 <code>toString</code> 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a = 1234</div><div class="line">a.toString() // &apos;1234&apos;</div><div class="line"></div><div class="line">Object.prototype.toString.call(a) // &quot;[object Number]&quot;</div></pre></td></tr></table></figure>
<p> 不同类型返回的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">1. 数值 [object Number]</div><div class="line">2. 字符串 [object String]</div><div class="line">3.布尔值 [object Boolean]</div><div class="line">4.undefined [object undefined]</div><div class="line">5.null  [object Null]</div><div class="line">6.数组 [object Array]</div><div class="line">7.arguments [object Arguments]</div><div class="line">8.函数 [object function]</div><div class="line">9.Error [object Error]</div><div class="line">10.Date [object Date]</div><div class="line">11.RegExp [object RegExp]</div><div class="line">12.其他对象 [object object]</div></pre></td></tr></table></figure>
<p>那么我们就能够通过 <code>Object.prototype.toString</code> 方法，封装一个可以判断变量数据类型的函数了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function type(obj) &#123;</div><div class="line">    return Object.prototype.toString.call(obj).slice(8, -1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">type(function()&#123;&#125;) //&quot;Function&quot;</div></pre></td></tr></table></figure>
<blockquote>
<p>这次我们从对象、函数、类型三方面入手了解了<code>javascript</code> 中容易被忽视或则说比较难理解的地方，我会继续将我在学习中积累的内容分享给大家，如果大家觉得文章有需要改进或则有其他想要了解的内容的，欢迎私信，评论或则微信我，我的微信是：646321933</p>
</blockquote>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/javascript/" rel="tag"># javascript</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/28/sanya/" rel="next" title="三亚之旅">
                <i class="fa fa-chevron-left"></i> 三亚之旅
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/04/28/history/" rel="prev" title="你需要知道的单页面路由实现原理">
                你需要知道的单页面路由实现原理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2018/04/02/javascript-notes/"
           data-title="你需要知道的 javascript 的细节" data-url="https://bailinlin.github.com/2018/04/02/javascript-notes/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/bbt.jpeg"
               alt="bailinlin" />
          <p class="site-author-name" itemprop="name">bailinlin</p>
          <p class="site-description motion-element" itemprop="description">前端,白霸天,博客</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">16</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#对象"><span class="nav-number">1.</span> <span class="nav-text">对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#变量可以当对象使用"><span class="nav-number">1.1.</span> <span class="nav-text">变量可以当对象使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象删除属性"><span class="nav-number">1.2.</span> <span class="nav-text">对象删除属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造函数"><span class="nav-number">1.3.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原型继承"><span class="nav-number">1.4.</span> <span class="nav-text">原型继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#获取自身对象属性"><span class="nav-number">1.5.</span> <span class="nav-text">获取自身对象属性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数"><span class="nav-number">2.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数声明的变量提升"><span class="nav-number">2.1.</span> <span class="nav-text">函数声明的变量提升</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#this-的工作原理"><span class="nav-number">2.2.</span> <span class="nav-text">this 的工作原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setTimeout-amp-amp-setInterval"><span class="nav-number">2.3.</span> <span class="nav-text">setTimeout && setInterval</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型"><span class="nav-number">3.</span> <span class="nav-text">类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#类型转换"><span class="nav-number">3.1.</span> <span class="nav-text">类型转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#typeof"><span class="nav-number">3.2.</span> <span class="nav-text">typeof</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#instanceof"><span class="nav-number">3.3.</span> <span class="nav-text">instanceof</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-prototype-toString"><span class="nav-number">3.4.</span> <span class="nav-text">Object.prototype.toString</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bailinlin</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"baibatian"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  








  
  

  

  

  

  


</body>
</html>
