<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="前端,白霸天,博客">
<meta property="og:type" content="website">
<meta property="og:title" content="白霸天的博客">
<meta property="og:url" content="https://bailinlin.github.com/page/2/index.html">
<meta property="og:site_name" content="白霸天的博客">
<meta property="og:description" content="前端,白霸天,博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="白霸天的博客">
<meta name="twitter:description" content="前端,白霸天,博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://bailinlin.github.com/page/2/"/>





  <title> 白霸天的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">白霸天的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2018/04/02/javascript-notes/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/02/javascript-notes/" itemprop="url">
                  你需要知道的 javascript 的细节
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-02T17:27:29+08:00">
                2018-04-02
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2018/04/02/javascript-notes/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/04/02/javascript-notes/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>现在的前端框架层出不穷，3个月就要重新入门一次前端的现状，让我们来不及学好基础就开始上手框架。常常就因为这样，我们会很快到达基础<code>技术瓶颈</code>，基础是所有技术的核心，在跳槽季重新温故了一遍 javascript 基础，有收获，整理出来分享给大家。</p>
</blockquote>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="变量可以当对象使用"><a href="#变量可以当对象使用" class="headerlink" title="变量可以当对象使用"></a>变量可以当对象使用</h4><p><code>javascript</code> 中所有的变量都可以当做对象使用，除了<code>undefined</code> 和 <code>null</code> ，我们测试下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">false.toString() // &quot;false&quot;</div><div class="line"></div><div class="line">[1,2,3].toString() //&quot;1,2,3&quot;</div><div class="line"></div><div class="line">1..toString() //&quot;1&quot;</div><div class="line"></div><div class="line">(&#123;a:&apos;33&apos;&#125;).toString() //&quot;[object Object]&quot;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">undefined.toString() //Uncaught TypeError</div><div class="line"></div><div class="line">null.toString()   //Uncaught TypeError</div></pre></td></tr></table></figure>
<p>数值和对象虽然能调用 <code>toString</code> 方法，但是在写法上需要注意下</p>
<p><code>number</code> 调用时不能直接数值后面直接调用<code>toString</code> 方法，因为 <code>js</code> 会将点运算符解析为数值的小数点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.toString() //Uncaught SyntaxError</div><div class="line"></div><div class="line">1..toString() //&quot;1&quot;</div></pre></td></tr></table></figure>
<p>对象直接调用<code>toString</code> 方法时，需要用小括号包裹起来，不然<code>js</code> 会将对象的花括号识别成块，从而报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;a:&apos;33&apos;&#125;.toString()  // Uncaught SyntaxError</div><div class="line"></div><div class="line">(&#123;a:&apos;33&apos;&#125;).toString() // &quot;[object Object]&quot;</div></pre></td></tr></table></figure>
<h4 id="对象删除属性"><a href="#对象删除属性" class="headerlink" title="对象删除属性"></a>对象删除属性</h4><blockquote>
<p>删除对象的属性唯一的方法是使用 <code>delete</code> 操作符，设置元素属性为 <code>undefined</code> 或则 <code>null</code> 并不能真正删除，只是移除了属性和值的关联</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var test = &#123;</div><div class="line">	name:&apos;bbt&apos;,</div><div class="line">	age:&apos;18&apos;,</div><div class="line">	love:&apos;dog&apos;</div><div class="line">&#125;</div><div class="line"></div><div class="line">test.name = undefined</div><div class="line">test.age = null</div><div class="line">delete test.love</div><div class="line"></div><div class="line">for (var i in test)&#123;</div><div class="line">  console.log(i+&apos;:&apos;+test[i])</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">name:undefined</div><div class="line">age:null</div><div class="line">undefined</div></pre></td></tr></table></figure>
<p>只有 <code>love</code> 被正则删除，<code>name</code> 和 <code>age</code> 还是能被遍历到</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><blockquote>
<p>在 <code>javascript</code> 中，通过关键字 <code>new</code> 调用的函数就被认为是构造函数，我们可以通过构造函数创建对象实例</p>
</blockquote>
<p>但是在使用过程中你一定发现了，每实例化一个对象，都会在实例对象上创造构造函数的方法和属性。倘若创建的实例比较多，重复创建同一个方法去开辟内存空间就会显得十分浪费，我们可以通过把被经常复用的方法放在原型链上。</p>
<h4 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h4><blockquote>
<p><code>javascript</code> 和一些我们所了解的面向对象编程的语言不太一样，在 <code>es6</code> 语法以前，我们是通过原型链来实现方法和属性的继承</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">function Child()&#123;</div><div class="line">  this.name = &apos;bbt&apos;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Child.prototype = &#123;</div><div class="line">	title:&apos;baba&apos;,</div><div class="line">    method: function() &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function Grandson()&#123;&#125;</div><div class="line"></div><div class="line">//设置 Grandson 的 prototype 为 Child 的实例</div><div class="line">Grandson.prototype = new Child()</div><div class="line"></div><div class="line">//为 Grandson 的原型添加添加属性 age</div><div class="line">Grandson.prototype.age = 40</div><div class="line"></div><div class="line">// 修正 Grandson.prototype.constructor 为 Grandson 本身</div><div class="line">Grandson.prototype.constructor = Grandson;</div><div class="line"></div><div class="line">var xiaomin = new Grandson()</div><div class="line"></div><div class="line">//原型链如下</div><div class="line">xiaomin // Grandson的实例</div><div class="line">    Grandson.prototype // Child的实例</div><div class="line">         Grandson.prototype //&#123;title:&apos;baba&apos;,...&#125;</div><div class="line">            Object.prototype</div><div class="line">                &#123;toString: ... /* etc. */&#125;;</div></pre></td></tr></table></figure>
<p>对象的属性查找，<code>javascript</code> 会在原型链上向上查找属性，直到查到 原型链顶部，所以，属性在原型链的越上端，查找的时间会越长，查找性能和复用属性方面需要开发者自己衡量下。</p>
<h4 id="获取自身对象属性"><a href="#获取自身对象属性" class="headerlink" title="获取自身对象属性"></a>获取自身对象属性</h4><p><code>hasOwnProperty</code> 方法能够判断一个对象是否包含自定义属性，而不是在原型链上的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var test = &#123;hello:&apos;123&apos;&#125;</div><div class="line"></div><div class="line">Object.prototype.name = &apos;bbt&apos;</div><div class="line"></div><div class="line">test.name  //&apos;bbt&apos;</div><div class="line">test.hasOwnProperty(&apos;hello&apos;) //true</div><div class="line">test.hasOwnProperty(&apos;name&apos;) //false</div></pre></td></tr></table></figure>
<p><code>for in</code> 循环可以遍历对象原型链上的所有属性，如此我们将 <code>hasOwnProperty</code>结合循环<code>for in</code> 能够获取到对象自定义属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var test = &#123;hello:&apos;222&apos;&#125;</div><div class="line">Object.prototype.name = &apos;bbt&apos;</div><div class="line"></div><div class="line">for(var i in test)&#123;</div><div class="line">  console.log(i) // 输出两个属性，hello ，name</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">for(var i in test)&#123;</div><div class="line">  if(test.hasOwnProperty(i))&#123;</div><div class="line">    console.log(i)//只输出 hello</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了上面的方法，<code>getOwnPropertyNames</code> 和 <code>Object.keys</code> 方法，能够返回对象自身的所有属性名，也是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有属性名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var test = &#123;hello:&apos;222&apos;&#125;</div><div class="line">Object.prototype.name = &apos;bbt&apos;</div><div class="line"></div><div class="line">Object.keys(test) //[&quot;hello&quot;]</div><div class="line">Object.getOwnPropertyNames(test) //[&quot;hello&quot;]</div></pre></td></tr></table></figure>
<p>那 <code>getOwnPropertyNames</code> 和 <code>Object.keys</code> 的用法有什么区别呢</p>
<p><code>Object.keys</code>方法只返回可枚举的属性，<code>Object.getOwnPropertyNames</code>  方法还返回不可枚举的属性名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var a = [&apos;Hello&apos;, &apos;World&apos;];</div><div class="line"></div><div class="line">Object.keys(a) // [&quot;0&quot;, &quot;1&quot;]</div><div class="line"></div><div class="line">Object.getOwnPropertyNames(a) // [&quot;0&quot;, &quot;1&quot;, &quot;length&quot;]  // length 是不可枚举属性</div></pre></td></tr></table></figure>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="函数声明的变量提升"><a href="#函数声明的变量提升" class="headerlink" title="函数声明的变量提升"></a>函数声明的变量提升</h4><p>我们通常会使用函数声明或函数赋值表达式来定义一个函数，函数声明和变量声明一样都存在提升的情况，函数可以在声明前调用，但是不可以在赋值前调用</p>
<p>函数声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">foo(); // 正常运行，因为foo在代码运行前已经被创建</div><div class="line">function foo() &#123;&#125;</div></pre></td></tr></table></figure>
<p>函数表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">foo; // &apos;undefined&apos;</div><div class="line">foo(); // 出错：TypeError</div><div class="line">var foo = function() &#123;&#125;;</div></pre></td></tr></table></figure>
<p>变量提升是在代码解析的时候进行的，foo() 方法调用的时候，已经在解析阶段将 foo 定义过了。赋值语句只在代码运行时才进行，所以在赋值前调用会报错</p>
<p>一种比较少用的函数赋值操作，将命名函数赋值给一个变量，此时的函数名只对函数内部可见</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var test = function foo()&#123;</div><div class="line">  console.log(foo) //正常输出</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log(foo) //Uncaught ReferenceError</div></pre></td></tr></table></figure>
<h4 id="this-的工作原理"><a href="#this-的工作原理" class="headerlink" title="this 的工作原理"></a>this 的工作原理</h4><blockquote>
<p>在 <code>javascript</code> 中 ，<code>this</code> 是一个比较难理解的点，不同的调用环境会导致 <code>this</code> 的不同指向，但是唯一不变的是 <code>this</code> 总是指向一个对象</p>
</blockquote>
<p>简单的说，<code>this</code> 就是属性和方法当前所在的对象（函数执行坐在的作用域），平时使用的 <code>this</code>  的情况可以大致分为5种</p>
<table>
<thead>
<tr>
<th>调用方式</th>
<th>指向</th>
</tr>
</thead>
<tbody>
<tr>
<td>1. 全局范围调用</td>
<td>指向 window 全局对象</td>
</tr>
<tr>
<td>2. 函数调用</td>
<td>指向 window 全局变量</td>
</tr>
<tr>
<td>3. 对象的方法调用</td>
<td>指向方法调用的对象</td>
</tr>
<tr>
<td>4. 构造函数调用</td>
<td>指向构造函数创建的实例</td>
</tr>
<tr>
<td>5. 通过，call ，apply ，bind 显示的指定 this指向</td>
<td>和传参有关</td>
</tr>
</tbody>
</table>
<p>Function.call</p>
<blockquote>
<p>语法：function.call(thisArg, arg1, arg2, …)，<code>thisArg</code>表示希望函数被调用的作用域，<code>arg1, arg2, …</code>表示希望被传入函数额参数 , 如果参数为空、<code>null</code>和<code>undefined</code>，则默认传入全局对象。</p>
</blockquote>
<p>代码示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var name = &apos;xiaomin&apos;</div><div class="line">var test = &#123;name : &apos;bbt&apos;&#125;</div><div class="line"></div><div class="line">function hello( _name )&#123;</div><div class="line">  _name ?console.log(this.name,_name): console.log(this.name)</div><div class="line">&#125;</div><div class="line"></div><div class="line">hello() //xiaomin</div><div class="line">hello.call(test) //bbt</div><div class="line">hello.call(test,&apos;xiaohong&apos;) //bbt xiaohong</div><div class="line">hello.call() //xiaomin</div><div class="line">hello.call(null) //xiaomin</div><div class="line">hello.call(undefined) //xiaomin</div></pre></td></tr></table></figure>
<p>Function.apply</p>
<blockquote>
<p>语法和<code>call</code> 方法类似，不同的是，传入调用函数的参数变成以数组的形式传入，即 func.apply(thisArg, [argsArray])</p>
</blockquote>
<p>改造上面的示例就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hello.apply(test,[&apos;xiaomin&apos;])</div></pre></td></tr></table></figure>
<p>Function.bind</p>
<blockquote>
<p><code>bind</code>方法用于将函数体内的<code>this</code>绑定到某个对象，然后返回一个新函数。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var d = new Date();</div><div class="line">d.getTime()</div><div class="line"></div><div class="line">var print = d.getTime; //赋值后 getTime 已经不指向 d 实例</div><div class="line">print() // Uncaught TypeError</div></pre></td></tr></table></figure>
<p>解决方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var print = d.getTime.bind(d)</div></pre></td></tr></table></figure>
<p>容易出错的地方</p>
<p>容易出错的地方，函数调用，<code>this</code> 总是指向 <code>window</code> 全局变量，所以在对象的方法里如果有函数的调用的话（闭包的情况），<code>this</code> 是会指向 全局对象的，不会指向调用的对象，具体示例如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var name = &apos;xiaomin&apos;</div><div class="line">var test = &#123;</div><div class="line">  name : &apos;bbt&apos;</div><div class="line">&#125;</div><div class="line">test.method = function()&#123;</div><div class="line">  function hello()&#123;</div><div class="line">      console.log(this.name)</div><div class="line">    &#125;</div><div class="line">    hello()</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 调用</div><div class="line">test.method() // 输出 xiaomin</div></pre></td></tr></table></figure>
<p>如果需要将 <code>this</code> 指向调用的对象，可以将对象的 <code>this</code> 指向存储起来，通常我们使用 <code>that</code> 变量来做这个存储。改进之后的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var name = &apos;xiaomin&apos;</div><div class="line">var test = &#123;</div><div class="line">  name : &apos;bbt&apos;</div><div class="line">&#125;</div><div class="line">test.method = function()&#123;</div><div class="line">  var that = this</div><div class="line">  function hello()&#123;</div><div class="line">      console.log(that.name)</div><div class="line">    &#125;</div><div class="line">    hello()</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 调用</div><div class="line">test.method() // 输出 bbt</div></pre></td></tr></table></figure>
<p>####闭包和引用</p>
<blockquote>
<p>闭包我们可以理解成是在函数内部定义的函数</p>
</blockquote>
<p>在 <code>javascript</code> 中，内部作用域可以访问到外部作用域的变量，但是外部作用域不能访问内部作用域，需要访问的时候，我们需要通过创建闭包，来操作内部变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function test(_count)&#123;</div><div class="line">  var count = _count</div><div class="line"></div><div class="line">  return &#123;</div><div class="line">    inc:function()&#123;</div><div class="line">      count++</div><div class="line">    &#125;,</div><div class="line">    get:function()&#123;</div><div class="line">      return count</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var a = test(4)</div><div class="line">a.get()//4</div><div class="line">a.inc()</div><div class="line">a.get()//5</div></pre></td></tr></table></figure>
<p>闭包中常会出错的面试题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for(var i = 0; i &lt; 10; i++) &#123;</div><div class="line">    setTimeout(function() &#123;</div><div class="line">        console.log(i);</div><div class="line">    &#125;, 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很多同学会觉得，上面的代码会正常输出0到9，但是实际是输出十次10。遇到这个题目，除了闭包的概念要理解清楚，你还需要知道，<code>setTimeout</code> 内的代码会被异步执行，代码会先执行所有的同步代码，即上面的这段代码会先将 <code>for</code> 循环执行，此时 <code>i</code> 的值为 10，console.log(i) 一直引用着全局变量的 i  所以会输出十次 10</p>
<p> 改进代码，我们在 <code>for</code> 循环里创建一个闭包，把循环自增的 <code>i</code> 作为参数传入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for(var i = 0; i &lt; 10; i++) &#123;</div><div class="line">    (function(e) &#123;</div><div class="line">        setTimeout(function() &#123;</div><div class="line">            console.log(e);</div><div class="line">        &#125;, 1000);</div><div class="line">    &#125;)(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="setTimeout-amp-amp-setInterval"><a href="#setTimeout-amp-amp-setInterval" class="headerlink" title="setTimeout &amp;&amp; setInterval"></a>setTimeout &amp;&amp; setInterval</h4><blockquote>
<p><code>javascript</code> 是异步的单线程运行语言，其他代码运行的时候可能会阻塞 <code>setTimeout</code> &amp;&amp; <code>setInterval</code> 的运行</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">console.log(1)</div><div class="line">setTimeout(function()&#123;</div><div class="line">  console.log(2)</div><div class="line">&#125;, 0);</div><div class="line">console.log(3)</div><div class="line"></div><div class="line">输出结果： 1，3，2  //setTimeout 被阻塞</div></pre></td></tr></table></figure>
<p>处理阻塞的方法是将<code>setTimeout</code> 和 <code>setInterval</code>放在回调函数里执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function test()&#123;</div><div class="line">  	setTimeout(function()&#123;</div><div class="line">  		console.log(2)</div><div class="line">	&#125;, 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>setTimeout</code> 和 <code>setInterval</code> 被调用时会返回一个 ID 用来清除定时器</p>
<p>手工清除某个定时器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var id = setTimeout(foo, 1000);</div><div class="line">clearTimeout(id);</div></pre></td></tr></table></figure>
<p>清楚所有的定时器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var lastId = setTimeout(function()&#123;</div><div class="line">  console.log(&apos;11&apos;)</div><div class="line">&#125;, 0);</div><div class="line"></div><div class="line">for(var i=0;i&lt;lastId;i++;)&#123;</div><div class="line">  clearTimeout(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>获取最后一个定时器的id，遍历清除定时器，可以清除所有的定时器。</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>####包装对象</p>
<blockquote>
<p>数值、字符串、布尔值——在一定条件下，也会自动转为对象，也就是原始类型的“包装对象”。</p>
</blockquote>
<p>我们可以通过构造函数，将原始类型转化为对应的对象即包装对象，从而是原始类型能够方便的调用某些方法</p>
<p>数值，字符串，布尔值的类型转换函数分别是 <code>Number，String，Boolean</code>，在调用的时候在函数前面加上New 就变成了构造函数，能够蒋对应的原始类型转化为“包装对象”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var v1 = new Number(123);</div><div class="line">var v2 = new String(&apos;abc&apos;);</div><div class="line">var v3 = new Boolean(true);</div><div class="line"></div><div class="line">typeof v1 // &quot;object&quot;</div><div class="line">typeof v2 // &quot;object&quot;</div><div class="line">typeof v3 // &quot;object&quot;</div><div class="line"></div><div class="line">v1 === 123 // false</div><div class="line">v2 === &apos;abc&apos; // false</div><div class="line">v3 === true // false</div></pre></td></tr></table></figure>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>类型转换分为强制类型转换和自动转换，<code>javascript</code> 是动态类型语言，在到吗解析运行时，需要的数据类型和传入的数据类型不一致的时候，<code>javascript</code> 会进行自动类型转化。当然，你也可以通过类型转换方法进行强制类型装换。</p>
<p>日常开发中，我们最常用的数据类型自动转换不过就下面三种情况</p>
<p>不同数据类型之间相互运算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&apos;2&apos;+4 // &apos;24&apos;</div></pre></td></tr></table></figure>
<p>对非布尔值进行布尔运算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if(&apos;22&apos;)&#123;</div><div class="line">  console.log(&apos;hello&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对非数据类型使用一元运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+&apos;12&apos;  //12</div></pre></td></tr></table></figure>
<p>我们也通过<code>Number ，String，Boolean</code> 来进行强制数据类型转换。强制类型转化的规则有点复杂，我们来了解一下。</p>
<p>Number 转换  <a href="http://javascript.ruanyifeng.com/grammar/conversion.html" target="_blank" rel="external">引用阮老师的详细解释</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">第一步，调用对象自身的valueOf方法。如果返回原始类型的值，则直接对该值使用Number函数，不再进行后续步骤。</div><div class="line"></div><div class="line">第二步，如果 valueOf 方法返回的还是对象，则改为调用对象自身的 toString 方法。如果 toString 方法返回原始类型的值，则对该值使用 Number 函数，不再进行后续步骤。</div><div class="line"></div><div class="line">第三步，如果 toString 方法返回的是对象，就报错。</div></pre></td></tr></table></figure>
<p><code>String</code> 转换方法同样也是通过调用原对象的 <code>toString</code> 方法和 <code>valueOf</code> 方法，但是不同的是 <code>String</code> 函数会先调用 <code>toString</code> 方法进行转换</p>
<p><code>Boolean</code> 的转换规则会相对简单一些，除了几个特殊的值，都会被转化为 <code>true</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">undefined</div><div class="line">null</div><div class="line">+0或-0</div><div class="line">NaN</div><div class="line">&apos;&apos;（空字符串）</div></pre></td></tr></table></figure>
<p>但是要注意</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Boolean(&apos;false&apos;) //true</div></pre></td></tr></table></figure>
<h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><blockquote>
<p><code>typeof</code> 操作符返回数据类型，但是由于 <code>javascript</code> 设计的历史原因，<code>typeof</code> 现已经不能满足我们现在对于类型判断的要求了</p>
</blockquote>
<table>
<thead>
<tr>
<th>Value</th>
<th>Class</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>“foo”</td>
<td>String</td>
<td>string</td>
</tr>
<tr>
<td>new String(“foo”)</td>
<td>String</td>
<td>object</td>
</tr>
<tr>
<td>1.2</td>
<td>Number</td>
<td>number</td>
</tr>
<tr>
<td>new Number(1.2)</td>
<td>Number</td>
<td>object</td>
</tr>
<tr>
<td>true</td>
<td>Boolean</td>
<td>boolean</td>
</tr>
<tr>
<td>new Boolean(true)</td>
<td>Boolean</td>
<td>object</td>
</tr>
<tr>
<td>new Date()</td>
<td>Date</td>
<td>object</td>
</tr>
<tr>
<td>new Error()</td>
<td>Error</td>
<td>object</td>
</tr>
<tr>
<td>[1,2,3]</td>
<td>Array</td>
<td>object</td>
</tr>
<tr>
<td>new Array(1, 2, 3)</td>
<td>Array</td>
<td>object</td>
</tr>
<tr>
<td>new Function(“”)</td>
<td>Function</td>
<td>functio</td>
</tr>
<tr>
<td>/abc/g</td>
<td>RegExp</td>
<td>object (function in Nitro/V8)</td>
</tr>
<tr>
<td>new RegExp(“meow”)</td>
<td>RegExp</td>
<td>object (function in Nitro/V8)</td>
</tr>
<tr>
<td>{}</td>
<td>Object</td>
<td>object</td>
</tr>
<tr>
<td>new Object()</td>
<td>Object</td>
<td>object</td>
</tr>
<tr>
<td>null</td>
<td>null</td>
<td>object</td>
</tr>
</tbody>
</table>
<p>我们可以看到，<code>typeof</code> 不能区分对象的数组和日期，还会把 <code>null</code> 判断成对象，那我们一般是什么时候用 <code>typeof</code> 呢。我们可以用来判断一个已经定义的变量是否被赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a</div><div class="line">if(typeof a == &apos;undefined&apos;)&#123;</div><div class="line">  console.log(&apos;a 已经被定义&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><blockquote>
<p><code>instanceof</code> 操作符通常用来判断，一个对象是否在另一个对象的原型链上，需要注意的是 <code>instanceof</code> 的左值是对象，右值是构造函数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// defining constructors</div><div class="line">function C() &#123;&#125;</div><div class="line">function D() &#123;&#125;</div><div class="line"></div><div class="line">var o = new C();</div><div class="line"></div><div class="line">// true, because: Object.getPrototypeOf(o) === C.prototype</div><div class="line">o instanceof C;</div><div class="line"></div><div class="line">// false, because D.prototype is nowhere in o&apos;s prototype chain</div><div class="line">o instanceof D;</div></pre></td></tr></table></figure>
<h4 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a>Object.prototype.toString</h4><blockquote>
<p>那么我们有没有可以用来区分变量数据类型的方法呢，有，<code>Object.prototype.toString</code></p>
</blockquote>
<p>一些原始数据类型也有 <code>toString</code> 方法，但是通常他们的 <code>toString</code> 方法都是改造过的，不能进行 数据类型判断，所以我们需要用 <code>Object</code> 原型链上的 <code>toString</code> 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a = 1234</div><div class="line">a.toString() // &apos;1234&apos;</div><div class="line"></div><div class="line">Object.prototype.toString.call(a) // &quot;[object Number]&quot;</div></pre></td></tr></table></figure>
<p> 不同类型返回的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">1. 数值 [object Number]</div><div class="line">2. 字符串 [object String]</div><div class="line">3.布尔值 [object Boolean]</div><div class="line">4.undefined [object undefined]</div><div class="line">5.null  [object Null]</div><div class="line">6.数组 [object Array]</div><div class="line">7.arguments [object Arguments]</div><div class="line">8.函数 [object function]</div><div class="line">9.Error [object Error]</div><div class="line">10.Date [object Date]</div><div class="line">11.RegExp [object RegExp]</div><div class="line">12.其他对象 [object object]</div></pre></td></tr></table></figure>
<p>那么我们就能够通过 <code>Object.prototype.toString</code> 方法，封装一个可以判断变量数据类型的函数了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function type(obj) &#123;</div><div class="line">    return Object.prototype.toString.call(obj).slice(8, -1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">type(function()&#123;&#125;) //&quot;Function&quot;</div></pre></td></tr></table></figure>
<blockquote>
<p>这次我们从对象、函数、类型三方面入手了解了<code>javascript</code> 中容易被忽视或则说比较难理解的地方，我会继续将我在学习中积累的内容分享给大家，如果大家觉得文章有需要改进或则有其他想要了解的内容的，欢迎私信，评论或则微信我，我的微信是：646321933</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2018/03/28/sanya/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/28/sanya/" itemprop="url">
                  三亚之旅
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-28T16:31:57+08:00">
                2018-03-28
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2018/03/28/sanya/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/03/28/sanya/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>大家总说，身体和心灵需要有一个在路上。读书不一定所有的人都能喜欢，但是旅行绝对是每一个年龄阶段的人都不会拒绝的的一种亦或是放松亦或是长见识的方式，如果说优缺点的话，那应该就是心疼钱了。我很喜欢旅游，我觉得每年一次旅行是必要的。</p>
</blockquote>
<p>旅行一般我都是临时起意的，看到哪里的机票便宜了，就买了准备走，所以我还是比较倾向于不需要办签证的地方，比如济州岛，或则国内。这次我们去了三亚。</p>
<p>因为是自由行，去之前做了一些粗略的攻略，确定几个自己想要游玩的景点。但是这次行程除了入住的地方和攻略是一致的，其他的都没有按照攻略来。</p>
<p>攻略是按照窝蜂上的推荐景点排序进行筛选的，但是到三亚的时候，当地居民推荐了我去其他景点，游客少的，消费更低一些的。</p>
<p>机票是在携程上买的，杭州出发到海口，海口动车到三亚（别问为啥不直飞，因为穷，哈哈哈）海口的火车站和飞机场在一个地方，掐着点的话，下飞机一个半小时就能到三亚了。担心飞机晚点问题，还有到机场需要去提行李，所以没有提前买动车票，到站买了最近一趟去三亚，所以下飞机后我们在火车站逗留了大概一个小时才出发去三亚。</p>
<h2 id="D1"><a href="#D1" class="headerlink" title="D1"></a>D1</h2><p>飞机是上午6点出发，8点55到海口，坐动车到三亚的时候已经是12点了，入住房间刚好，我们把房间定在三亚湾，190 一晚的海景房（一室一厅一厨一卫）感觉性价超级高，三亚的物价没有特别高，溜达的时候，有看到布丁酒店100多一晚的房间，但是不是在海边，具体房间是怎么样的，我也不太清楚，如果预算不够的话，可以住这种的。</p>
<p>因为出门就能到海边，虽然肚子有点饿，我们没有马上去觅食，而是去海边小坐了一会，没有坐太久，因为大中午的实在太热了，哈哈。在沙滩上看到了几个皮肤十分黑的男人在光着屁股晒太阳，以为是外国黑人，还在感叹他们奔放的时候发现其实是三亚本地人，脸上3条黑线</p>
<p>三亚湾上街购物和吃放也很方便，过一条马路就能到热闹的地方去，因为没有在淘宝上挑到自己喜欢的草帽，所以没有带，三亚很晒，所以在逛当地礼品店的时候买了一个，15块钱，和淘宝的价格差不多，没有很宰客，后面又买了一个自拍杆，20块，比淘宝上买略贵一些。</p>
<p>中午随便吃的重庆小面，2人吃了30多，这个比在杭州吃的时候贵一丢丢，在杭州吃可能 20多就搞定了。也说不上来，可能这个不是三亚本地的吃食吧，所以要贵一些，三亚的海鲜和热带水果还是很便宜的。</p>
<p>因为第一天早上为了赶飞机，3点多就起来了，我们两个都有点累，本来这一天也没有很特别的行程安排，所以我们就在酒店睡了一下午，晚上的时候本来想随意吃点，逛到了海鲜加工市场，就在市场里买了活海鲜加工着吃，2个人一共吃了300块，因为没有挑加工店，随意没有特别好吃也没有特别难吃，如果你们去的话，还是建议去第一海鲜市场，挑个开的时间长的加工店，</p>
<p>晚上我们吃完饭又去沙滩上坐了会，穿着拖鞋去海棠踏浪。快到10点的时候准备回房间，在沿着海滩边上的路牙上有好多大姐大妈在按摩，20块钱可以按20分钟，挺舒服的。</p>
<p><img src="/images/travel/yz.jpeg" alt="三亚路牙子"></p>
<h2 id="D2"><a href="#D2" class="headerlink" title="D2"></a>D2</h2><p>第二天，我们睡到9点起，打算坐公交车去亚龙湾潜水，在等公交的时候有个大叔问我们去哪，可以送。开始以为是黄牛，有点不太想搭理他。他和我们说可以送我们去亚龙湾，带我们去售票点买票，他们是通过带人去售票店买票积分，然后领礼品的。他和我们说潜水的话，亚龙湾398可以潜，水上项目想多玩点的话，可以去西岛，西岛的套票是 980 可以玩18项。送我们去西岛的话只要每人5块的路费</p>
<p>我们想着，反正也来了，就去多玩点吧，亚龙湾是在三亚的海岸边，海水可能也会比较浑浊，出海到岛上潜水体验应该能好点。于是我们坐了他老婆的车到西岛售票处，车子沿着海边开了半个小时左右，5块一个人的路费真是良心价。</p>
<p>到西岛后，我们买了980 的套票，里面包括珊瑚礁潜水，保礁潜水，香蕉船，飞鱼船，快艇，观光艇，划伞，中午的自助餐，鱼疗和台风体验等小项目，也不是所有的项目都好玩，一半一半吧，反正这么买套票我觉得是十分划算的</p>
<p>我们上岛第一个玩的项目是潜水，潜水有潜水服，但是你还是要穿自己的泳衣在里面，玩其他水上项目也会把衣服弄湿，所以潜完之后，你可以不换衣服，直接去玩其他水上项目了。</p>
<p>潜水很好玩，潜水前教练会教你一些简单的手势动作，全程教练牵着你移动，所以即使不会游泳也没有关系。潜水的时候最好自己带着鱼食，吸引小鱼。虽然我没有买，但是和我一起潜的其他同学买了，蹭了一把鱼食，小鱼在自己周边游动，十分有趣，壮观</p>
<p>潜完水，我们衣服没换去吃了自助餐，然后去划伞，划伞这个项目说不上好玩不好玩，就是快艇拉着你在海上兜一圈，不是很刺激，看起来很好玩，实际也没有特别好玩，如果没买套票的话，不是很建议单买着玩</p>
<p>然后我们去坐了香蕉船，飞羽船，快艇，基本上都是你坐在气垫小船上被快艇拉着在海上兜一圈，速度比较快，挺刺激的。（香蕉船千万别坐第一排，海水很咸，十分辣眼睛，一路海水打在脸上眼睛上，全程睁不开眼睛，飞鱼船可以坐第一排，不会有很多水贱上来，第一排视野还算开阔的）</p>
<p>水上项目都在一个地方，我们玩了全部的水上项目基本也到下午3点钟了，去做了鱼疗足浴，其实是热带小鱼吃你的角质，脚放进去会痒痒的，但是还满舒服的。然后坐环岛电瓶去了牛岛，因为赶着要在6点前离岛，我们就再牛岛上随意逛了下，拍了几张照片。</p>
<p>出岛的时候人比较多，我们排队差不多排了半个小时，晚上回去的时候我问了下，打车去三亚湾要60多，不是很划算，我们去坐了公交车，在等公交的时候我买了芒果，10块钱2小袋，我数了一下，一共有11个手掌心这么大的芒果，而且十分甜，很好吃。</p>
<p>到酒店的时候差不多7点多，我们洗个澡出门觅食，找到一条小吃街，在解放路上，我们住的地方过去需要走15分钟，也算方便，吃了海鲜烧烤和清补凉臭豆腐，买了泡椒鸡爪，一个人50块钱管够了</p>
<p>吃完饭，我们照例去海滩边逛了下，躺一会，晚上的海滩真的太舒服了，让人想融化在沙滩上。等老了真心可以在海滩边买一套房子养老，哈哈哈。晚上的海滩很热闹，很多游客在踩水，拍婚纱照，还有当地的老人歌舞团的聚会活动，到处是欢声笑语。从海滩边回来，我们在路牙边做了马杀鸡，好多老阿姨按摩，20块钱可以按20分钟，不贵，很舒服，按完然后回去睡觉<br><img src="/images/travel/hb.jpeg" alt="三亚路牙子"></p>
<h2 id="D3"><a href="#D3" class="headerlink" title="D3"></a>D3</h2><p>前一天玩水玩的比较累，第二天10点才起来，按照原来的计划，是想去南山文化旅游区，那边的108米的海上观音很出名，但是后来没有去，也幸好没去，30多度在外面逛露天的景点实在不太合适，昨天玩水一起认识的几个小伙伴去了，他们和我说让我别去，他们就逛了10几分钟就走了，因为实在太热了</p>
<p>在我们不知道要去哪里的时候，昨天带我们去西岛的大姐发微信和我说，我们可以去热带雨林，20块钱一个人带我们玩一天，在景点买票就行。而且雨林里有丛林飞跃，是我很想玩的项目，于是我们去了呀渃哒，大姐和我们说这个在海南话里是 1，2，3 的意思。呀渃哒 的门票加丛林飞跃项目是 300块一人，后来我们又加了踏步戏水的项目，每人150。踏步戏水不是很建议玩，感觉比较像是团建，因为大家的身体素质不一样，景区不太敢开放太冒险的路段，所以不是很刺激，没有特别好玩。丛林飞跃就是玉林滑索项目，索道从一个山头到另一个山头，一共有130米，速度不是很快，但是在玉林中飞过，眺看整个玉林的样子真是很舒服，值得一玩。可惜就是不让带手机，索道的终点会有人给你拍照，照片是要钱的，要不要照片就看你个人意愿了，反正我是不太喜欢。</p>
<p>丛林飞跃之后可以在玉林里闲逛一会，景区会给散客一个电子讲解器，讲解到是挺详细的，反正我是没有耐心听下来，全程拍照瞎晃。只记住槟榔树在海南是一个很重要的文化，以前小伙子要爬49颗槟榔树才能取到老婆。</p>
<p>雨林很舒服，有身处大自然的感觉，值得去，反正我是觉得一天雨林一天海滩的玩耍方案挺合适的，到是海滩和雨林的景点是比较多的，除了我玩的几个，你们可以自由选择下</p>
<p>晚上到酒店，我们又重复了前一天的活动，小吃，海滩，马杀鸡</p>
<p><img src="/images/travel/rx.jpeg" alt="三亚路牙子"></p>
<h2 id="D4"><a href="#D4" class="headerlink" title="D4"></a>D4</h2><p>第四天，我们晚上11点的飞机，而且需要从三亚坐动车到海口机场，所以我们12点退了房子，打算继续在海滩边玩到下午5，6点再出发。不过现实总是没有想象的美好，30度的海滩，也热，我们差不多在海滩边逗留了1个小时，去吃了午饭买了些菠萝和泡面就公交到动车站避暑了。</p>
<p>我们没有提前买动车票，总是买的就近一般有座位的，4点从三亚触发，到海口的检完票的时候差不多8点了。逛了免税店，买了2千的面膜和洗面奶，刚好9点多。在机场吃了泡面，玩了会机场农药就开始回城机票检票了</p>
<p>总得来说第四天，没有很紧张的行程，就是瞎逛，买东西，吃东西。三亚的景点都离得比价远，去一个景点公交都差不多要2个小时的样子，来回需要4个小时在路上。如果要赶着玩的话其实可以把行李寄存起来再玩一个景点。但是想着太累了，我们还是把时间留下去逛免税店了。</p>
<p><img src="/images/travel/by.jpeg" alt="三亚路牙子"></p>
<h2 id="装备"><a href="#装备" class="headerlink" title="装备"></a>装备</h2><p>以下我罗列的非必要，但是很有用，哈哈哈</p>
<table>
<thead>
<tr>
<th style="text-align:center">防晒</th>
<th style="text-align:center">记录旅程</th>
<th style="text-align:center">玩水</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">防晒霜</td>
<td style="text-align:center">自拍杆</td>
<td style="text-align:center">手机防水袋</td>
</tr>
<tr>
<td style="text-align:center">防晒外套</td>
<td style="text-align:center">美美的衣服</td>
<td style="text-align:center">拖鞋</td>
</tr>
<tr>
<td style="text-align:center">帽子</td>
<td style="text-align:center">墨镜</td>
<td style="text-align:center">钱</td>
</tr>
</tbody>
</table>
<h2 id="你可能想要知道的东西"><a href="#你可能想要知道的东西" class="headerlink" title="你可能想要知道的东西"></a>你可能想要知道的东西</h2><ol>
<li>我们190订的海景房，是在爱彼迎上定的，这个平台主打民宿所以比携程上便宜，平台注册链接 <a href="https://zh.airbnb.com/c/09425c" target="_blank" rel="external">https://zh.airbnb.com/c/09425c</a></li>
<li>三亚水果很便宜，最便宜的是在槟榔谷，10块钱能买5个菠萝。市区0块钱只能买3个，如果想买没有削皮的菠萝，可以去就近的菜市场</li>
<li>马杀鸡在三亚湾的海岸上，20块1次，可以按20分钟</li>
<li>如果你有其他的想问，可以私我像我，我的微信：646321933</li>
</ol>
<blockquote>
<p>我们的行程是4天3夜，如果有时间的话，建议还是6天5夜，这样能把大部分的景点覆盖到，蜈支洲岛，分界洲，南山文化旅游区，槟榔谷，国家森林公园都可以去走一走。三亚是个很舒服的城市，在三亚，你会感觉整个时间都慢下来，很舒服很放松，你会喜欢的</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2018/03/05/cookie-share/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/05/cookie-share/" itemprop="url">
                  web 浏览器指纹跨域共享
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-05T17:41:49+08:00">
                2018-03-05
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2018/03/05/cookie-share/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/03/05/cookie-share/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>概念：设备id 即设备指纹，用来表示用户设备的唯一性</p>
</blockquote>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近在做用户行为分析项目的开发，需要采集用户的设备信息，需要用设备指纹来唯一表示用户操作设备。web 存储都和浏览器相关，我们无法通过js 来标识一台电脑，只能以浏览器作为设备维度来采集设备信息。即用户电脑中一个浏览器就是一个设备。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>web 变量存储，我们第一时间想到的就是 cookie，sessionStorage，localStorage，但是这3种存储方式都和访问资源的域名相关。我们总不能每次访问一个网站就新建一个设备指纹吧，所以我们需要通过一个方法来跨域共享设备指纹</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>我们想到的方案是，通过嵌套 iframe 加载一个静态页面，在 iframe 上加载的域名上存储设备id，通过跨域共享变量获取设备id，共享变量的原理是采用了iframe 的 contentWindow通讯，通过 postMessage 获取事件状态，调用封装好的回调函数进行数据处理</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>SDK 采集端，调用方初始化的时候调用方法</p>
<pre><code>collect.setIframe = function () {
      var that = this
      var iframe = document.createElement(&apos;iframe&apos;)
      iframe.src = &quot;http://localhost:82/&quot;
      iframe.style = &apos;display:none&apos;
      document.body.appendChild(iframe)
      iframe.onload = function () {
        iframe.contentWindow.postMessage(&apos;loaded&apos;,&apos;*&apos;);
      }

      //监听message事件
      window.addEventListener(&quot;message&quot;, function(){
            that.deviceId = event.data.deviceId

            console.log(&apos;获取设备id&apos;,that.deviceId)

            sessionStorage.setItem(&apos;PageSessionID&apos;,helper.upid())
            helper.send(that.getParames(), that.eventUrl);
            helper.sendDevice(that.getDevice(), that.deviceUrl);
      }, false);
}
</code></pre><p>嵌套在 iframe 静态页面里的脚本</p>
<pre><code>&lt;script&gt;

     var getDeviceId = function() {
             return &apos;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&apos;.replace(/[xy]/g, function (c) {
                     var r = Math.random() * 16 | 0, v = c == &apos;x&apos; ? r : (r &amp; 0x3 | 0x8);
                     return v.toString(16);
             });
     };

     var hasCreated = false
     var _deviceId = &apos;&apos;
     if(document.cookie){
             document.cookie.split(&apos;;&apos;).forEach(function(i){
                     if(i.indexOf(&apos;deviceId&apos;)&gt;-1){
                             hasCreated = true
                             _deviceId = i.split(&apos;=&apos;)[1]
                     }
             })
     }

     if(!_deviceId &amp;&amp; (sessionStorage.getItem(&apos;deviceId&apos;)||localStorage.getItem(&apos;deviceId&apos;))){
             hasCreated = true
             _deviceId = sessionStorage.getItem(&apos;deviceId&apos;)||localStorage.getItem(&apos;deviceId&apos;)
     }


     if(!hasCreated) {
             _deviceId =  getDeviceId()
             document.cookie = &apos;deviceId=&apos; + _deviceId
             sessionStorage.setItem(&apos;deviceId&apos;,_deviceId)
             localStorage.setItem(&apos;deviceId&apos;,_deviceId)
     }

     //回调函数
     function receiveMessageFromIndex ( event ) {
             console.log( &apos;receiveMessageFromIndex&apos;, event )
             parent.postMessage( {deviceId: _deviceId}, &apos;*&apos;);
     }
     //监听message事件
     window.addEventListener(&quot;message&quot;, receiveMessageFromIndex, false);

 &lt;/script&gt;
</code></pre><h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><p><a href="http://cxh.me/2014/11/25/flash-shared-cookie/" target="_blank" rel="external">跨浏览器cookie</a><br><a href="http://www.freebuf.com/articles/web/139984.html" target="_blank" rel="external">跨浏览器指纹识别</a><br><a href="https://paper.seebug.org/229/" target="_blank" rel="external">浏览器指纹追踪</a><br><a href="https://rockjins.js.org/2017/05/05/2017-05-05-iframe-cross-domain-Communication" target="_blank" rel="external">使用postMessage解决iframe跨域通信问题</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage" target="_blank" rel="external">window.postMessage</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2018/02/26/cookie-set/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/26/cookie-set/" itemprop="url">
                  跨域问题导致设置 cookie 不生效的问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-26T16:18:09+08:00">
                2018-02-26
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2018/02/26/cookie-set/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/02/26/cookie-set/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们看下跨域不生效的问题，首先抛出两个问题：</p>
<blockquote>
<ol>
<li>我们如何设置 cookie ？</li>
<li>又如何确定 cookie 设置是否生效了 ？</li>
</ol>
</blockquote>
<p>首先，我们实现一个简单的接口,新建一个 test.js 文件，将如下代码复制进去，通过 <code>node test.js</code> 启动服务，在本地就可以通过 <code>http://localhost:3000/rest/collect/event/h5/v1/</code> 来访问了我们创建的接口了（node 环境安装的教程网上有很多详细的教程，本文不再赘述）</p>
<pre>
var express = require('express');
var app = express();
var URL = require('url')
var path = require('path');


app.post('/rest/collect/event/h5/v1/', function(req, res) {
        res.cookie('token','11111112222222224444444444')
        res.cookie('httpOnly-token','11111112222222224444444444',{ httpOnly: true })

        function User() {
                this.name;
                this.city;
                this.age;
        }

        var user = new User();

        if(params.id == '1') {

                user.name = "ligh";
                user.age = "1";
                user.city = "北京市";

        }else{
                user.name = "SPTING";
                user.age = "1";
                user.city = "杭州市";
        }

        var response = {status:1,data:user};
        res.send(JSON.stringify(response));
});

app.listen(3000);
console.log('Listening on port 3000...');
</pre>

<p>访问效果如下</p>
<p><img src="/images/cookie/3.jpeg" alt="接口访问效果如下"></p>
<p>在前端代码中访问我们的接口<br><img src="/images/cookie/4.jpeg" alt="cookie设置"><br><img src="/images/cookie/5.jpeg" alt="cookie查看"><br>在浏览器中我们可以看到请求的 Resopnse Headers 里，有两个 <code>set-cookie</code>头部，区别在于一个带有 <code>HttpOnly</code>的标识，我们打开浏览器的调试窗口<code>Application</code>我们可以看到，两个数值都被设置到浏览器里了，<code>httpOnly</code>的值在浏览器调试窗口的<code>http</code>一栏，打了个小勾，说明这个变量是只能通过 http 请求来获取到这个cookie ，前端无法通过 js 的 <code>document.cookie</code>来获取到<br><img src="/images/cookie/7.jpeg" alt="就是无法操作的cookie"><br>讲到这块内容，我们顺便讲下 cookie 设置的其他参数的作用</p>
<p><img src="/images/cookie/6.jpeg" alt="其他参数"><br>cookie 和域名相关的哟，<code>Domain</code> 变量表示 cookie 生效的域名，<code>expries</code>和<code>max-age</code>表示 cookie 的有效时间</p>
<h4 id="问题描述及解决"><a href="#问题描述及解决" class="headerlink" title="问题描述及解决"></a>问题描述及解决</h4><p>在开发阶段我自己用node 简单的写了一个接口，便于联调前端传参问题，希望通过 http 的set-cookie 存储变量， 但是却始终没有把 cookie 成功设置到浏览器里，经过排查发现是跨域导致的 cookie 设置不生效<br><img src="/images/cookie/1.jpeg" alt="cookie设置"><br><img src="/images/cookie/2.jpeg" alt="cookie查看"></p>
<p>不生效的原因是我本地项目启动在 <code>http://localhost:70</code>,但是调用的接口在 <code>http://localhost:3000</code>上，端口不一样，存在跨域的问题，所以虽然在 Response Header 里看到了<code>set-cookie</code>的操作，但是在浏览器的 <code>application</code>里看到，并没有被设置进来，解决办法，通过nginx 代理（最长用的跨域解决办法）</p>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>跨域的问题在开发过程中比较常见，我们经常会碰到，简单来说<code>只要请求资源的协议，域名，端口不一致，都会导致跨域</code>，网上的解决方法也比较多，比较成熟，本文不做扩展，附带几个链接供大家参考</p>
<p><a href="http://harttle.land/2016/12/30/cors-preflight.html" target="_blank" rel="external">跨域中的预检测请求</a><br><a href="https://www.jianshu.com/p/13d53acc124f" target="_blank" rel="external">CORS 跨域中的 Cookie</a><br><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="external">跨域资源共享 CORS 详解</a><br><a href="http://harttle.land/2015/10/10/cross-origin.html" target="_blank" rel="external">Web开发中跨域的几种解决方案</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2017/05/18/nginx-basic/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/18/nginx-basic/" itemprop="url">
                  你需要知道的 nginx 基础配置
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-18T14:23:31+08:00">
                2017-05-18
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2017/05/18/nginx-basic/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/05/18/nginx-basic/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="初探nginx"><a href="#初探nginx" class="headerlink" title="初探nginx"></a>初探nginx</h2><blockquote>
<p>今天给大家讲下nginx的基础配置,很多小伙伴在开发的过程中会使用到 nginx ,但是确对 nginx 的配置其实并不了解,今天我给大家讲下基础的配置项.nginx 的功能很多,但是说到 nginx 大家最先想到的是反向代理和负载均衡.</p>
</blockquote>
<p>“负载均衡”在开发环境体现的不太明显,主要是为了解决生产环境的客户端请求很多的时候,动态的去分散给各个服务器,缓解服务器压力,充 分利用资源.而说到 “反向代理”,你的第一反应应该是”正向代理”,简称”代理”,你可以把代理想象成客户端和服务端的中介,代理的种类很多,比较常见的是,客户端对服务端进行请求的时候,代理会对请求的内容进行下载缓存,从而提高客户端的请求速度,代理还有多重代理,加密处理等功能,”反向代理”的作用和正项代理的功能相辅相成,原理也类似,反向代理将字符串和相应的服务器和端口匹配上,从而获取用户想要获取的内容,那么这两者的区分是什么呢,”正向代理”作用于客户端,”反向代理”作用于服务器.</p>
<h2 id="生动的-nginx-反向代理解释"><a href="#生动的-nginx-反向代理解释" class="headerlink" title="生动的 nginx 反向代理解释"></a>生动的 nginx 反向代理解释</h2><p>为了让大家能够更加深刻的理解代理和反向代理的模式,我们引用下知乎上<a href="https://www.zhihu.com/question/24723688/answer/160252724" target="_blank" rel="external">车小胖</a>的回答</p>
<blockquote>
<p>有了第三方订餐外卖平台（代理），老王懒得动身前往饭店，老王打个电话或用APP，先选好某个饭店，再点好菜，外卖小哥会送上门来。由于某个品牌的饭店口碑特别好，食客络绎不绝涌入，第三方订餐电话也不绝于耳，但是限于饭店接待能力有限，无法提供及时服务，很多食客等得不耐烦了，纷纷铩羽而归，饭店老总看着煮熟的鸭子飞走了，心疼不已。痛定思痛，老总又成立了几个连锁饭店，形成一个集群，对外提供统一标准的菜品服务，电话订餐电话400-xxx-7777，当食客涌入饭店总台，总台将食客用大巴运到各个连锁店，这样食客既不需要排队，各连锁店都能高速运转起来，一举两得，老总乐开了花，并为此种运作模式起名为“反向代理”（Reverse Proxy)。</p>
</blockquote>
<h2 id="nginx-基础配置"><a href="#nginx-基础配置" class="headerlink" title="nginx 基础配置"></a>nginx 基础配置</h2><p>好了,了解了 nginx 的一些概念之后,我们要开始切入今天的主题,”ngix 的基础配置”,安装好 nginx 配置之后,你对 nginx 的配置都写在 nginx.conf 的文件里,从 nginx 的配置指令作用域来讲,我们分为 5 个作用域块,分别是:</p>
<ul>
<li>全局作用域块</li>
<li>event 作用域块</li>
<li>http 指令作用域块</li>
<li>server 指令作用域块</li>
<li>location 指令作用域块</li>
</ul>
<p><img src="/images/nginx/nd.jpeg" alt="nginx基础配置"></p>
<p>在 “全局作用域块” 作用域块中配置通用的nginx 配置,比如 nginx 的用户组信息,nginx 的并发进程数,日志存放位置等,nginx 的用户组信息配置,用来控制启动 nginx 的权限,服务并发一般情况下是越多越好,但是当超过硬件的承受范围时会适得其反,所以一般我们会配置为 auto,这样 nginx 会去检查硬件的信息,启用适当的进程数量.</p>
<p>日志存放位置你也可以配置在 http 作用域块,”http 作用域块”作用域通常是配置请求相关的内容,比如数据的传输,对同一个接口的请求次数上线,配置请求的潮湿时间,还有是否要对请求进行 gzip 压缩等.在之前讲 web性能优化的时候,我记得和大家讲过 gzip 压缩是提高 web 性能优化的一种手段,gzip 能对 http 请求的请求头和请求体进行压缩,从而达到优化.但是不是所有的请求都要去压缩,有些压缩之后的请求体积可能会更大,从而达不到压缩的效果.那怎么办呢,在 nginx 的配置中,你可以进行配置,设置当请求大于一定值的时候,才触发 gzip 压缩 gzip 的内容这里就深入讲解了,想要了解的同学可以去谷歌下,或则在下次 nginx 的高级配置的分享的时候我们再来细讲.</p>
<p>在 event 模块我们通常会配置进程的连接数量,就是每一个worker进程能并发处理（发起）的最大连接数.在 “server 指令作用域块” 我们可以进行独立项目的代理配置,</p>
<p>一个 http 指令中可以包含多个 server ,每一个 server 你可以看做是一个虚拟机,部署过网站的同学应该知道,若果你没有做代理,你的服务器只能部署一个项目的内容,默认是80端口,使用代理,能将客户端的请求根据端口作为区分,发散到不同的项目中.nginx 这一点,能让我们更好的利用服务器资源</p>
<p>在server 指令中,我们同样可以配置多个 location 指令,location 指令能将我们的字符串请求解析到对应的IP和端口,从而去获取正确的资源,location 也可以进行特殊配置,定制 网站的 404 ,500 等页面.</p>
<h2 id="nginx-的项目配置示例"><a href="#nginx-的项目配置示例" class="headerlink" title="nginx 的项目配置示例"></a>nginx 的项目配置示例</h2><p><img src="/images/nginx/l1.jpeg" alt="nginx作用域"><br><img src="/images/nginx/l2.jpeg" alt="nginx作用域"><br>我们简单的看下,我目前使用到的两个项目的 nginx 配置,在fengdai_pc 项目中我们通过 listen 来配置项目监听端口,通过 root 来配置前端项目文件的地址,我们还通过 location 来配置了几个模块代理,account 和 funds ,定制了 404 页面,在 另一个 nginx 配置项目中我们做了https 配置,配置了域名 <code>baibatianpc.com</code>,并且指定了证书的位置,这样配置后,我们能通过 访问 <a href="https://baibatianpc.com/" target="_blank" rel="external">https://baibatianpc.com/</a> 来查看我们的项目.这里对于如何搭建 https 环境就不细讲了,不同的开发系统证书的获取和配置方式也不太一样,想要深入了解的同学继续谷歌.</p>
<h2 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h2><p>好了,我们今天讲了nginx 的基础配置,我们现在来复习一下,我们今天讲的知识点有哪些</p>
<ol>
<li>nginx 常用的功能的概念,负载均衡,反向代理</li>
<li>nginx 指令配置的5个作用域空间</li>
<li>nginx 的每个配置作用域的基础配置项目</li>
<li>简单的两个项目配置示例</li>
</ol>
<p>你都掌握了吗,联系我进行交流,WeChat:646321933</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2017/01/09/webpack/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/09/webpack/" itemprop="url">
                  你需要知道的 webpack 配置
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-09T21:27:52+08:00">
                2017-01-09
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2017/01/09/webpack/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/01/09/webpack/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>好久没有写文章，最近在做项目自动化构建工具的迁移，花了一点时间去研究 <code>webpack</code> ，<code>webpack</code> 的入门其实简单，但是现有的资料比较零碎，按照我的学习路径整理了下，希望对大家能有所帮助。</p>
<blockquote>
<p>接下来我将从3个部分来给大家介绍<code>webpack</code>,分别是 webpack 的基础配置，哪些常用的加载器，我在项目自动化构建工具改造的过程中雨大了那些问题</p>
</blockquote>
<h3 id="webpack-基础配置"><a href="#webpack-基础配置" class="headerlink" title="webpack 基础配置"></a>webpack 基础配置</h3><p>首先我们需要理解四个重要的概念</p>
<ol>
<li>入口（你需要打包的文件声明），你的项目需要什么依赖没在这里进行声明，require 你需要的依赖，webpack 会直接和间接的找到依赖文件进行打包，可传字符串，数组，对象<pre>
     // 配置了3个入口文件
     entry: [
             './config/dependencies.js',
             './config/index.js',
             './config/cssImport.js'
     ]
</pre></li>
<li>出口（你打包资源后到哪个目录哪个文件），声明依赖打包后的文件输出的目录及命名方式，可传字符串，数组，对象<pre>
     //声明了依赖压缩打包之后会被添加到 build 目录的 bundle.js 文件里
     output: {
             path: path.join(__dirname, '../build'),
             filename: 'bundle.js',
     },
</pre></li>
<li>loader（模块加载器）能将各种资源的依赖模块打包成webpack 能够理解的 js 模块，从而进行你需要的操作，如 css 预编译，图片压缩，路径转换等<pre>
     loaders: [
                 {
                     test: /\.js?$/,
                     exclude: /(node_modules|bower_components)/,
                     loader: 'babel-loader', // 'babel-loader' is also a legal name to reference
                     query: {
                             presets: ['es2015']
                     }
             }]
</pre></li>
<li><p>插件（插件用于扩展 loader 的能力）你可以用插件进行定义环境变量对代码进行打包压缩。</p>
<pre>
     //声明
     const ImageminPlugin = require("imagemin-webpack-plugin").default
     const CopyWebpackPlugin = require('copy-webpack-plugin')

     //从imgSrc 目录压缩图片，压缩完拷贝到 build/img 目录下
     plugins: [
             new CopyWebpackPlugin([
                     { from: 'imgSrc' ,to:'img'}
             ]),
             new ImageminPlugin(
                     { test: /\.(jpe?g|png|gif|svg)$/i }
                     )
     ]
</pre>

</li>
</ol>
<p><a href="https://doc.webpack-china.org/concepts/" target="_blank" rel="external">概念方面如果有不清晰的可以看下 webpack 的中文文档</a></p>
<h3 id="webpack-的常用加载器"><a href="#webpack-的常用加载器" class="headerlink" title="webpack 的常用加载器"></a>webpack 的常用加载器</h3><p>loader 用于常用的源代码进行装换，常用的有js编译，css 预编译，图片压缩等，这些都是项目中比较常见的，大家平时不需要记忆，只要能大概知道有这么一个东西，需要用到的时候去查阅就行，<a href="https://doc.webpack-china.org/loaders/" target="_blank" rel="external">loader 官方收录文档</a></p>
<h3 id="在项目迁移中遇到的问题"><a href="#在项目迁移中遇到的问题" class="headerlink" title="在项目迁移中遇到的问题"></a>在项目迁移中遇到的问题</h3><p>由于各种历史原因，我们的项目目录结构凌乱，项目依赖多，结构复杂，使用着 <code>angular + gulp</code> 进行开发，自动化构建工具还处于刀耕火种的年代，发版本的时候通过前端给包，不安全，不规范。新的一年我们尝试去改变这种现状，洗完通过运维直接拉去前端代码，这样能充分的保证前端代码的一致性。</p>
<h4 id="目前的项目结构的控诉"><a href="#目前的项目结构的控诉" class="headerlink" title="目前的项目结构的控诉"></a>目前的项目结构的控诉</h4><ol>
<li>项目所有问文件处于一个平级状态</li>
<li>有3个依赖包文件夹分别是 framwork，lib，node_modules(各种历史遗留问题)</li>
<li>源图片imgSrc和压缩后的img在同一个目录</li>
<li>人工手动打包的时候要很小心的删除不必要的文件</li>
</ol>
<h4 id="现有的改进方案"><a href="#现有的改进方案" class="headerlink" title="现有的改进方案"></a>现有的改进方案</h4><ol>
<li>创建 build 文件夹，nginx 代理 到 build 目录</li>
<li>config 中配置 webpack 构建打包任务，以及各种依赖的入口文件</li>
<li>ib &amp;&amp; framwork 移到 build 文件</li>
<li>less 中对图片的引用路径需要变动，因为img 的路径变动了，tpls 也变动了，所以在视图中直接引用的不需要变化</li>
<li>gulpfile 中的 js 压缩，less 编译，图片压缩内容迁移到 webpack 任务中</li>
<li>通过 npm run dev 进行编译构建</li>
<li>图片压缩</li>
<li>依赖及模块文件变化时实时构建项目</li>
<li>弃用 gulpfile 编译构建</li>
</ol>
<p>创建 <code>build</code> 文件夹，<code>nginx</code> 代理 到 <code>build</code></p>
<blockquote>
<p>目录，配置生产环境依赖目录，运维可以直接将代理指向该目录，不需要人工手动剔除多余的目录</p>
</blockquote>
<p>config 中配置 webpack 构建打包任务，以及各种依赖的入口文件</p>
<blockquote>
<p>建立config 目录，存放 webpack 配置文件目录，及各种依赖声明目录，我们一共声明了3个依赖入口文件，分别是npm 管理的生产依赖文件，css 文件，项目逻辑js文件。css 和 生产依赖的内容比较烧，我们手动 require 一下，但是我们项目是已经经过近两年的迭代开发，逻辑代码 js 文件繁多，目录结构负责，所以我们需要写一个简单的 node 脚本，递归查询项目目录结构，动态 require 写入到我们的js入口文件中，node 脚本 如下</p>
</blockquote>
<pre>
        var files = fs.readdirSync('js')
        var jsPath = 'js'

        fs.unlink('config/index.js')

        var getFileName = function (files,dirPath) {

        files.forEach(function (filename) {
                var fullname = path.join(dirPath,filename)
                var stats = fs.statSync(fullname)

                if (stats.isDirectory()){
                        var subFiles = fs.readdirSync(fullname)
                        getFileName(subFiles,fullname)
                } else {
                        let file = './../'+dirPath+'/'+filename
                        fs.writeFile('./config/index.js', 'require (\"'+file +'\")\n', {
                                flag: 'a'
                        }, function(err){
                                 if(err) throw err
                        })
                }
        })
}

getFileName(files,jsPath)
</pre>

<p>配置我们的入口和输入</p>
<pre>
        entry: [
                './config/dependencies.js',
                './config/index.js',
                './config/cssImport.js'
        ],
        output: {
                path: path.join(__dirname, '../build'),
                filename: '[name].js',
        },
</pre>

<p>然后是对我们的gulp task 进行迁移，我们需要配置 js 语法编译，css 预处理，图片压缩的功能。js 编译只需要使用 <code>babel-loader</code> ,通过 <code>npm install babel-loader</code> 安装加载器，指定匹配的文件及需要忽略的文件，指定转化语法，设定转码规则，就配置成功了</p>
<pre>
        {
            test: /\.js?$/,
            exclude: /(node_modules|bower_components)/,
            loader: 'babel-loader', // 'babel-loader' is also a legal name to reference
            query: {
                presets: ['es2015']
            }
        }
</pre>

<p>css 预编译，我们使用了 less 做为 css 开发工具，编译的时候需要用到的 loader 比较多，通过<code>less-loader</code>,<code>css-loader</code>,<code>style-loader</code>的链式调用，将样式作用于DOM</p>
<pre>
        rules: [{
            test: /\.less$/,
            use: [{
                loader: "style-loader" // creates style nodes from JS strings
            }, {
                loader: "css-loader" // translates CSS into CommonJS
            }, {
                loader: "less-loader" // compiles Less to CSS
            }]
        }]
</pre>

<p>或则</p>
<pre>
loaders: [
            {
                test: /\.less$/,
                use: ['style-loader',
                    {
                        loader: 'css-loader',
                        options: {
                            //支持@important引入css
                            importLoaders: 1
                        }
                    },
                    {
                        loader: 'postcss-loader',
                        options: {
                            plugins: function() {
                                return [
                                //一定要写在require("autoprefixer")前面，否则require("autoprefixer")无效
                                require('postcss-import')(),
                                require("autoprefixer")({
                                "browsers": ["Android >= 4.1", "iOS >= 7.0", "ie >= 8"]})]
                            }
                        }
                    },
                    'less-loader']
                }]
</pre>

<p>图片压缩我们选择了两个插件分别是<code>imagemin-webpack-plugin</code>和<code>copy-webpack-plugin</code>，imagemin 实现图片压缩，copy 实现图片资源拷贝，具体配置如下</p>
<pre>
//插件引用
const ImageminPlugin = require("imagemin-webpack-plugin").default
const CopyWebpackPlugin = require('copy-webpack-plugin')

//插件使用
plugins: [
                new CopyWebpackPlugin([
                        { from: 'imgSrc' ,to:'img'}
                ]),
                new ImageminPlugin(
                        { test: /\.(jpe?g|png|gif|svg)$/i }
                        )
        ]
</pre>

<p>了解完细节我们看下一个整体的配置</p>
<pre>
/**
 * Created by bailinlin on 2018/1/4.
 */
const fs = require ("fs")
const path = require ("path")

const ImageminPlugin = require("imagemin-webpack-plugin").default
const CopyWebpackPlugin = require('copy-webpack-plugin')


var files = fs.readdirSync('js')
var jsPath = 'js'

fs.unlink('config/index.js')

var getFileName = function (files,dirPath) {

        files.forEach(function (filename) {
                var fullname = path.join(dirPath,filename)
                var stats = fs.statSync(fullname)

                if (stats.isDirectory()){
                        var subFiles = fs.readdirSync(fullname)
                        getFileName(subFiles,fullname)
                } else {
                        let file = './../'+dirPath+'/'+filename
                        fs.writeFile('./config/index.js', 'require (\"'+file +'\")\n', {
                                flag: 'a'
                        }, function(err){
                                 if(err) throw err
                        })
                }
        })
}

getFileName(files,jsPath)

module.exports = {
        entry: [
                './config/dependencies.js',
                './config/index.js',
                './config/cssImport.js'
        ],
        output: {
                path: path.join(__dirname, '../build'),
                filename: 'bundle.js',
        },
        module: {
                loaders: [
                    {
                        test: /\.js?$/,
                    exclude: /(node_modules|bower_components)/,
            loader: 'babel-loader', // 'babel-loader' is also a legal name to reference
            query: {
                presets: ['es2015']
            }
                },{
                test: /\.less$/,
                use: ['style-loader',
                {
                loader: 'css-loader',
                options: {
                 //支持@important引入css
                    importLoaders: 1
                }
                },{
                loader: 'postcss-loader',
                options: {
                plugins: function() {
                    return [
                    //一定要写在require("autoprefixer")前面，否则require("autoprefixer")无效
                    require('postcss-import')(),
                    require("autoprefixer")({
                    "browsers": ["Android >= 4.1", "iOS >= 7.0", "ie >= 8"]})]
                     }
                     }
                    },
                    'less-loader']
                },{
                    test: /\.(jpe?g|png|gif|svg)$/i,
                    use: [
                    {
                        loader: 'url-loader',
                        options: {
                            limit: 8192
                        }
                    }]
                }]
        },
        plugins: [
                new CopyWebpackPlugin([
                        { from: 'imgSrc' ,to:'img'}
                ]),
                new ImageminPlugin(
                        { test: /\.(jpe?g|png|gif|svg)$/i }
                        )
        ]
}

</pre>

<h4 id="实现热编译"><a href="#实现热编译" class="headerlink" title="实现热编译"></a>实现热编译</h4><p>实现完配置之后我们要考虑另一个问题了，我们希望修改完之后能实时编译预览，不用每次都手动的跑一边命令，我们可以选择 webpack 提供的 node 服务，<code>webpack-dev-server</code>,在配置文件里新增一个 webpack.server.js 的文件，在文件中 require 需要的依赖，<code>webpack-dev-server</code> 可以指定服务启动的目录，及服务监听的端口，我们的配置如下</p>
<pre>
/**
 * Created by bailinlin on 2018/1/4.
 */
var path = require("path")
var webpack = require("webpack")
var webpackDevServer = require("webpack-dev-server")
var webpackCfg = require("./webpack.config.js")

var compiler = webpack(webpackCfg)

//init server
var app = new webpackDevServer(compiler, {
        contentBase        : path.join(__dirname, '../build'),
        noInfo             : true,
        hot                : true,
        historyApiFallback : true,
        stats              : { colors : true },
        //注意此处publicPath必填
        publicPath: webpackCfg.output.publicPath
})

app.listen(9090, "localhost", function (err) {
        if (err) {
                console.log(err)
        }
})

console.log("listen at http://localhost:9090")
</pre>

<h4 id="启动我们的服务"><a href="#启动我们的服务" class="headerlink" title="启动我们的服务"></a>启动我们的服务</h4><p>配置完成之后，我们需要启动我们的服务，你可以再你的控制台中直接输入 <code>node config/webpack.server.js</code> 来启动服务，<code>webpack --config config/webpack.config.js</code> 来进行编译构建，也可以在 package.json 文件中配置 script 如</p>
<p><pre><br>“scripts”: {<br>    “start”:”node config/webpack.server.js”,<br>    “build”: “webpack –config config/webpack.config.js”<br>  },<br></pre><br>这样你就可以通过 <code>npm start</code> 和 <code>npm run build</code>来控制你的服务启动和项目构建</p>
<p>参考文章列表</p>
<blockquote>
<p>如果你还想更深入理解，你可以继续阅读这些扩展文章<br><a href="https://doc.webpack-china.org/concepts/" target="_blank" rel="external">理解概念</a><br><a href="https://doc.webpack-china.org/configuration/#-" target="_blank" rel="external">配置讲解</a><br><a href="https://doc.webpack-china.org/loaders/" target="_blank" rel="external">常会用到的loaders</a><br><a href="http://blog.csdn.net/lancewu0907/article/details/76513231" target="_blank" rel="external">webpack打包原理</a><br><a href="https://www.zhihu.com/question/46661735" target="_blank" rel="external">webpack全局变量</a><br><a href="https://github.com/webpack-contrib/css-loader/issues/74" target="_blank" rel="external">less 图片解析问题</a><br><a href="https://juejin.im/entry/5767a975df0eea0062ffe193" target="_blank" rel="external">其他优秀的配置文章</a><br><a href="https://github.com/kingvid-chan/webpack2-lessons/tree/master/lesson2" target="_blank" rel="external">《使用webpack-dev-server实现热更新》</a><br><a href="https://github.com/Klathmon/imagemin-webpack-plugin" target="_blank" rel="external">imagemin-webpack-plugin</a><br><a href="https://github.com/webpack-contrib/copy-webpack-plugin" target="_blank" rel="external">copy-webpack-plugin</a></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2016/11/01/learn-wxapp/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/01/learn-wxapp/" itemprop="url">
                  你需要知道的小程序开发基础
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-01T20:38:15+08:00">
                2016-11-01
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/11/01/learn-wxapp/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/01/learn-wxapp/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>微信小程序出来已有段时间，虽还在内测阶段。利用空闲时间，我把蜂贷微信项目部分迁移到小程序上。</p>
<p>##1.目录结构</p>
<p>   小程序的主体由三个文件组成，这三个文件要放在项目的根目录下，分别是</p>
<ol>
<li>app.js 配置小程序的逻辑</li>
<li>app.json 公共设置</li>
<li><p>app.wxss 公共样式</p>
<p>小程序可以自定义 page，但是 page 需要在 app.json 中做出声明，不然IDE会报错，找不到页面。小程序的页面由四个文件组成，分别是</p>
</li>
<li><p>.js文件 页面逻辑</p>
</li>
<li>.wxml 视图层文件，页面结构</li>
<li>.wxss 样式文件，页面样式表</li>
<li>.json 文件，配置文件，页面配置</li>
</ol>
<h2 id="2-小程序配置"><a href="#2-小程序配置" class="headerlink" title="2.小程序配置"></a>2.小程序配置</h2><p>app.json 决定页面文件的路径、窗口表现、设置网络超时时间、设置多少 tab 。</p>
<p>在 pages 对象里定义页面路径，pages 接受由字符串组成的数组，pages数组的第一个元素就是小程序的首页。</p>
<ol>
<li>window 用于设置小程序的状态栏、导航条、标题、窗口背景色。</li>
<li>tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。</li>
<li>networkTimeout 用来设置各种网络请求超时时间</li>
<li>debug 是布尔类型，用来配置是否在开发者工具中开启 debug 模式</li>
</ol>
<h2 id="3-小程序视图"><a href="#3-小程序视图" class="headerlink" title="3.小程序视图"></a>3.小程序视图</h2><p>在小程序中，你不能继续用 html 中的标签来构造你的页面，MANA 框架有特定的容器组件，view，scroll-view  以及 swiper。</p>
<ol>
<li>view 是视图容器，类似于 html 中的 div ，但是不同的是，用 view 包裹的内容，在超出设备窗口的时候，它实现的效果如 css 样式设置的 overflow：hidden</li>
<li>如果你需要实现类似通讯录或则聊天列表的滚动效果，你需要使用 scroll-view 滚动容器组件，它实现的效果如 css 样式设置的 overflow:scroll 。</li>
<li>swiper 是滑块视图组件，如果你要实现类似轮播图的效果的话，他是你的不二之选，你能通过属性配置来控制是否显示圆点，是否自动播放，切换时间，以及切换间隔时间等。<br>小程序的MANA也实现了数据的绑定，写法类似于 Angular 和 Vue，通过双括号的形式 如： 即可，值得注意的是，如果你写在容器（为了便于描述和理解，下文会以标签来描述）于之间的话，你直接把变量写在双括号里即可，如：<view></view> ，但是如果你给标签的属性绑定变量，你需要将双括号放在双引号内，如：<view wx:if="””&gt;</view">,类似于Angular 和 Vue，你也能在双括号内进行简单的运算，如：<view hidden="”{flag?true:false}”"></view>。</view></li>
</ol>
<p>细心的同学可能发现了在介绍数据绑定的时候我们用了wx:if  的属性，这是 MANA 提供的条件渲染，通过判断 wx:if 传布尔值（非布尔类型进行隐士转化）来控制是否渲染标签中的内容。在 MANA 中还有一个属性能控制内容的显隐，不同的是，wx:if 只有在为 true 的时候才回去渲染标签中的内容，而 hidden 始终会渲染内容，只是根据条件来控制内容的显示与否。</p>
<p>此外MANA 也为我们提供了较为实用的列表渲染，wx:for 接受一个数组,在页面中能根据数组中的值来渲染页面列表</p>
<p>除了使用列表渲染来复用一块视图外，你还可以通过模版来进行复用，你能在 template 中定义一块代码片段，然后在不同的页面中引用，如：</p>
<pre><code>&lt;template name=&quot;odd&quot;&gt;
  &lt;view&gt; odd &lt;/view&gt;
&lt;/template&gt;
&lt;template name=&quot;even&quot;&gt;
  &lt;view&gt; even &lt;/view&gt;
&lt;/template&gt;

&lt;block wx:for=&quot;{{[1, 2, 3, 4, 5]}}&quot;&gt;
    &lt;template is=&quot;{{item % 2 == 0 ? 'even' : 'odd'}}&quot;/&gt;
&lt;/block&gt;
</code></pre><p>除了 template 外，MANA 还提供了另外两种方式来进行应用和复用，import 和 include ，import 有作用域的概念，他只会引用目标文件中定义的模版。include可以将目标文件除了<template>的整个代码引入，相当于是拷贝到include位置上。</template></p>
<p>除MANA 同样也定义了常用的事件分类，如</p>
<ol>
<li>touchstart 手指触摸动作开始</li>
<li>touchmove 手指触摸后移动</li>
<li>touchcancel 手指触摸动作被打断，如来电提醒，弹窗</li>
<li>touchend 手指触摸动作结束</li>
<li>tap 手指触摸后马上离开</li>
<li>longtap 手指触摸后，超过350ms再离开<h2 id="4-组件样式"><a href="#4-组件样式" class="headerlink" title="4.组件样式"></a>4.组件样式</h2></li>
</ol>
<p>定义在 app.wxss 中的样式为全局样式，作用于每一个页面。在 page 的 wxss 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 app.wxss 中相同的选择器。如果你写过 css ，那你就能轻松驾驭 wxss,wxss 在选择器上做了限制，目前支持的选择器有：</p>
<ol>
<li>.class 如：.intro    选择所有拥有 class=”intro” 的组件</li>
<li><code>#id</code> 如：<code>#firstname</code>    选择拥有 id=”firstname” 的组件</li>
<li>element  如：    view    选择所有 view 组件</li>
<li>element, 如： element    view checkbox    选择所有文档的 view 组件和所有的 checkbox 组件</li>
<li>::after     如：view::after    在 view 组件后边插入内容</li>
<li>::before     如：view::before    在 view 组件前边插入内容</li>
</ol>
<p>开发过移动端的前端er 都知道，苹果手机有物理像素和逻辑像素的区别，比如设备的像素是350px，设计稿的像素是750px；一般在开发过程中，我们会使用自动化构建工具去做像素转化，或则是使用预处理器定义像素转化函数进行处理，在小程序的开发中，大可不必这么麻烦，小程序提供了一个 rpx 的单位，你可以直接写上你在设计稿中测量的数值即可，小程序开发工具在编译过程中会自动帮你做转换。</p>
<p>在下次小程序分享《小程序开发踩坑（二）》的时候，会教大家如何与后端进行数据交互，欢迎感兴趣的小伙伴订阅博客。</p>
<p><img src="/img/bVEXHS" alt="蜂贷微信端"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2016/06/30/init-blog/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/30/init-blog/" itemprop="url">
                  使用 hexo 搭建你的 github.io 博客网站
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-30T20:37:03+08:00">
                2016-06-30
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/06/30/init-blog/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/30/init-blog/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>作为前端er,我们每天都要保持学习,前阵子有一片文章很火<a href="https://zhuanlan.zhihu.com/p/22782487" target="_blank" rel="external">在 2016 年学 JavaScript 是一种什么样的体验？</a>,前端技术日新月异,我们不仅要保持学习,还需要掌握一个好的,适合自己的学习方式.在这个信息这个发达的时代,你不缺输入的机会,却少的反而是我们的输出机会.大多数的前端没有去记录自己的所学,所用,即使有记录,也都是在一些第三方的博客网站, 这就会有这么一个情况.持续性不够,发布过的文章没有去回顾,这个博客网站发一篇,那个博客网站发一篇,而且很没归属感.</p>
<p>然而,github 作为我们的程序员圈子的同性交友社区,面试必看的内容,我们为什么不在 github 上搭一个自己的博客呢,在 github 上你可以直接建立一个仓库,然后在 issue 里写博客,我个人比较建议的是,搭一个属于你自己的 github pages,在 github pages 上记录你的博客. 首先是外观上比较好看,而且你可以依照你的心情改变你的博客主题,其次,你可以通过你的 github 用户名点 github.io 的方式来直接访问你的博客网站,感觉有了一个属于自己的网站一样,不要钱,还在一定程度上满足了你的虚荣心.</p>
<h2 id="快速搭建"><a href="#快速搭建" class="headerlink" title="快速搭建"></a>快速搭建</h2><p>如果你是有一定开发经验的前端,你的电脑一定已经安装了 git 和 node ,那你在搭建博客之前你只要先全局安装 hexo 的命令行工具,命令如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g hexo-cli</div></pre></td></tr></table></figure>
<p>然后你在你的电脑里新建一个空的文件夹命名就按照 userName.github.io 的方式来命名 例如我的项目我命名为 bailinlin.github.io, 其次,你需要进入你新建的这个文件夹,执行命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo init</div></pre></td></tr></table></figure>
<p>等待一定时间,你会看到你新建的文件夹里出现了好多初始化文件,现在这个时候一个基本的简单博客搭建成功了,你运行以下命令</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo s -p 3000</div></pre></td></tr></table></figure>
<p> 就能在 localhost:3000 中看到一个博客网站了,现在你要做的就是为你的博客网站做一些个性化的定制,打开_config.yml 文件.修改文件内的参数,</p>
<pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">title: 白霸天的博客              //博客网站的title</div><div class="line">subtitle:                      //子标题</div><div class="line">description: 前端,白霸天,博客   //网站描述</div><div class="line">author: bailinlin             //网站作者</div><div class="line">language: zh-Hans            //网站语言,用于本地化</div><div class="line">...                          // 等其它配置</div></pre></td></tr></table></figure>
</code></pre><h2 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h2><h3 id="关联远程仓库"><a href="#关联远程仓库" class="headerlink" title="关联远程仓库"></a>关联远程仓库</h3><p>博客搭建好之后,你需要做的是把博客发布到 github 上,首先你需要在 github 上新建一个仓库,命名和你新建的文件夹一样, username.githhub.io 值得注意的是,这里的 username 必须和你的github 用户名一样,大小写也要一样.然后你需要进入你的本地文件夹,关联你的远程仓库.</p>
<p>首先<br>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git init</div></pre></td></tr></table></figure></p>
<p>然后<br>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git remote add origin git@github.com:username/username.github.io.git</div></pre></td></tr></table></figure></p>
<p>然后我们只要把代码推到远程仓库就行了,不过这里我们要有个约定,我们在 master 上发布博客,在 dev 分支上修改我们的博客内容和项目配置,也就是说我们发布博客后,master 分支上就是我们的博客的静态文件,dev 分支上的代码就是我们世纪维护的博客内容,如图<br>master 分支:<br><img src="/images/blog/master.png" alt="master分支"><br>dev 分支:<br><img src="/images/blog/master.png" alt="master分支"></p>
<h3 id="安装-hexo-的一键部署命令工具"><a href="#安装-hexo-的一键部署命令工具" class="headerlink" title="安装 hexo 的一键部署命令工具"></a>安装 hexo 的一键部署命令工具</h3><p> 通过npm 安装<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></p>
<p> 修改部署配置,在 _config.yml 中添加如下配置</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  <span class="built_in">type</span>: git</div><div class="line">  branch: master</div><div class="line">  repo: git@github.com:bailinlin/bailinlin.github.io.git  //此处记得改成你的 github 仓库的地址</div></pre></td></tr></table></figure>
<h3 id="你的-first-commit"><a href="#你的-first-commit" class="headerlink" title="你的 first commit"></a>你的 first commit</h3><p>按照约定我们先切分支,通过命令把项目切换到 dev 分支<br>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b dev</div></pre></td></tr></table></figure></p>
<p>然后 add 你的项目代码<br>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git add .</div></pre></td></tr></table></figure></p>
<p>你的 first commit<br>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git commit -m <span class="string">":tada: init blog"</span></div></pre></td></tr></table></figure></p>
<p>然后 push 你的代码到远程<br>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$  git push --set-upstream origin dev</div></pre></td></tr></table></figure></p>
<h3 id="你的第一次博客发布"><a href="#你的第一次博客发布" class="headerlink" title="你的第一次博客发布"></a>你的第一次博客发布</h3><p>发布其实很简单的,我们之前也说是一个命令行发布的,所以你只要<br>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure></p>
<p>然后你就可以看到一个属于你的 github.io 的网站了</p>
<h2 id="改变你的博客网站主题"><a href="#改变你的博客网站主题" class="headerlink" title="改变你的博客网站主题"></a>改变你的博客网站主题</h2><p>个人比较推荐的是 next ,大量的留白,让你的博客看起来简洁大方,或则你喜欢其它的主题也行,你需要在你的博客文件夹里clone 下你需要的主题</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</div></pre></td></tr></table></figure>
<p> 然后在 _config.yml 文件夹里修改你的主题配置</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ theme: next</div></pre></td></tr></table></figure>
<p> 然后 hexo s 就能看到你修改的主题生效了,为了防止 clone 下来的主题文件和自己的博客文件冲突,我删除了clone 下来的 .git 文件.你再按照你的 first commit 的操作提交你的修改就行了,然后别忘记了 deploy</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2016/03/30/learn-gulp/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/30/learn-gulp/" itemprop="url">
                  你需要知道的 gulp 自动化构建
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-03-30T20:37:03+08:00">
                2016-03-30
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/03/30/learn-gulp/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/30/learn-gulp/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="为什么要前端自动化"><a href="#为什么要前端自动化" class="headerlink" title="为什么要前端自动化"></a>为什么要前端自动化</h3><blockquote>
<p>什么是前端自动化构建就不说了，因为我不是写书的。在前端开发实践中，大公司都会有自己的基础前端架构，能容包括了开发环境、代码管理，代码质量，性能检测，命令行工具，开发规范，开发流程，前端架构及性能优化。相对而言，小公司或则是创业型的公司，前端架构这块做得就相对没有这么好，甚至于很不规范，而规范的目的在于提升工作效率。</p>
</blockquote>
<p>而规范需要一定的过程，我们就先从代码质量，代码管理上入手。</p>
<ol>
<li>对代码（html，css，js）进行语法检查</li>
<li>对图片，代码进行压缩</li>
<li>对sass。less 的css预处理器进行编译</li>
<li>期望代码有改动后，能自动刷新页面</li>
<li>…</li>
</ol>
<p>这些操作，我们可以通过人工来完成，但是效率真的低到没朋友，难道语法检查你要自己一行一行的<code>review</code>，或则是拜托你的同事帮你一行一行的 <code>review</code> 么。如果你让我做这个，我肯定和你绝交…但是 <code>review</code> 的目的是帮助我们写出高质量的代码。这是必不可少的，所以我们期望能有一个自动帮我们实现代码检测压缩的工具。只要一个命令，你就能轻松的实现代码压缩，图片压缩，<code>css</code>预处理器编译等原来需要你去人工完成的任务，是不是爽到爆炸。</p>
<p>在项目自动化构建工具中，大家用得比较多的，分别是<code>grunt</code>，<code>gulp</code>。与这些自动化工具配套的包管理工具呢，通常还有<code>npm</code>。<code>node</code>包含了<code>npm</code>的包，所以只要你的系统里安装的 <code>node</code>，你就可以在你的控制台里通过 npm install 来安装你的项目依赖。还有的就是最近流行起来的 <code>webpack</code> 模块管理工具,大家对<code>webpack</code> 的反应也很好，所以我们打算在项目开发的时候把 gulp 和 webpack 一起用起来，并把研究后的搭建流程写成教程。这次分享的是gulp的搭建，下次等我的后台项目开始用 webpack 的时候，再来分享一篇。</p>
<h3 id="从零开始搭建-gulp-前端自动化"><a href="#从零开始搭建-gulp-前端自动化" class="headerlink" title="从零开始搭建 gulp 前端自动化"></a>从零开始搭建 gulp 前端自动化</h3><ol>
<li>安装node.js</li>
<li>npm init 生成package文件，或则你可以自己手动生成</li>
<li>在控制台中输入<code>npm install --save-dev gulp</code>命令，在项目中安装gulp</li>
<li>配置gulp任务</li>
<li>在控制台中输入 <code>gulp</code>或则<code>gulp default</code>测试你的gulp任务</li>
<li>配置你真正需要的 gulp 任务，（压缩，代码质量检查，浏览器自动刷新）</li>
</ol>
<pre><code>var gulp = require(&apos;gulp&apos;);
gulp.task(&apos;default&apos;,function(){
    console.log(&quot;hello&quot;)
});



#####浏览器自动刷新

1. 在你的谷歌浏览器里安装插件。关键字`livereload`
2. 通过命令`mpn install gulp-livereload --save-dev`来安装依赖
3. 在gulp文件中引入`livereload = require(&apos;gulp-livereload&apos;),`
4. 在gulp的`watch`任务中通过 `livereload.listen([options])`启动刷新服务
5. 定义的任务在最后加入一个工作流`.pipe(livereload())`,
6. 在启动后进入到这个任务后，开启谷歌插件，就能自动刷新浏览器了

#gulpfile.js 文件

    var gulp = require(&apos;gulp&apos;),
    uglify = require(&apos;gulp-uglify&apos;),
    livereload = require(&apos;gulp-livereload&apos;),

gulp.task(&apos;test&apos;,function() {
    return gulp.src(&apos;js/test.js&apos;)
        .pipe(uglify())
        .pipe(gulp.dest(&apos;build&apos;))
        .pipe(livereload())
});

gulp.task(&apos;watch&apos;,function(){
    livereload.listen();
    gulp.watch(&apos;js/test.js&apos;, [&apos;test&apos;]);
});

当你修改你的test.js 文件之后，ctrl + s 保存，你就可以看到时时刷新。
</code></pre><p> 7.代码压缩</p>
<pre><code>1.通过命令`mpn install gulp-uglify --save-dev`来安装依赖(js 压缩)
2.通过命令`mpn install gulp-concat --save-dev`来安装依赖(合并压缩后的文件到一个文件)

    #gulpfile.js 文件

    uglify = require(&apos;gulp-uglify&apos;),

    gulp.task(&apos;compress&apos;,function(){
    return gulp.src(&apos;js/servers/*.js&apos;)
        .pipe(uglify())
        .pipe(concat(&apos;all.js&apos;))
        .pipe(gulp.dest(&apos;dist/js&apos;))
        .pipe(livereload())
});
</code></pre><p> 8.同理css压缩，生成雪碧图等task，代码质量检查，都是同样的先安装依赖，再引用，编写task</p>
<p><strong>如果你想深入学习</strong></p>
<p><a href="https://segmentfault.com/a/1190000004638228" target="_blank" rel="external">我理想中的前端工作流</a><br><a href="http://www.gulpjs.com.cn/" target="_blank" rel="external">gulp 中文网</a><br><a href="https://scotch.io/tutorials/a-quick-guide-to-using-livereload-with-gulp" target="_blank" rel="external">livereload</a><br><a href="https://www.npmjs.com/package/gulp-livereload" target="_blank" rel="external">gulp-livereload</a>ulp-livereload)</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2015/11/15/ng1-style-guide1/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/15/ng1-style-guide1/" itemprop="url">
                  你需要知道的 Angular 编程指南(上)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-11-15T20:20:00+08:00">
                2015-11-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2015/11/15/ng1-style-guide1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/11/15/ng1-style-guide1/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一个好的编程风格有助于团队的协同开发，所以在做 angular 开发时，我们也有一些约定，本文章主要是针对于使用 angular 和 coffeescript 编程的团队。（这是一个粗糙的翻译版本，原文的链接在文章下，感兴趣的同学可以去看）</p>
<blockquote>
<p><a href="https://github.com/johnpapa/angular-styleguide" target="_blank" rel="external">Angular 编程风格指导原文地址</a></p>
</blockquote>
<p>##1. 单一职责</p>
<p><strong>原则 1：一个文件只能定义一个组件</strong></p>
<p>下面的例子定义了app模块和他的依赖，把控制器和服务都定义到一个文件了</p>
<pre><code>-- 不推荐 --
SomeController = ()-&gt;
someFactory = ()-&gt;
angular
    .module(&apos;app&apos;, [&apos;ngRoute&apos;])
    .controller(&apos;SomeController&apos; , SomeController)
    .factory(&apos;someFactory&apos; , someFactory)
</code></pre><p>同样的组建，现在我们把它分解到他们自己的文件中</p>
<pre><code>-- 推荐方式 --
-- app.module.js --

angular
    .module(&apos;app&apos;, [&apos;ngRoute&apos;])


-- 推荐方式 --
-- someController.js --
SomeController = ()-&gt;
angular
    .module(&apos;app&apos;)
    .controller(&apos;SomeController&apos; , SomeController)


-- 推荐方式 --
-- someFactory.js --
someFactory = ()-&gt;
angular
    .module(&apos;app&apos;)
    .factory(&apos;someFactory&apos; , someFactory)
</code></pre><p>##2. 模块</p>
<p><strong>原则 2：定义模块的时候不要用变量来定义，用设置的语法来定义</strong></p>
<blockquote>
<p>因为我们使用的单一职责的原则，每一个组建一个文件，在定义组建的时候你已经用<code>angular.module</code>来介绍这个组建是哪个模块的了。</p>
</blockquote>
<pre><code>-- 不推荐 --
app = angular.module(&apos;app&apos;, [
    &apos;ngAnimate&apos;
    &apos;ngRoute&apos;
    &apos;app.shared&apos;
    &apos;app.dashboard&apos;
])
</code></pre><p>下面是不用变量的语法</p>
<pre><code>-- 推荐方式 --
angular
    .module(&apos;app&apos;, [
    &apos;ngAnimate&apos;
    &apos;ngRoute&apos;
    &apos;app.shared&apos;
    &apos;app.dashboard&apos;
])
</code></pre><p><strong>拓展</strong>：当使用模块的时候，不要用变量，要用链式定义的语法</p>
<blockquote>
<p>这样做能够使代码的可读性更高，同时也能避免变量的泄露和碰撞（重名）</p>
</blockquote>
<pre><code>-- 不推荐--
app = angular.module(&apos;app&apos;)
app.controller(&apos;SomeController&apos; , SomeController)
SomeController = ()-&gt;

-- 推荐方式 --
SomeController = ()-&gt;

angular
  .module(&apos;app&apos;)
  .controller(&apos;SomeController&apos; , SomeController)
</code></pre><p><strong>设置 vs 获取</strong>所有的实例只要设置一次</p>
<blockquote>
<p>一个模块只要被创建一次，之后的模块获取只要通过这个切入点来获取就可以了</p>
</blockquote>
<ul>
<li>用 <code>angular.module(&#39;app&#39;, [])</code> 来设置模块</li>
<li>用<code>angular.module(&#39;app&#39;)</code>来获取模块</li>
</ul>
<p><strong>命名函数 vs 匿名函数</strong>：使用命名函数来代替向回掉函数传递匿名函数</p>
<blockquote>
<p>这样能够是代码的可读性更高，更加容易debug，减少回调函数的嵌套</p>
</blockquote>
<pre><code>-- 不推荐 --
angular
  .module(&apos;app&apos;)
  .controller(&apos;Dashboard&apos;, ()-&gt;)
  .factory(&apos;logger&apos;, ()-&gt; )

-- 推荐方式 --
-- dashboard.js --
Dashboard = ()-&gt;
  # logic goes here --&gt;
  return

angular
  .module(&apos;app&apos;)
  .controller(&apos;Dashboard&apos;, Dashboard)

-- 推荐方式 --
-- logger.js --
logger = ()-&gt;
  # logic goes here --&gt;
  return

angular
  .module(&apos;app&apos;)
  .factory(&apos;logger&apos;, logger)
</code></pre><p><strong>IIFE（立即调用函数表达式）：</strong>把angular 组建包裹在能够马上调用的函数表达式中</p>
<blockquote>
<p>IIFE 把变量从全局作用域里解放出来，这样做能防止把变量和函数定义在全局作用句中从而造成变量的碰撞（）变量重名造成的莫名其妙的bug）</p>
</blockquote>
<pre><code>(-&gt;
  logger = ()-&gt;
    # logic goes here --&gt;
    return

  angular
    .module(&apos;app&apos;)
    .factory(&apos;logger&apos;, logger);

)()
</code></pre><p><strong>主意</strong>：为了使代码更加简洁，下面的编程先省略 IIFE 语法</p>
<p>##3. 控制器</p>
<p><strong>controller as view 语法：</strong>用 <code>controllerAs</code>语法来代替经典的把controller 绑定到  $scope 作用域的语法</p>
<ul>
<li>控制器是一个构造类，需要通过<code>newed</code>来创建一个新的实例，但是<code>controllerAS</code>语法更像 javascript 的构造函数</li>
<li>这样的用法能够促进我们在视图中绑定对应对象的变量（ 用<code>customer.name</code>来取代<code>name</code>）等等，这样能够是我们的代码更易读，避免我们没有指定对象的时候的一些参考问题。</li>
<li><p>能够让我们避免在视图中的嵌套控制器中使用<code>$parent</code>来调用父级控制器</p>
<pre><code>-- 不推荐 --
&lt;div ng-controller=&quot;Customer&quot;&gt;
  {{ name }}
&lt;/div&gt;
-- 推荐方式 --
&lt;div ng-controller=&quot;Customer as customer&quot;&gt;
  {{ customer.name }}
&lt;/div&gt;
</code></pre></li>
</ul>
<p><strong>controllerAs Controller Syntax</strong>：用<code>controllerAs</code>来代替<code>传统的将控制器绑定到$scope</code>的语法</p>
<ul>
<li><code>controllerAs</code>通过 <code>this</code>来从控制器的内部把返回的内容绑定到$scope 上<br><code>controllerAs</code>在语法上比 <code>$scope</code>要友好，使用<code>controllerAs</code> 你依旧可以把把数据绑定到视图，依旧可以访问绑定在<code>$scope</code>上的方法</li>
<li><p>能够避免可能把方法定义到服务上更好的时候，想要将控制器中的方法绑定到<code>$scope</code>上，在服务中要考虑$scope 的用法，在控制器中只有必要的时候才能绑定到<code>$scope</code>上，举个例子，当要通过<code>$emit</code>,<code>$broadcast</code>,<code>$on</code>来传递和接收事件的时候，要在服务中定义，再在控制器中调用<br><strong>主意</strong>：介于 coffeescript 会自动返回最后一行，我们最好在函数的最后一行加上一个return 声明（即使这个函数没有任何东西返回），大多数上可以没有返回声明，但是在我自己的开发过程中，没有返回声明的时候，会报错，所以建议还是加上这个返回声明</p>
<pre><code>-- 不推荐 --
(-&gt;
  Customer = ($scope)-&gt;
    $scope.name = {}
    $scope.sendMessage = ()-&gt;
  angular
    .module(&apos;app&apos;)
    .controller(&apos;Customer&apos;, Customer)
)()
-- 推荐方法 --
(-&gt;
  Customer = ()-&gt;
    @name = {}
    @sendMessage = ()-&gt;
    return

  angular
    .module(&apos;app&apos;)
    .controller(&apos;Customer&apos;, Customer)
)()
</code></pre></li>
</ul>
<p><strong>controllerAS with vm</strong>当使用<code>controllerAs</code>语法时，用一个变量来代替 this ，找一个统一的变量名来代替视图模型例如 <code>vm</code></p>
<p><code>this</code>关键字是联系上下文的，当在控制器中使用函数的时候可能会改变上下文，为了避免这样的情况，最好用一个变量来捕获<code>this</code></p>
<pre><code>-- 不推荐 --
(-&gt;
  Customer = ()-&gt;
    @name = {}
    @sendMessage = ()-&gt;
      # here @/this is not the same
      @stuff = &quot;stuff&quot;

    return
  angular
    .module(&apos;app&apos;)
    .controller(&apos;Customer&apos;, Customer)
)()


-- 推荐方式 --
(-&gt;
  Customer = ()-&gt;
    vm = @
    vm.name = {}
    vm.sendMessage = ()-&gt;

    return
  angular
    .module(&apos;app&apos;)
    .controller(&apos;Customer&apos;, Customer)
)()
</code></pre><p>【tip】</p>
<pre><code>### OR use the fat arrow in functions =&gt; ###
(-&gt;
  Customer = ()-&gt;
    @name = {}
    @sendMessage = ()=&gt;
      @stuff

    return
  angular
    .module(&apos;app&apos;)
    .controller(&apos;Customer&apos;, Customer)
)()
</code></pre><p>【note】：你可以把下面这段代码放到你的代码的最前一行，来避免一些组建的语法检查</p>
<pre><code>### jshint validthis: true ###
vm = @
</code></pre><p><strong>把变量放在控制器的最前面</strong></p>
<p>把数据绑定的变量成员（按照字母顺序）放在控制器的最前面，而不是遍布在整个控制器中。</p>
<blockquote>
<p>把数据绑定的变量成员放在控制器的最前面,使程序更加易读，帮你立即分辨控制器中这个变量成员可以绑定在视图中</p>
</blockquote>
<pre><code>-- 不推荐 --
function SessionsController() {
    var vm = this;

    vm.gotoSession = function() {
      /* ... */
    };
    vm.refresh = function() {
      /* ... */
    };
    vm.search = function() {
      /* ... */
    };
    vm.sessions = [];
    vm.title = &apos;Sessions&apos;;
}

-- 推荐方式 --
function SessionsController() {
    var vm = this;

    vm.gotoSession = gotoSession;
    vm.refresh = refresh;
    vm.search = search;
    vm.sessions = [];
    vm.title = &apos;Sessions&apos;;

    ////////////

    function gotoSession() {
      /* */
    }

    function refresh() {
      /* */
    }

    function search() {
      /* */
    }
}
</code></pre><p>【note】 如果函数是一行的就把函数也放在控制器的前面，这样做对代码的阅读性不会有影响</p>
<pre><code>-- 不推荐--
function SessionsController(data) {
    var vm = this;

    vm.gotoSession = gotoSession;
    vm.refresh = function() {
        blabla
    };
    vm.search = search;
    vm.sessions = [];
    vm.title = &apos;Sessions&apos;;
}



-- 推荐方法--
function SessionsController(sessionDataService) {
    var vm = this;

    vm.gotoSession = gotoSession;
    vm.refresh = sessionDataService.refresh; // 1 liner is OK
    vm.search = search;
    vm.sessions = [];
    vm.title = &apos;Sessions&apos;;
}
</code></pre><h3 id="函数声明，隐藏实现细节"><a href="#函数声明，隐藏实现细节" class="headerlink" title="函数声明，隐藏实现细节"></a>函数声明，隐藏实现细节</h3><p>函数声明，隐藏实现的细节。把用于数据绑定的变量成员的声明，放在控制器的前面，实现放在文件的后面。</p>
<ul>
<li>把数据绑定的成员放在前面易于代码的阅读，能让你一眼就分辨出哪个变量用于视图的哪块区域的绑定</li>
<li>把函数的实现放在文件的后面，把函数实现这部分比较复杂的部分放在后面。能让你直接看到函数声明这部分重要的信息</li>
<li>因为函数的声明被提升了，所以在函数定义前，你是不需要关心这个函数的</li>
<li>你不需要担心函数声明的位子移动的问题，你不用担心”因为a函数是依赖于b函数的，a函数移动到b函数前面会让你的代码出错”这样子的问题</li>
<li><p>顺序在函数表达式中很重要</p>
<pre><code>--不建议使用函数表达式--
function AvengersController(avengersService, logger) {
    var vm = this;
    vm.avengers = [];
    vm.title = &apos;Avengers&apos;;

    var activate = function() {
        return getAvengers().then(function() {
            logger.info(&apos;Activated Avengers View&apos;);
        });
    }

    var getAvengers = function() {
        return avengersService.getAvengers().then(function(data) {
            vm.avengers = data;
            return vm.avengers;
        });
    }

    vm.getAvengers = getAvengers;

    activate();
}
</code></pre></li>
</ul>
<p>主意上面的例子中把重要的函数声明分散在控制器中，但在下面的例子中重要的函数声明都被提升到了顶部。举个栗子，函数绑定变量如<code>vm.avengers</code>和<code>vm.title</code>，把函数实现的细节放在后面，这样更加有利于代码的阅读</p>
<pre><code>--  推荐方法 --
function AvengersController(avengersService, logger) {
    var vm = this;
    vm.avengers = [];
    vm.getAvengers = getAvengers;
    vm.title = &apos;Avengers&apos;;

    activate();

    function activate() {
        return getAvengers().then(function() {
            logger.info(&apos;Activated Avengers View&apos;);
        });
    }

    function getAvengers() {
        return avengersService.getAvengers().then(function(data) {
            vm.avengers = data;
            return vm.avengers;
        });
    }
}
</code></pre><p>###把控制器的逻辑定义放到服务中</p>
<ul>
<li>逻辑可能会在多个控制器中复用，通过封装在服务中来通过函数暴露给控制器</li>
<li>把逻辑封装在服务中，能更容易在单元测试中分离成独立作用域，在控制器中调用函数也更容易模拟</li>
<li>从控制器中移除依赖，把实现细节隐藏起来</li>
<li><p>让控制器变得简单，苗条，且专注</p>
<pre><code>-- 不推荐 --
function OrderController($http, $q, config, userInfo) {
    var vm = this;
    vm.checkCredit = checkCredit;
    vm.isCreditOk;
    vm.total = 0;

    function checkCredit() {
        var settings = {};
        // Get the credit service base URL from config
        // Set credit service required headers
        // Prepare URL query string or data object with request data
        // Add user-identifying info so service gets the right credit limit for this user.
        // Use JSONP for this browser if it doesn&apos;t support CORS
        return $http.get(settings)
            .then(function(data) {
             // Unpack JSON data in the response object
               // to find maxRemainingAmount
               vm.isCreditOk = vm.total &lt;= maxRemainingAmount
            })
            .catch(function(error) {
               // Interpret error
               // Cope w/ timeout? retry? try alternate service?
               // Re-reject with appropriate error for a user to see
            });
    };
}
-- 推荐方法 --
function OrderController(creditService) {
    var vm = this;
    vm.checkCredit = checkCredit;
    vm.isCreditOk;
    vm.total = 0;

    function checkCredit() {
       return creditService.isOrderTotalOk(vm.total)
          .then(function(isOk) { vm.isCreditOk = isOk; })
          .catch(showError);
    };
}
</code></pre></li>
</ul>
<h3 id="使控制器变得专注"><a href="#使控制器变得专注" class="headerlink" title="使控制器变得专注"></a>使控制器变得专注</h3><p>为一个视图定义一个控制器，不要讲一个控制器为多个视图复用，要把复用的逻辑封装到服务中，保证一个控制器只专注于他的视图</p>
<p>给多个视图复用的控制器是很脆的，一个好的 E2E测试覆盖率是用来确定一个应用的稳定性的</p>
<h3 id="路由分配"><a href="#路由分配" class="headerlink" title="路由分配"></a>路由分配</h3><p>当一个控制器必须和某个视图绑定但也有可能和其他视图或者控制器复用，把控制器的定义和路由条状一起定义</p>
<p>【note】如果一个视图不是通过路由而是通过其他方式加载的，请用<code>ng-controller=&quot;Avengers as vm&quot;</code>语法</p>
<p>在路由中分配控制器，允许不同的路由去调用不同的控制器和视图，当控制器是在视图中通过<code>ng-controller</code> 进行声明，那么这个视图就要和这个控制器一直关联</p>
<pre><code>-- 不推荐 --

// route-config.js
angular
    .module(&apos;app&apos;)
    .config(config);

function config($routeProvider) {
    $routeProvider
        .when(&apos;/avengers&apos;, {
          templateUrl: &apos;avengers.html&apos;
        });
}

&lt;!-- avengers.html --&gt;
&lt;div ng-controller=&quot;AvengersController as vm&quot;&gt;
&lt;/div&gt;



-- 推荐方式 --

// route-config.js
angular
    .module(&apos;app&apos;)
    .config(config);

function config($routeProvider) {
    $routeProvider
        .when(&apos;/avengers&apos;, {
            templateUrl: &apos;avengers.html&apos;,
            controller: &apos;Avengers&apos;,
            controllerAs: &apos;vm&apos;
        });
}
&lt;!-- avengers.html --&gt;
&lt;div&gt;
&lt;/div&gt;
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/bbt.jpeg"
               alt="bailinlin" />
          <p class="site-author-name" itemprop="name">bailinlin</p>
          <p class="site-description motion-element" itemprop="description">前端,白霸天,博客</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">21</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bailinlin</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"baibatian"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  








  
  

  

  

  

  


</body>
</html>
