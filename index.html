<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="前端,白霸天,博客">
<meta property="og:type" content="website">
<meta property="og:title" content="白霸天的博客">
<meta property="og:url" content="https://bailinlin.github.com/index.html">
<meta property="og:site_name" content="白霸天的博客">
<meta property="og:description" content="前端,白霸天,博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="白霸天的博客">
<meta name="twitter:description" content="前端,白霸天,博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://bailinlin.github.com/"/>





  <title> 白霸天的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">白霸天的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2018/06/20/javascript2/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/06/20/javascript2/" itemprop="url">
                  精读《你不知道的javascript》中卷
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-20T14:04:36+08:00">
                2018-06-20
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2018/06/20/javascript2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/06/20/javascript2/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>《你不知道的 javascript》是一个前端学习必读的系列，让不求甚解的JavaScript开发者迎难而上，深入语言内部，弄清楚JavaScript每一个零部件的用途。本书《你不知道的javascript》中卷介绍了该系列的两个主题：“类型和语法”以及“异步与性能”。这两块也是值得我们反复去学习琢磨的两块只是内容，今天我们用思维导图的方式来精读一遍。（思维导图图片可能有点小，记得点开看，你会有所收获）</p>
<h3 id="第一部分-作用域和闭包"><a href="#第一部分-作用域和闭包" class="headerlink" title="第一部分 作用域和闭包"></a>第一部分 作用域和闭包</h3><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c2f4d3ede46a?w=1105&amp;h=870&amp;f=jpeg&amp;s=140823" alt=""><br>JavaScript 有 七 种 内 置 类 型: null 、 undefined 、 boolean 、 number 、 string 、 object 和 symbol ,可以使用 typeof 运算符来查看。</p>
<p>变量没有类型,但它们持有的值有类型。类型定义了值的行为特征。</p>
<p>很多开发人员将 undefined 和 undeclared 混 为 一 谈, 但 在 JavaScript 中 它 们 是 两 码 事。 undefined 是值的一种。 undeclared 则表示变量还没有被声明过。</p>
<p>遗憾的是, JavaScript 却将它们混为一谈, 在我们试图访问 “undeclared” 变量时这样报 错:ReferenceError: a is not defined, 并 且 typeof 对 undefined 和 undeclared 变 量 都 返 回 “undefined” 。</p>
<p>然而,通过 typeof 的安全防范机制(阻止报错)来检查 undeclared 变量,有时是个不错的办法。</p>
<h3 id="值"><a href="#值" class="headerlink" title="值"></a>值</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c2f9fd654d30?w=1299&amp;h=398&amp;f=jpeg&amp;s=77055" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c2fbdebcded2?w=1300&amp;h=894&amp;f=jpeg&amp;s=195120" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c2fdca914292?w=1303&amp;h=706&amp;f=jpeg&amp;s=150852" alt=""></p>
<p>JavaScript 中的数组是通过数字索引的一组任意类型的值。字符串和数组类似,但是它们的 行为特征不同, 在将字符作为数组来处理时需要特别小心。 JavaScript 中的数字包括“整 数”和“浮点型”。</p>
<p>基本类型中定义了几个特殊的值。</p>
<p>null 类型只有一个值 null , undefined 类型也只有一个值 undefined 。 所有变量在赋值之 前默认值都是 undefined 。 void 运算符返回 undefined 。</p>
<p>数 字 类 型 有 几 个 特 殊 值, 包 括 NaN ( 意 指“not a number” , 更 确 切 地 说 是“invalid number” )、 +Infinity 、 -Infinity 和 -0 。</p>
<p>简单标量基本类型值(字符串和数字等)通过值复制来赋值 / 传递, 而复合值(对象等) 通过引用复制来赋值 / 传递。 JavaScript 中的引用和其他语言中的引用 / 指针不同,它们不 能指向别的变量 / 引用,只能指向值。</p>
<h3 id="原生函数"><a href="#原生函数" class="headerlink" title="原生函数"></a>原生函数</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c303afb22377?w=1450&amp;h=770&amp;f=jpeg&amp;s=128562" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c306f032cf04?w=1450&amp;h=682&amp;f=jpeg&amp;s=180566" alt=""></p>
<p>JavaScript 为基本数据类型值提供了封装对象,称为原生函数(如 String 、 Number 、 Boolean 等)。它们为基本数据类型值提供了该子类型所特有的方法和属性(如: String#trim() 和 Array#concat(..) )。</p>
<p>对于简单标量基本类型值,比如 “abc” ,如果要访问它的 length 属性或 String.prototype 方法, JavaScript 引擎会自动对该值进行封装(即用相应类型的封装对象来包装它)来实现对这些属性和方法的访问。</p>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c30a226085fc?w=1499&amp;h=239&amp;f=jpeg&amp;s=43515" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c30d238ec375?w=1499&amp;h=891&amp;f=jpeg&amp;s=213161" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c30efc487344?w=1499&amp;h=887&amp;f=jpeg&amp;s=203319" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c310cc70fdcc?w=1499&amp;h=823&amp;f=jpeg&amp;s=164996" alt=""></p>
<p>本章介绍了 JavaScript 的数据类型之间的转换,即强制类型转换:包括显式和隐式。</p>
<p>强制类型转换常常为人诟病, 但实际上很多时候它们是非常有用的。 作为有使命感的 JavaScript 开发人员,我们有必要深入了解强制类型转换,这样就能取其精华,去其糟粕。</p>
<p>显式强制类型转换明确告诉我们哪里发生了类型转换, 有助于提高代码可读性和可维 护性。</p>
<p>隐式强制类型转换则没有那么明显,是其他操作的副作用。感觉上好像是显式强制类型转 换的反面,实际上隐式强制类型转换也有助于提高代码的可读性。</p>
<p>在处理强制类型转换的时候要十分小心,尤其是隐式强制类型转换。在编码的时候,要知 其然,还要知其所以然,并努力让代码清晰易读。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c313229058fc?w=1250&amp;h=857&amp;f=jpeg&amp;s=153667" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c315bee42707?w=1253&amp;h=870&amp;f=jpeg&amp;s=194344" alt=""><br>JavaScript 语法规则中的许多细节需要我们多花点时间和精力来了解。 从长远来看, 这有 助于更深入地掌握这门语言。</p>
<p>语句和表达式在英语中都能找到类比——语句就像英语中的句子,而表达式就像短语。表 达式可以是简单独立的,否则可能会产生副作用。</p>
<p>JavaScript 语法规则之上是语义规则(也称作上下文)。例如, { } 在不同情况下的意思不 尽相同,可以是语句块、对象常量、解构赋值(ES6)或者命名函数参数(ES6)。</p>
<p>JavaScript 详细定义了运算符的优先级(运算符执行的先后顺序)和关联(多个运算符的 组合方式)。只要熟练掌握了这些规则,就能对如何合理地运用它们作出自己的判断。</p>
<p>ASI(自动分号插入)是 JavaScript 引擎的代码解析纠错机制, 它会在需要的地方自动插 入分号来纠正解析错误。问题在于这是否意味着大多数的分号都不是必要的(可以省略), 或者由于分号缺失导致的错误是否都可以交给 JavaScript 引擎来处理。</p>
<p>JavaScript 中有很多错误类型, 分为两大类:早期错误(编译时错误, 无法被捕获)和运 行时错误(可以通过 try..catch 来捕获)。所有语法错误都是早期错误,程序有语法错误 则无法运行。</p>
<p>函数参数和命名参数之间的关系非常微妙。尤其是 arguments 数组,它的抽象泄漏给我们 挖了不少坑。因此,尽量不要使用 arguments ,如果非用不可,也切勿同时使用 arguments 和其对应的命名参数。</p>
<p>finally 中代码的处理顺序需要特别注意。它们有时能派上很大用场,但也容易引起困惑, 特别是在和带标签的代码块混用时。总之,使用 finally 旨在让代码更加简洁易读,切忌 弄巧成拙。</p>
<p>switch 相对于 if..else if.. 来说更为简洁。需要注意的一点是,如果对其理解得不够透 彻,稍不注意就很容易出错。</p>
<h3 id="第二部分-this-和对象原型"><a href="#第二部分-this-和对象原型" class="headerlink" title="第二部分 this 和对象原型"></a>第二部分 this 和对象原型</h3><h3 id="异步：现在与将来"><a href="#异步：现在与将来" class="headerlink" title="异步：现在与将来"></a>异步：现在与将来</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c318a66b1032?w=1200&amp;h=619&amp;f=jpeg&amp;s=126139" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c31aeeeaae13?w=1200&amp;h=698&amp;f=jpeg&amp;s=138515" alt=""><br>实际上, JavaScript 程序总是至少分为两个块:第一块 现在 运行;下一块 将来 运行, 以响 应某个事件。尽管程序是一块一块执行的,但是所有这些块共享对程序作用域和状态的访 问,所以对状态的修改都是在之前累积的修改之上进行的。</p>
<p>一旦有事件需要运行, 事件循环就会运行, 直到队列清空。 事件循环的每一轮称为一个 tick。 用户交互、IO 和定时器会向事件队列中加入事件。</p>
<p>任意时刻,一次只能从队列中处理一个事件。执行事件的时候,可能直接或间接地引发一 个或多个后续事件。</p>
<p>并发是指两个或多个事件链随时间发展交替执行,以至于从更高的层次来看,就像是同时 在运行(尽管在任意时刻只处理一个事件)。</p>
<p>通常需要对这些并发执行的“进程”(有别于操作系统中的进程概念)进行某种形式的交 互协调,比如需要确保执行顺序或者需要防止竞态出现。这些“进程”也可以通过把自身 分割为更小的块,以便其他“进程”插入进来。</p>
<h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c31dc255b722?w=1200&amp;h=845&amp;f=jpeg&amp;s=169244" alt=""></p>
<p>回调函数是 JavaScript 异步的基本单元。但是随着 JavaScript 越来越成熟,对于异步编程领域的发展,回调已经不够用了。</p>
<p>第一,大脑对于事情的计划方式是线性的、阻塞的、单线程的语义,但是回调表达异步流 程的方式是非线性的、非顺序的,这使得正确推导这样的代码难度很大。难于理解的代码 是坏代码,会导致坏 bug。</p>
<p>我们需要一种更同步、更顺序、更阻塞的的方式来表达异步,就像我们的大脑一样。</p>
<p>第二,也是更重要的一点,回调会受到控制反转的影响,因为回调暗中把控制权交给第三 方(通常是不受你控制的第三方工具!)来调用你代码中的 continuation。 这种控制转移导 致一系列麻烦的信任问题,比如回调被调用的次数是否会超出预期。</p>
<p>可以发明一些特定逻辑来解决这些信任问题,但是其难度高于应有的水平,可能会产生更 笨重、更难维护的代码,并且缺少足够的保护,其中的损害要直到你受到 bug 的影响才会 被发现。</p>
<p>我们需要一个通用的方案来解决这些信任问题。不管我们创建多少回调,这一方案都应可 以复用,且没有重复代码的开销。</p>
<p>我们需要比回调更好的机制。到目前为止,回调提供了很好的服务,但是未来的 JavaScript 需要更高级、功能更强大的异步模式。本书接下来的几章会深入探讨这些新型技术。</p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c3210ed1135d?w=1559&amp;h=321&amp;f=jpeg&amp;s=81813" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c322b9dce156?w=1559&amp;h=712&amp;f=jpeg&amp;s=219007" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c32579139ed3?w=1561&amp;h=715&amp;f=jpeg&amp;s=201171" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c3279bb0a8d7?w=1506&amp;h=773&amp;f=jpeg&amp;s=236818" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c3299cc4a0d4?w=1504&amp;h=330&amp;f=jpeg&amp;s=101344" alt=""></p>
<p>Promise 非常好,请使用。它们解决了我们因只用回调的代码而备受困扰的控制反转问题。</p>
<p>它们并没有摈弃回调,只是把回调的安排转交给了一个位于我们和其他工具之间的可信任 的中介机制。</p>
<p>Promise 链也开始提供(尽管并不完美)以顺序的方式表达异步流的一个更好的方法,这 有助于我们的大脑更好地计划和维护异步 JavaScript 代码。我们将在第 4 章看到针对这个 问题的一种更好的解决方案!</p>
<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c32bc25ce357?w=1430&amp;h=893&amp;f=jpeg&amp;s=251348" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c32dfa81cca0?w=1429&amp;h=875&amp;f=jpeg&amp;s=220277" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c32feeacf0c8?w=1429&amp;h=330&amp;f=jpeg&amp;s=82989" alt=""><br>生成器是 ES6 的一个新的函数类型, 它并不像普通函数那样总是运行到结束。 取而代之 的是, 生成器可以在运行当中(完全保持其状态)暂停, 并且将来再从暂停的地方恢复 运行。</p>
<p>这种交替的暂停和恢复是合作性的而不是抢占式的,这意味着生成器具有独一无二的能力 来暂停自身,这是通过关键字 yield 实现的。不过,只有控制生成器的迭代器具有恢复生 成器的能力(通过 next(..) )。</p>
<p>yield / next(..) 这一对不只是一种控制机制,实际上也是一种双向消息传递机制。 yield .. 表 达式本质上是暂停下来等待某个值,接下来的 next(..) 调用会向被暂停的 yield 表达式传回 一个值(或者是隐式的 undefined )。</p>
<p>在异步控制流程方面,生成器的关键优点是:生成器内部的代码是以自然的同步 / 顺序方 式表达任务的一系列步骤。其技巧在于,我们把可能的异步隐藏在了关键字 yield 的后面, 把异步移动到控制生成器的迭代器的代码部分。</p>
<p>换句话说,生成器为异步代码保持了顺序、同步、阻塞的代码模式,这使得大脑可以更自 然地追踪代码,解决了基于回调的异步的两个关键缺陷之一。</p>
<h3 id="程序性能"><a href="#程序性能" class="headerlink" title="程序性能"></a>程序性能</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c33279d14790?w=1150&amp;h=757&amp;f=jpeg&amp;s=152257" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c334668ebefc?w=1150&amp;h=273&amp;f=jpeg&amp;s=64116" alt=""></p>
<p>本部分的前四章都是基于这样一个前提:异步编码模式使我们能够编写更高效的代码,通 常能够带来非常大的改进。但是,异步特性只能让你走这么远,因为它本质上还是绑定在 一个单事件循环线程上。</p>
<p>因此,在这一章里,我们介绍了几种能够进一步提高性能的程序级别的机制。</p>
<p>Web Worker 让你可以在独立的线程运行一个 JavaScript 文件(即程序),使用异步事件在 线程之间传递消息。 它们非常适用于把长时间的或资源密集型的任务卸载到不同的线程 中,以提高主 UI 线程的响应性。</p>
<p>SIMD 打算把 CPU 级的并行数学运算映射到 JavaScript API, 以获得高性能的数据并行运算,比如在大数据集上的数字处理。</p>
<p>最后, asm.js 描述了 JavaScript 的一个很小的子集, 它避免了 JavaScript 难以优化的部分 (比如垃圾收集和强制类型转换),并且让 JavaScript 引擎识别并通过激进的优化运行这样 的代码。可以手工编写 asm.js, 但是会极端费力且容易出错,类似于手写汇编语言(这也 是其名字的由来)。实际上, asm.js 也是高度优化的程序语言交叉编译的一个很好的目标, 比如 Emscripten 把 C/C++ 转换成 JavaScript(<a href="https://github.com/kripken/emscripten/wiki" target="_blank" rel="external">https://github.com/kripken/emscripten/wiki</a>) 。</p>
<p>JavaScript 还有一些更加激进的思路已经进入非常早期的讨论, 尽管本章并没有明确包含 这些内容,比如近似的直接多线程功能(而不是藏在数据结构 API 后面)。不管这些最终 会不会实现,还是我们将只能看到更多的并行特性偷偷加入 JavaScript, 但确实可以预见, 未来 JavaScript 在程序级别将获得更加优化的性能。</p>
<h3 id="性能测试与调优"><a href="#性能测试与调优" class="headerlink" title="性能测试与调优"></a>性能测试与调优</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c336f145c542?w=1486&amp;h=883&amp;f=jpeg&amp;s=206732" alt=""></p>
<p>对一段代码进行有效的性能测试,特别是与同样代码的另外一个选择对比来看看哪种方案 更快,需要认真注意细节。</p>
<p>与其打造你自己的统计有效的性能测试逻辑,不如直接使用 Benchmark.js 库,它已经为你 实现了这些。但是,编写测试要小心,因为我们很容易就会构造一个看似有效实际却有缺 陷的测试,即使是微小的差异也可能扭曲结果,使其完全不可靠。</p>
<p>从尽可能多的环境中得到尽可能多的测试结果以消除硬件/ 设备的偏差, 这一点很重要。 jsPerf.com 是很好的网站,用于众包性能测试运行。</p>
<p>遗憾的是,很多常用的性能测试执迷于无关紧要的微观性能细节,比如 x++ 对比 ++x 。编 写好的测试意味着理解如何关注大局, 比如关键路径上的优化以及避免落入类似不同的 JavaScript 实现细节这样的陷阱中。</p>
<p>尾调用优化是 ES6 要求的一种优化方法。它使 JavaScript 中原本不可能的一些递归模式变 得实际。 TCO 允许一个函数在结尾处调用另外一个函数来执行,不需要任何额外资源。这意味着,对递归算法来说,引擎不再需要限制栈深度。</p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>思维导图能比较清晰的还原整本书的知识结构体系，如果你还没用看过这本书，可以按照这个思维导图的思路快速预习一遍，提高学习效率。学习新事物总容易遗忘，我比较喜欢在看书的时候用思维导图做些记录，便于自己后期复习，如果你已经看过了这本书，也建议你收藏复习。如果你有神马建议或则想法，欢迎留言或加我微信交流：646321933，备注技术交流</p>
<p><a href="https://bailinlin.github.io/2018/05/28/javascript1/" target="_blank" rel="external">精读《你不知道的javascript》上卷</a></p>
<p><a href="https://bailinlin.github.io/2018/06/08/node-notes/" target="_blank" rel="external">精读《深入浅出Node.js》</a></p>
<p><a href="https://github.com/bailinlin/Awsome-Front-End-Xmind" target="_blank" rel="external">思维导图下载地址</a></p>
<p><a href="https://github.com/threerocks/studyFiles/blob/master/js/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%EF%BC%88%E4%B8%AD%E5%8D%B7%EF%BC%89.pdf" target="_blank" rel="external">你不知道的 javascript（中卷）PDF 下载地址</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2018/06/12/ljhs/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/06/12/ljhs/" itemprop="url">
                  你需要知道的 javascript 垃圾回收机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-12T15:11:38+08:00">
                2018-06-12
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2018/06/12/ljhs/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/06/12/ljhs/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>我们通常理解的 javascript 垃圾回收机制都停留在表面，”会释放不被引用变量内存”，最近在读《深入浅出node.js》的书，详细了解了下 v8 垃圾回收的算法，记录了一些学习笔记。</p>
</blockquote>
<h3 id="敲黑板：v8引擎的垃圾回收算法"><a href="#敲黑板：v8引擎的垃圾回收算法" class="headerlink" title="敲黑板：v8引擎的垃圾回收算法"></a>敲黑板：v8引擎的垃圾回收算法</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/12/163f306c4254c932?w=1064&amp;h=492&amp;f=jpeg&amp;s=114417" alt=""></p>
<p>V8的垃圾回收策略主要基于分代式垃圾回收机制，现代的垃圾回收算法中按对象的存活时间将内存的垃圾回收进行不同的分代,然后分别对不同分代的内存施以更高效的算法。在V8中,主要将内存分为新生代和老生代两代。新生代中的对象为存活时间较短的对象, 老生代中的对象为存活时间较长或常驻内存的对象。</p>
<h3 id="Scavenge算法"><a href="#Scavenge算法" class="headerlink" title="Scavenge算法"></a>Scavenge算法</h3><blockquote>
<p>在分代的基础上,新生代中的对象主要通过Scavenge算法进行垃圾回收,在Scavenge的具体 实现中,主要采用了Cheney算法</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/12/163f30742b0bf065?w=1130&amp;h=568&amp;f=jpeg&amp;s=175952" alt=""></p>
<p>Cheney 算法是一种采用复制的方式实现的垃圾回收算法。它将堆内存一分为二,每一部分空间称为 semispace。在这两个 semispace 空间中,只有一个处于使用中,另一个处于闲置状态。处于使用状态的 semispace 空间称为 From 空间,处于闲置状态的空间称为 To 空间。当我们分配对象时,先是在 From 空间中进行分配。当开始进行垃圾回收时,会检查 From 空间中的存活对象,这 些存活对象将被复制到 To 空间中,而非存活对象占用的空间将会被释放。完成复制后,From 空 间和To空间的角色发生对换。 简而言之, 在垃圾回收的过程中, 就是通过将存活对象在两个 semispace 空间之间进行复制。</p>
<h3 id="Mark-Sweep-amp-Mark-Compact"><a href="#Mark-Sweep-amp-Mark-Compact" class="headerlink" title="Mark-Sweep &amp; Mark-Compact"></a>Mark-Sweep &amp; Mark-Compact</h3><blockquote>
<p>Scavenge算法通过牺牲空间换时间的算法非常适合生命周期短的新生代，但是，当一个对象经过多次复制，生命周期较长的时候或则To空间不足的时候，对象会被分配到进入到老生代中，需要采用新的算法进行垃圾回收。</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/12/163f307747161f7d?w=1175&amp;h=609&amp;f=jpeg&amp;s=184055" alt=""></p>
<p>Mark-Sweep 并不将内存空间划分为两半,所以不存在浪费一半空间的行为。与 Scavenge 复制活着的对象不同, Mark-Sweep 在标记阶段遍历堆中的所有对象,并标记活着的对象,在随后的清除阶段中,只清除没有被标记的对象。可以看出,Scavenge 中只复制活着的对象,而 Mark-Sweep 只清理死亡对象。</p>
<p>Mark-Sweep 在进行一次标记清除回收后,内存空间会出现不连续的状态。这种内存碎片会对后续的内存分配造成问题,因为很可能出现需要分配一个大对象的情况,这时所有的碎片空间都无法完成此次分配,就会提前触发垃圾回收,而这次回收是不必要的。Mark-Compact 对象在标记为死亡后,在整理的过程中,将活着的对象往一端移动,移动完成后,直接清理掉边界外的内存</p>
<h3 id="增量标记"><a href="#增量标记" class="headerlink" title="增量标记"></a>增量标记</h3><p>为了避免出现 JavaScript 应用逻辑与垃圾回收器看到的不一致的情况,垃圾回收的 3 种基本算法都需要将应用逻辑暂停下来,待执行完垃圾回收后再恢复执行应用逻辑,这种行为被称为“全停顿”，长时间的”全停顿”垃圾回收会让用户感受到明显的卡顿，带来体验的影响。以1.5 GB的垃圾回收堆内存为例,V8做一次小的垃圾回收需要50毫秒以上,做一次非增量式的垃圾回收甚至要1秒以上。这是垃圾回收中引起JavaScript线程暂停执行的时间,在 这样的时间花销下,应用的性能和响应能力都会直线下降。</p>
<p>为了降低全堆垃圾回收带来的停顿时间,V8先从标记阶段入手,将原本要一口气停顿完成的动作改为增量标记(incremental marking),也就是拆分为许多小“步进”,每做完一“步进” 就让 JavaScript 应用逻辑执行一小会儿,垃圾回收与应用逻辑交替执行直到标记阶段完成</p>
<h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><p><a href="http://www.ruanyifeng.com/blog/2017/04/memory-leak.html" target="_blank" rel="external">JavaScript 内存泄漏教程</a></p>
<p><a href="https://bailinlin.github.io/2018/06/08/node-notes/" target="_blank" rel="external">精读《深入浅出Node.js》</a></p>
<p><a href="chrome-extension://ikhdkkncnoglghljlkmcimlnlhkeamad/pdf-viewer/web/viewer.html?file=http%3A%2F%2Fblog.songqingbo.cn%2Fpdf%2Fnodejs%2F%25E6%25B7%25B1%25E5%2585%25A5%25E6%25B5%2585%25E5%2587%25BANode.js.pdf" target="_blank" rel="external">《深入浅出Node.js》PDF</a></p>
<p><a href="https://github.com/bailinlin/Awsome-Front-End-Xmind" target="_blank" rel="external">思维导图下载地址</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2018/06/08/node-notes/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/06/08/node-notes/" itemprop="url">
                  精读《深入浅出Node.js》
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-08T14:04:36+08:00">
                2018-06-08
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2018/06/08/node-notes/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/06/08/node-notes/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>如果你想要深入学习Node，那你不能错过《深入浅出Node.js》这本书，它从不同的视角介绍了 Node 内在的特点和结构。由首章Node 介绍为索引，涉及Node 的各个方面，主要内容包含模块机制的揭示、异步I/O 实现原理的展现、异步编程的探讨、内存控制的介绍、二进制数据Buffer 的细节、Node 中的网络编程基础、Node 中的Web 开发、进程间的消息传递、Node 测试以及通过Node 构建产品需要的注意事项。最后的附录介绍了Node 的安装、调试、编码规范和NPM 仓库等事宜。在读这本书的过程中我收获颇多，并用思维导图的方式记录下来，方便自己后期温故。如果你刚好没有读过，可以当做度这本书的预习阅读，相信你也会有所收获（思维导图图片可能有点小，记得点开看）</p>
<h3 id="第1章-Node简介"><a href="#第1章-Node简介" class="headerlink" title="第1章　Node简介"></a>第1章　Node简介</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/8/163ddf797e5ca946?w=1087&amp;h=694&amp;f=jpeg&amp;s=112844" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/8/163ddf7beac28eea?w=1088&amp;h=445&amp;f=jpeg&amp;s=39820" alt=""></p>
<h3 id="第2章-模块机制"><a href="#第2章-模块机制" class="headerlink" title="第2章　模块机制"></a>第2章　模块机制</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/8/163ddf7f53fdae09?w=1180&amp;h=393&amp;f=jpeg&amp;s=36439" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/8/163ddf823d7036bf?w=1180&amp;h=734&amp;f=jpeg&amp;s=141761" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/8/163ddf850d0a355e?w=1183&amp;h=745&amp;f=jpeg&amp;s=164967" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/8/163ddf8757804e03?w=1180&amp;h=527&amp;f=jpeg&amp;s=80154" alt=""><br>CommonJS提出的规范均十分简单,但是现实意义却十分强大。Node通过模块规范,组织了 自身的原生模块,弥补JavaScript弱结构性的问题,形成了稳定的结构,并向外提供服务。NPM 通过对包规范的支持,有效地组织了第三方模块,这使得项目开发中的依赖问题得到很好的解决, 并有效提供了分享和传播的平台,借助第三方开源力量,使得Node第三方模块的发展速度前所未 有,这对于其他后端JavaScript语言实现而言是从未有过的。从一定的角度上讲,CommonJS规范 帮助Node形成了它的骨骼。只有茁壮的根,才能培养出茂盛的枝叶,并成长为参天大树。正是这 些底层的规范和实践,使得Node有序地发展着,摆脱掉过去JavaScript纷乱和被误解的局面,进 而进化成良性的生态系统。</p>
<h3 id="第3章-异步I-O"><a href="#第3章-异步I-O" class="headerlink" title="第3章　异步I/O"></a>第3章　异步I/O</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/8/163de079a7e88a57?w=1193&amp;h=658&amp;f=jpeg&amp;s=118066" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/8/163ddfd11745edcd?w=1383&amp;h=613&amp;f=jpeg&amp;s=152907" alt=""><br>本章介绍了异步I/O和另一些非I/O的异步方法。可以看出,事件循环是异步实现的核心,它 与浏览器中的执行模型基本保持了一致。而像古老的Rhino,尽管是较早就能在服务器端运行的 JavaScript运行时,但是执行模型并不像浏览器采用事件驱动,而是像其他语言一般采用同步I/O 作为主要模型,这造成它在性能上无所发挥。Node正是依靠构建了一套完善的高性能异步I/O框 架,打破了JavaScript在服务器端止步不前的局面。</p>
          <!--noindex-->
          <div class="post-more-link text-center">
            <a class="btn" href="/2018/06/08/node-notes/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2018/05/28/javascript1/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/05/28/javascript1/" itemprop="url">
                  精读《你不知道的javascript》上卷
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-28T14:04:36+08:00">
                2018-05-28
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2018/05/28/javascript1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/05/28/javascript1/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>《你不知道的 javascript》是一个前端学习必读的系列，让不求甚解的JavaScript开发者迎难而上，深入语言内部，弄清楚JavaScript每一个零部件的用途。本书介绍了该系列的两个主题：“作用域和闭包”以及“this和对象原型”。这两块也是值得我们反复去学习琢磨的两块只是内容，今天我们用思维导图的方式来精读一遍。（思维导图图片可能有点小，记得点开看，你会有所收获）</p>
<h3 id="第一部分-作用域和闭包"><a href="#第一部分-作用域和闭包" class="headerlink" title="第一部分 作用域和闭包"></a>第一部分 作用域和闭包</h3><h4 id="作用域是什么"><a href="#作用域是什么" class="headerlink" title="作用域是什么"></a>作用域是什么</h4><p><img src="https://user-gold-cdn.xitu.io/2018/5/29/163a99495f8829f7?w=1377&amp;h=872&amp;f=jpeg&amp;s=209079" alt=""></p>
<p>作用域是一套规则,用于确定在何处以及如何查找变量(标识符)。如果查找的目的是对 变量进行赋值,那么就会使用 LHS 查询;如果目的是获取变量的值,就会使用 RHS 查询。赋值操作符会导致 LHS 查询。 的赋值操作。 =操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。<br>JavaScript 引擎首先会在代码执行前对其进行编译,在这个过程中,像 var a = 2 这样的声 明会被分解成两个独立的步骤：</p>
<ol>
<li>首先, var a 在其作用域中声明新变量。这会在最开始的阶段,也就是代码执行前进行。</li>
<li>接下来, a = 2 会查询(LHS 查询)变量 a 并对其进行赋值。</li>
</ol>
<p>LHS 和 RHS 查询都会在当前执行作用域中开始,如果有需要(也就是说它们没有找到所 需的标识符),就会向上级作用域继续查找目标标识符,这样每次上升一级作用域(一层 楼),最后抵达全局作用域(顶层),无论找到或没找到都将停止。</p>
<p>不成功的RHS引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式地创建一个全局变量(非严格模式下),该变量使用 LHS 引用的目标作为标识符,或者抛 出 ReferenceError 异常(严格模式下)。</p>
<h4 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h4><p><img src="https://user-gold-cdn.xitu.io/2018/5/29/163a994edf51a32f?w=1105&amp;h=471&amp;f=jpeg&amp;s=50305" alt=""></p>
<p>词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段 基本能够知道全部标识符在哪里以及是如何声明的,从而能够预测在执行过程中如何对它 们进行查找。</p>
<p>JavaScript 中有两个机制可以“欺骗”词法作用域: eval(..) 和 with 。 前者可以对一段包 含一个或多个声明的“代码”字符串进行演算,并借此来修改已经存在的词法作用域(在 运行时)。后者本质上是通过将一个对象的引用 当作 作用域来处理,将对象的属性当作作 用域中的标识符来处理,从而创建了一个新的词法作用域(同样是在运行时)。</p>
<p>这两个机制的副作用是引擎无法在编译时对作用域查找进行优化,因为引擎只能谨慎地认 为这样的优化是无效的。使用这其中任何一个机制都 将 导致代码运行变慢。 不要使用它们。</p>
<h4 id="函数作用域和块作用域"><a href="#函数作用域和块作用域" class="headerlink" title="函数作用域和块作用域"></a>函数作用域和块作用域</h4><p><img src="https://user-gold-cdn.xitu.io/2018/5/29/163a9954593cc366?w=1689&amp;h=828&amp;f=jpeg&amp;s=160928" alt=""></p>
<p>函数是 JavaScript 中最常见的作用域单元。本质上,声明在一个函数内部的变量或函数会 在所处的作用域中“隐藏”起来,这是有意为之的良好软件的设计原则。</p>
<p>但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域, 也可以属于某个代码块(通常指 { .. } 内部)。</p>
<p>从 ES3 开始, try/catch 结构在 catch 分句中具有块作用域。在 ES6 中引入了 let 关键字( var 关键字的表亲), 用来在任意代码块中声明变量。 if(..) { let a = 2; } 会声明一个劫持了 if 的 { .. } 块的变量,并且将变量添加到这个块 中。</p>
<p>有些人认为块作用域不应该完全作为函数作用域的替代方案。两种功能应该同时存在,开 发者可以并且也应该根据需要选择使用何种作用域,创造可读、可维护的优良代码。</p>
<h4 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h4><p><img src="https://user-gold-cdn.xitu.io/2018/5/29/163a995873202ea4?w=1651&amp;h=539&amp;f=jpeg&amp;s=98748" alt=""></p>
<p>我们习惯将 var a = 2; 看作一个声明,而实际上 JavaScript 引擎并不这么认为。它将 var a 和 a = 2 当作两个单独的声明,第一个是编译阶段的任务,而第二个则是执行阶段的任务。</p>
<p>这意味着无论作用域中的声明出现在什么地方,都将在代码本身被执行前 首先 进行处理。 可以将这个过程形象地想象成所有的声明(变量和函数)都会被“移动”到各自作用域的最顶端,这个过程被称为提升。</p>
<p>声明本身会被提升,而包括函数表达式的赋值在内的赋值操作并不会提升。</p>
<p>要注意避免重复声明,特别是当普通的 var 声明和函数声明混合在一起的时候,否则会引 起很多危险的问题!</p>
<h4 id="作用域闭包"><a href="#作用域闭包" class="headerlink" title="作用域闭包"></a>作用域闭包</h4><p><img src="https://user-gold-cdn.xitu.io/2018/5/29/163a995bb92570eb?w=1549&amp;h=731&amp;f=jpeg&amp;s=158866" alt=""></p>
<p>闭包就好像从 JavaScript 中分离出来的一个充满神秘色彩的未开化世界,只有最勇敢的人 才能够到达那里。但实际上它只是一个标准,显然就是关于如何在函数作为值按需传递的 词法环境中书写代码的。</p>
<p>当函数可以记住并访问所在的词法作用域,即使函数是在当前词法作用域之外执行,这时 就产生了闭包。</p>
<p>如果没能认出闭包,也不了解它的工作原理,在使用它的过程中就很容易犯错,比如在循 环中。但同时闭包也是一个非常强大的工具,可以用多种形式来实现 模块 等模式。模块有两个主要特征:</p>
<p>(1)为创建内部作用域而调用了一个包装函数;<br>(2)包装函数的返回 值必须至少包括一个对内部函数的引用,这样就会创建涵盖整个包装函数内部作用域的闭 包。</p>
<p>现在我们会发现代码中到处都有闭包存在,并且我们能够识别闭包然后用它来做一些有用 的事!</p>
<h3 id="第二部分-this-和对象原型"><a href="#第二部分-this-和对象原型" class="headerlink" title="第二部分 this 和对象原型"></a>第二部分 this 和对象原型</h3><h4 id="this-全面解析"><a href="#this-全面解析" class="headerlink" title="this 全面解析"></a>this 全面解析</h4><p><img src="https://user-gold-cdn.xitu.io/2018/5/29/163a996bcbf28e91" alt=""></p>
<p>如果要判断一个运行中函数的 this 绑定,就需要找到这个函数的直接调用位置。找到之后 就可以顺序应用下面这四条规则来判断 this 的绑定对象。</p>
<ol>
<li><p>由 new 调用?绑定到新创建的对象。</p>
</li>
<li><p>由 call 或者 apply (或者 bind )调用?绑定到指定的对象。</p>
</li>
<li><p>由上下文对象调用?绑定到那个上下文对象。</p>
</li>
<li><p>默认:在严格模式下绑定到 undefined ,否则绑定到全局对象。</p>
</li>
</ol>
<p>一定要注意,有些调用可能在无意中使用默认绑定规则。如果想“更安全”地忽略 this 绑 定,你可以使用一个 DMZ 对象,比如 ø = Object.create(null) ,以保护全局对象。ES6中的箭头函数并不会使用四条标准的绑定规则, 而是根据当前的词法作用域来决定 this ,具体来说,箭头函数会继承外层函数调用的 this 绑定(无论 this 绑定到什么)。这 其实和 ES6 之前代码中的 self = this 机制一样。</p>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p><img src="https://user-gold-cdn.xitu.io/2018/6/4/163c85faf904cf73?w=1378&amp;h=708&amp;f=jpeg&amp;s=79898" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/4/163c85fd6750a810?w=1260&amp;h=798&amp;f=jpeg&amp;s=138155" alt=""></p>
<p>JavaScript 中的对象有字面形式(比如 var a = { .. } )和构造形式(比如 var a = new Array(..) )。字面形式更常用,不过有时候构造形式可以提供更多选项。</p>
<p>许多人都以为“JavaScript 中万物都是对象”,这是错误的。对象是 6 个(或者是 7 个,取 决于你的观点)基础类型之一。对象有包括 function 在内的子类型,不同子类型具有不同 的行为,比如内部标签 [object Array] 表示这是对象的子类型数组。</p>
<p>对象就是键 / 值对的集合。可以通过 .propName 或者 [“propName”] 语法来获取属性值。访 问属性时, 引擎实际上会调用内部的默认 [[Get]] 操作(在设置属性值时是 [[Put]] ), [[Get]] 操作会检查对象本身是否包含这个属性,如果没找到的话还会查找 [[Prototype]] 链(参见第 5 章)。</p>
<p>属性的特性可以通过属性描述符来控制,比如 writable 和 configurable 。此外,可以使用 Object.preventExtensions(..) 、 Object.seal(..) 和 Object.freeze(..) 来设置对象(及其 属性)的不可变性级别。</p>
<p>属性不一定包含值——它们可能是具备 getter/setter 的“访问描述符”。此外,属性可以是 可枚举或者不可枚举的,这决定了它们是否会出现在 for..in 循环中。</p>
<p>你可以使用 ES6 的 for..of 语法来遍历数据结构(数组、对象, 等等)中的值, for..of 会寻找内置或者自定义的 @@iterator 对象并调用它的 next() 方法来遍历数据值。</p>
<h4 id="混合对象”类”"><a href="#混合对象”类”" class="headerlink" title="混合对象”类”"></a>混合对象”类”</h4><p><img src="https://user-gold-cdn.xitu.io/2018/5/29/163a9977ad530352?w=1428&amp;h=862&amp;f=jpeg&amp;s=135448" alt=""></p>
<p>类是一种设计模式。 许多语言提供了对于面向类软件设计的原生语法。 JavaScript 也有类 似的语法,但是和其他语言中的类完全不同。</p>
<p>类意味着复制。</p>
<p>传统的类被实例化时,它的行为会被复制到实例中。类被继承时,行为也会被复制到子类 中。</p>
<p>多态(在继承链的不同层次名称相同但是功能不同的函数)看起来似乎是从子类引用父 类,但是本质上引用的其实是复制的结果。</p>
<p>JavaScript 并不会(像类那样)自动创建对象的副本。</p>
<p>混入模式(无论显式还是隐式)可以用来模拟类的复制行为,但是通常会产生丑陋并且脆 弱的语法,比如显式伪多态( OtherObj.methodName.call(this, …) ),这会让代码更加难 懂并且难以维护。</p>
<p>此外, 显式混入实际上无法完全模拟类的复制行为, 因为对象(和函数!别忘了函数也 是对象)只能复制引用, 无法复制被引用的对象或者函数本身。 忽视这一点会导致许多 问题。</p>
<p>总地来说,在 JavaScript 中模拟类是得不偿失的,虽然能解决当前的问题,但是可能会埋下更多的隐患。</p>
<h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><p><img src="https://user-gold-cdn.xitu.io/2018/5/29/163a997b039a7ade?w=1458&amp;h=603&amp;f=jpeg&amp;s=159321" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/29/163a997def15b21f?w=1458&amp;h=781&amp;f=jpeg&amp;s=178700" alt=""></p>
<p>如果要访问对象中并不存在的一个属性, [[Get]] 操作(参见第 3 章)就会查找对象内部 [[Prototype]] 关联的对象。这个关联关系实际上定义了一条“原型链”(有点像嵌套的作用域链),在查找属性时会对它进行遍历。</p>
<p>所有普通对象都有内置的 Object.prototype ,指向原型链的顶端(比如说全局作用域),如 果在原型链中找不到指定的属性就会停止。 toString() 、 valueOf() 和其他一些通用的功能 都存在于 Object.prototype 对象上,因此语言中所有的对象都可以使用它们。</p>
<p>关联两个对象最常用的方法是使用 new 关键词进行函数调用, 在调用的 章)中会创建一个关联其他对象的新对象。4个步骤(第2章)中会创建一个关联其他对象的新对象。</p>
<p>使用 new 调用函数时会把新对象的 .prototype 属性关联到“其他对象”。带 new 的函数调用 通常被称为“构造函数调用”,尽管它们实际上和传统面向类语言中的 类构造函数 不一样。</p>
<p>JavaScript 是 中的机制有一个核心区别, 那就是不会进行复制, 对象之间是通过内部的</p>
<p>虽然这些 机制和传统面向类语言中的“类初始化”和“类继承”很相似, 但是  javascript 机制和传统面向对象类语言中的“类初始化”和“类继承”很相似但是 javascript 中的机制有一个核心区别，就是不会进行复制，对象之间是通过内部的 [[Prototype]] 链关联的。</p>
<p>出于各种原因,以“继承”结尾的术语(包括“原型继承”)和其他面向对象的术语都无 法帮助你理解 JavaScript 的 真实 机制(不仅仅是限制我们的思维模式)。</p>
<p>相比之下,“委托”是一个更合适的术语,因为对象之间的关系不是 复制 而是委托。</p>
<h4 id="行为委托"><a href="#行为委托" class="headerlink" title="行为委托"></a>行为委托</h4><p><img src="https://user-gold-cdn.xitu.io/2018/5/29/163a998194b182d8?w=1754&amp;h=763&amp;f=jpeg&amp;s=132903" alt=""></p>
<p>在软件架构中你可以 选择是否 使用类和继承设计模式。大多数开发者理所当然地认为类是 唯一(合适)的代码组织方式,但是本章中我们看到了另一种更少见但是更强大的设计模式: 行为委托 。</p>
<p>行为委托认为对象之间是兄弟关系, 互相委托, 而不是父类和子类的关系。 JavaScript 的 [[Prototype]] 机制本质上就是行为委托机制。也就是说,我们可以选择在 JavaScript 中努 力实现类机制(参见第 4 和第 5 章),也可以拥抱更自然的 [[Prototype]] 委托机制。</p>
<p>当你只用对象来设计代码时,不仅可以让语法更加简洁,而且可以让代码结构更加清晰。</p>
<p>对象关联(对象之前互相关联)是一种编码风格,它倡导的是直接创建和关联对象,不把 它们抽象成类。对象关联可以用基于 [[Prototype]] 的行为委托非常自然地实现。</p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>思维导图能比较清晰的还原整本书的知识结构体系，如果你还没用看过这本书，可以按照这个思维导图的思路快速预习一遍，提高学习效率。学习新事物总容易遗忘，我比较喜欢在看书的时候用思维导图做些记录，便于自己后期复习，如果你已经看过了这本书，也建议你收藏复习。如果你有神马建议或则想法，欢迎留言或加我微信交流：646321933</p>
<p><a href="https://www.kancloud.cn/kancloud/you-dont-know-js-this-object-prototypes/516674" target="_blank" rel="external">你不知道的javascript上卷第二部分在线文档</a></p>
<p><a href="https://github.com/threerocks/studyFiles/blob/master/js/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%EF%BC%88%E4%B8%8A%E5%8D%B7%EF%BC%89.pdf" target="_blank" rel="external">你不知道的 javascript（上卷）PDF 下载地址</a></p>
<p><a href="https://github.com/bailinlin/Awsome-Front-End-Xmind" target="_blank" rel="external">思维导图下载地址</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2018/05/15/maidian/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/05/15/maidian/" itemprop="url">
                  埋点的实现原理了解一下么
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-15T16:08:20+08:00">
                2018-05-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2018/05/15/maidian/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/05/15/maidian/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>埋点，是网站分析的一种常用的数据采集方法。我们主要用来采集用户行为数据（例如页面访问路径，点击了什么元素）进行数据分析，从而让运营同学更加合理的安排运营计划。现在市面上有很多第三方埋点服务商，百度统计，友盟，growingIO 等大家应该都不太陌生，大多情况下大家都只是使用，最近我研究了下 web 埋点，你要不要了解下。</p>
<h3 id="现有埋点三大类型"><a href="#现有埋点三大类型" class="headerlink" title="现有埋点三大类型"></a>现有埋点三大类型</h3><blockquote>
<p>用户行为分析是一个大系统，一个典型的数据平台。由用户数据采集，用户行为建模分析，可视化报表展示几个模块构成。现有的埋点采集方案可以大致被分为三种，手动埋点，可视化埋点，无埋点</p>
</blockquote>
<ol>
<li>手动埋点<br> 手动代码埋点比较常见，需要调用埋点的业务方在需要采集数据的地方调用埋点的方法。优点是流量可控，业务方可以根据需要在任意地点任意场景进行数据采集，采集信息也完全由业务方来控制。这样的有点也带来了一些弊端，需要业务方来写死方法，如果采集方案变了，业务方也需要重新修改代码，重新发布。</li>
<li>可视化埋点<br> 可是化埋点是近今年的埋点趋势，很多大厂自己的数据埋点部门也都开始做这块。优点是业务方工作量少，缺点则是技术上推广和实现起来有点难（业务方前端代码规范是个大前提）。阿里的活动页很多都是运营通过可视化的界面拖拽配置实现，这些活动控件元素都带有唯一标识。通过埋点配置后台，将元素与要采集事件关联起来，可以自动生成埋点代码嵌入到页面中。</li>
<li>无埋点<br> 无埋点则是前端自动采集全部事件，上报埋点数据，由后端来过滤和计算出有用的数据，优点是前端只要加载埋点脚本。缺点是流量和采集的数据过于庞大，服务器性能压力山大，主流的 GrowingIO 就是这种实现方案。</li>
</ol>
<p>我们暂时放弃可视化埋点的实现，在 <code>手动埋点</code> 和 <code>无埋点</code> 上进行了尝试，为了便于描述，下文我会称采集脚本为 SDK。</p>
<h3 id="思考几个问题"><a href="#思考几个问题" class="headerlink" title="思考几个问题"></a>思考几个问题</h3><blockquote>
<p>埋点开发需要考虑很多内容，贯穿着不轻易动手写代码的原则，我们在开发前先思考下面这几个问题</p>
</blockquote>
<ol>
<li>我们要采集什么内容，进行哪些采集接口的约定</li>
<li>业务方通过什么方式来调用我们的采集脚本</li>
<li>手动埋点：SDK 需要封装一个方法给业务方进行调用，传参方式业务方可控</li>
<li>无埋点：考虑到数据量对于服务器的压力，我们需要对无埋点进行开关配置，可以配置进行哪些元素进行无埋点采集</li>
<li>用户标识：游客用户和登录用户的采集数据怎么进行区分关联</li>
<li>设备Id：用户通过浏览器来访问 web 页面，设备Id需要存储在浏览器上，同一个用户访问不同的业务方网站，设备Id要保持一样，怎么实现</li>
<li>单页面应用：现在流行的单页面应用和普通 web 页面的数据采集是否有差异</li>
<li>混合应用：app 与 h5 的混合应用我们要怎么进行通讯</li>
</ol>
<h4 id="我们要采集什么内容，进行哪些采集接口的约定"><a href="#我们要采集什么内容，进行哪些采集接口的约定" class="headerlink" title="我们要采集什么内容，进行哪些采集接口的约定"></a>我们要采集什么内容，进行哪些采集接口的约定</h4><p>第一期我们先实现对 PV（即页面浏览量或点击量） 、UV（一天内同个访客多次访问） 、点击量、用户的访问路径的基础指标的采集。精细化分析的流量转化需要和业务相关，需要和数据分析方做约定，我们预留扩展。所以我们的采集接口需要进行以下的约定</p>
<pre>

    {
        "header":{ // HTTP 头部
            "X-Device-Id":" 550e8400-e29b-41d4-a716-446655440000", //设备ID，用来区分用户设备
            "X-Source-Url":"https://www.baidu.com/", //源地址，关联用户的整个操作流程，用于用户行为路径分析，例如登录，到首页，进入商品详情，退出这一整个完整的路径
            "X-Current-Url":"", //当前地址，用户行为发生的页面
            "X-User-Id":"",//用户ID，统计登录用户行为
        },
        "body":[{ // HTTP Body体
            "PageSessionID":"", //页面标识ID，用来区分页面事件，例如加载和离开我们会发两个事件，这个标识可以让我们知道这个事件是发生在一个页面上
            "Event":"loaded", //事件类型，区分用户行为事件
            "PageTitle":  "埋点测试页",  //页面标题，直观看到用户访问页面
            "CurrentTime":  “1517798922201”,  //事件发生的时间
            "ExtraInfo":  {
             }    //扩展字段，对具体业务分析的传参
        }]
    }

</pre>

<p>以上就是我们现在约定好了的通用的事件采集的接口，所传的参数基本上会根据采集事件的不同而发生变化。但是在用户的整一个访问行为中，用户的设备是不会变化的，如果你想采集设备信息可以重新约定一个接口，在整个采集开始之前发送设备信息，这样可以避免在事件采集接口上重复采集固定数据。</p>
<pre>

    {
        "header":{ // HTTP 头部
              "X-Device-Id"  ："550e8400-e29b-41d4-a716-446655440000"  ,      //  设备id
        },
        "body":{ // HTTP Body体
                  "DeviceType":  "web" ,   //设备类型
                 "ScreenWide"  :  768 , //  屏幕宽
                 "ScreenHigh":  1366 , //  屏幕高
                 "Language":    "zh-cn"  //语言
        }
    }

</pre>

<h4 id="业务方通过什么方式来调用我们的采集脚本"><a href="#业务方通过什么方式来调用我们的采集脚本" class="headerlink" title="业务方通过什么方式来调用我们的采集脚本"></a>业务方通过什么方式来调用我们的采集脚本</h4><p>埋点应该让调用的业务方，尽可能少有工作量，最好是什么都不用做，😁，但是实现起来有点难额。我们采用的方案是让业务方在代码里通过 script 脚本来引用我们的 SDK ，业务方只要配置一些需要的参数进行埋点定制（👆我们讲到过的无埋点的流量控制），然后什么都不做就可以进行基础数据的采集。</p>
<pre>

    (function() {
                var collect = document.createElement('script');
                collect.type = 'text/javascript';
                collect.async = true;
                collect.src =  'http://collect.trc.com/index.js';
                var s = document.getElementsByTagName('script')[0];
                s.parentNode.insertBefore(collect, s);
        })();


    //用户自定义要进行无埋点采集的元素，如果不进行无埋点采集，可以不配置
     var _XT = [];
      _XT.push(['Target','div']);

</pre>

<h4 id="手动埋点：SDK"><a href="#手动埋点：SDK" class="headerlink" title="手动埋点：SDK"></a>手动埋点：SDK</h4><p>如果业务方需要采集更多业务定制的数据，可以调用我们暴露出的方法进行采集</p>
<pre>

    //自定义事件
      sdk.dispatch('customEvent',{extraInfo:'自定义事件的额外信息'})

</pre>

<h4 id="游客与用户关联"><a href="#游客与用户关联" class="headerlink" title="游客与用户关联"></a>游客与用户关联</h4><p>我们使用 userId 来做用户标识，同一个设备的用户，从游客用户切换到登录用户，如果我们要把他们关联起来，需要有一个设备Id 做关联</p>
<h4 id="web-设备Id"><a href="#web-设备Id" class="headerlink" title="web 设备Id"></a>web 设备Id</h4><p>用户通过浏览器来访问 web 页面，设备Id需要存储在浏览器上，同一个用户访问不同的业务方网站，设备Id要保持一样。web 变量存储，我们第一时间想到的就是 cookie，sessionStorage，localStorage，但是这3种存储方式都和访问资源的域名相关。我们总不能每次访问一个网站就新建一个设备指纹吧，所以我们需要通过一个方法来跨域共享设备指纹</p>
<p>我们想到的方案是，通过嵌套 iframe 加载一个静态页面，在 iframe 上加载的域名上存储设备id，通过跨域共享变量获取设备id，共享变量的原理是采用了iframe 的 contentWindow通讯，通过 postMessage 获取事件状态，调用封装好的回调函数进行数据处理具体的实现方式</p>
<pre>

    //web 应用，通过嵌入 iframe 进行跨域 cookie 通讯，设置设备id,
        collect.setIframe = function () {
            var that = this
            var iframe = document.createElement('iframe')
            iframe.id = "frame",
            iframe.src = 'http://collectiframe.trc.com' // 配置域名代理，目的是让开发测试生产环境代码一致
            iframe.style.display='none' //iframe 设置的目的是用来生成固定的设备id，不展示
            document.body.appendChild(iframe)

            iframe.onload = function () {
                    iframe.contentWindow.postMessage('loaded','*');
            }

            //监听message事件，iframe 加载完成，获取设备id ，进行相关的数据采集
            helper.on(window,"message",function(event){
                that.deviceId = event.data.deviceId

                if(event.data && event.data.type == 'loaded'){
                    that.sendDevice(that.getDevice(), that.deviceUrl);
                    setTimeout(function () {
                        that.send(that.beforeload)
                        that.send(that.loaded)
                    },1000)
                }
            })
        }

</pre>

<p>iframe 与 SDK 通讯</p>
<pre>

    function receiveMessageFromIndex ( event ) {
        getDeviceInfo() // 获取设备信息
        var data =  {
                deviceId: _deviceId,
                type:event.data
        }

        event.source.postMessage(data, '*'); // 将设备信息发送给 SDK
    }

    //监听message事件
    if(window.addEventListener){
            window.addEventListener("message", receiveMessageFromIndex, false);
    }else{
            window.attachEvent("onmessage", receiveMessageFromIndex, false)

</pre>

<p>如果你想知道可以看我的另一篇博客 <a href="https://bailinlin.github.io/2018/03/05/cookie-share/" target="_blank" rel="external">web 浏览器指纹跨域共享</a></p>
<h4 id="单页面应用：现在流行的单页面应用和普通-web-页面的数据采集是否有差异"><a href="#单页面应用：现在流行的单页面应用和普通-web-页面的数据采集是否有差异" class="headerlink" title="单页面应用：现在流行的单页面应用和普通 web 页面的数据采集是否有差异"></a>单页面应用：现在流行的单页面应用和普通 web 页面的数据采集是否有差异</h4><blockquote>
<p>我们知道单页面应用都是无刷新的页面加载，所以我们在页面<code>跳转</code>的处理和我们的普通的页面会有所不同。单页面应用的路由插件运用了 window 自带的无刷新修改用户浏览记录的方法，pushState 和 replaceState。</p>
</blockquote>
<p>window 的 history 对象 提供了两个方法，能够无刷新的修改用户的浏览记录，pushSate，和 replaceState，区别的 pushState 在用户访问页面后面添加一个访问记录， replaceState 则是直接替换了当前访问记录，所以我们只要改写 history 的方法，在方法执行前执行我们的采集方法就能实现对单页面应用的页面跳转事件的采集了</p>
<pre>

     // 改写思路：拷贝 window 默认的 replaceState 函数，重写 history.replaceState 在方法里插入我们的采集行为，在重写的 replaceState 方法最后调用，window 默认的 replaceState 方法

        collect = {}
        collect.onPushStateCallback : function(){}  // 自定义的采集方法

        (function(history){
            var replaceState = history.replaceState;   // 存储原生 replaceState
            history.replaceState = function(state, param) {     // 改写 replaceState
               var url = arguments[2];
               if (typeof collect.onPushStateCallback == "function") {
                     collect.onPushStateCallback({state: state, param: param, url: url});   //自定义的采集行为方法
               }
               return replaceState.apply(history, arguments);    // 调用原生的 replaceState
            };
         })(window.history);

</pre>


<p>这块介绍起来也比较的复杂，如果你想了解更多，可以看我的另一篇博客<a href="https://bailinlin.github.io/2018/04/28/history/" target="_blank" rel="external">你需要知道的单页面路由实现原理</a></p>
<h4 id="混合应用：app-与-h5-的混合应用我们要怎么进行通讯"><a href="#混合应用：app-与-h5-的混合应用我们要怎么进行通讯" class="headerlink" title="混合应用：app 与 h5 的混合应用我们要怎么进行通讯"></a>混合应用：app 与 h5 的混合应用我们要怎么进行通讯</h4><blockquote>
<p>现在大部分的应用都不是纯原生的应用， app 与 h5 的混合的应用是现在的一种主流。</p>
</blockquote>
<p>纯 web 数据采集我们考虑到前端存储数据容易丢失，我们在每一次事件触发的时候都用采集接口传输采集到的数据。考虑到现在很多用户的手机会有流量管家的软件监控，如果在 App 中 h5 还是采集到数据就传输给服务端，很有可能会让流量管家检测到，给用户报警，从而使得用户不再信任你的 App , 所以我们在用户操作的时候将数据传给 app 端，存储到 app。用户切换应用到后台的时候，通过 app 端的 SDK 打包传输到服务器，我们给 app 提供的方法封装了一个适配器</p>
<pre>

    // app 与 h5 混合应用，直接将数信息发给 app
    collect.saveEvent = function (jsonString) {

        collect.dcpDeviceType && setTimeout(function () {
            if(collect.dcpDeviceType=='android'){
                android.saveEvent(jsonString)
            } else {
                window.webkit && window.webkit.messageHandlers ? window.webkit.messageHandlers.nativeBridge.postMessage(jsonString) : window.postBridgeMessage(jsonString)
            }

        },1000)
        }

</pre>

<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><blockquote>
<p>通过上面几个问题的思考，我们对埋点的实现大致已经有了一些想法，我们使用思维导图来还原下我们即将要做的事情，图片记得放大看哦，太小了可能看不清。</p>
</blockquote>
<ol>
<li>我们需要暴露给业务方调用的方法<br><img src="/images/sdk/method.jpeg" alt="nginx作用域"></li>
<li>我们需要处理的事件类型<br><img src="/images/sdk/event.jpeg" alt="nginx作用域"></li>
<li>SDK 的基本实现思路<br><img src="/images/sdk/logic.jpeg" alt="nginx作用域"></li>
</ol>
<h3 id="我们来看下几个核心代码的实现"><a href="#我们来看下几个核心代码的实现" class="headerlink" title="我们来看下几个核心代码的实现"></a>我们来看下几个核心代码的实现</h3><h4 id="工具方法"><a href="#工具方法" class="headerlink" title="工具方法"></a>工具方法</h4><p>我们定义了几个工具方法，提高开发的幸福指数 😝</p>
<pre>

        var helper = {};

        // 生成一个唯一的标识，pageSessionId （用这个变量来关联开始加载、加载完成、离开页面的事件，计算出页面加菜时间，停留时间）
        helper.uuid = function(){}

        // 元素绑定事件监听，兼容浏览器到IE8
        helper.on = function(){}

        //元素移除事件监听的适配器函数，兼容浏览器到IE8
        helper.remove = function(){}

        //将json转为字符串,事件传输的参数类型转化
        helper.changeJSON2Query = function(){}

        //将相对路径解析成文档全路径
        helper.normalize = function(){}
</pre>

<h4 id="采集逻辑"><a href="#采集逻辑" class="headerlink" title="采集逻辑"></a>采集逻辑</h4><pre>

        var collect = {
            deviceUrl:'http://collect.trc.com/rest/collect/device/h5/v1',
            eventUrl:'http://collect.trc.com/rest/collect/event/h5/v1',
            isuploadUrl:'http://collect.trc.com/rest/collect/isupload/app/v1',
            parmas:{ ExtraInfo:{} },
            device:{}
        };

        //获取埋点配置
        collect.setParames = function(){}

        //更新访问路径及页面信息
        collect.updatePageInfo = function(){}

        //获取事件参数
        collect.getParames = function(){}

        //获取设备信息
        collect.getDevice = function(){}

        //事件采集
        collect.send = function(){}

        //设备采集
        collect.sendDevice = function(){}

        //判断才否采集，埋点采集的开关
        collect.isupload = function(){

            1. 判断是否采集，不采集就注销事件监听（项目中区分游客身份和用户身份的采集情况，这个方法会被判断两次）
            2. 采集则判断是否已经采集过
                a.已经采集过不做任何操作
                b.没有采集过添加事件监听
            3. 判断是 混合应用还是纯 web 应用
                a.如果是web 应用，调用 collect.setIframe 设置 iframe
                b.如果是混合应用 将开始加载和加载完成事件传输给 app
        }

        //点击事件处理函数
        collect.clickHandler = function(){}

        //离开页面的事件处理函数
        collect.beforeUnloadHandler = function(){}

        //页面回退事件处理函数
        collect.onPopStateHandler = function(){}

        //系统事件初始化，注册离开事件，浏览器后退事件
        collect.event = function(){}

        //获取记录开始加载数据信息
        collect.getBeforeload = function(){}

        //存储加载完成，获取设备类型，记录加载完成信息
        collect.onload = function(){

            1. 判断cookie是否有存设备类型信息，有表示混合应用
            2. 采集加载完成时间等信息
            3. 调用 collect.isupload 判断是否进行采集
        }

        //web 应用，通过嵌入 iframe 进行跨域 cookie 通讯，设置设备id
        collect.setIframe = function(){}

        //app 与 h5 混合应用，直接将数信息发给 app,判断设备类型做原生方法适配器
        collect.saveEvent = function(){}

        //采集自定义事件类型
        collect.dispatch = function(){}

        //将参数 userId 存入sessionStorage
        collect.storeUserId = function(){}

        //采集H5信息,如果是混合应用，将采集到的信息发送给 app 端
        collect.saveEventInfo = function(){}

        //页面初始化调用方法
        collect.init = function(){

            1. 获取开始加载的采集信息
            2. 获取 SDK 配置信息，设备信息
            3. 改写 history 两个方法，单页面应用页面跳转前调用我们自己的方法
            4. 页面加载完成，调用 collect.onload 方法

        }


        collect.init(); // 初始化

        //暴露给业务方调用的方法
        return {
            dispatch:collect.dispatch,
            storeUserId:collect.storeUserId,
        }
</pre>


<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><blockquote>
<p>代码的篇幅比较长，就不放在博客里了，感兴趣的同学可以在 <a href="https://github.com/bailinlin/web-sdk" target="_blank" rel="external">github</a> 上看完整的项目。如果你有什么不懂的或者想和我交流的，欢迎在文章下面留言联系我</p>
</blockquote>
<p><a href="https://bailinlin.github.io/2018/03/05/cookie-share/" target="_blank" rel="external">web 浏览器指纹跨域共享</a><br><a href="https://bailinlin.github.io/2018/04/28/history/" target="_blank" rel="external">你需要知道的单页面路由实现原理</a></p>
<p><a href="https://www.zhihu.com/question/36411025" target="_blank" rel="external">数据埋点是什么？设置埋点的意义是什么？</a><br><a href="https://sensorsdata.cn/blog/shu-ju-jie-ru-yu-mai-dian/" target="_blank" rel="external">数据采集与埋点</a><br><a href="https://tech.meituan.com/mt-mobile-analytics-practice.html" target="_blank" rel="external">美团点评前端无痕埋点实践</a><br><a href="https://www.zhihu.com/question/20448467" target="_blank" rel="external">如何清楚易懂的解释“UV和PV＂的定义</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2018/05/07/vue-cli-webpack/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/05/07/vue-cli-webpack/" itemprop="url">
                  vue-cli#4.7项目结构分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-07T14:11:04+08:00">
                2018-05-07
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2018/05/07/vue-cli-webpack/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/05/07/vue-cli-webpack/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>使用过 vue 进行项目开发的同学，一定知道或者使用过 vue-cli 脚手架，他能够很好的搭建项目结构和工程，让我们能够把足够的精力放在业务开发上。也正是因为这样，很多时候我们会因为项目工期短等原因来不及或则不会刻意去了解项目工程配置，我们今天不去介绍脚手架的使用，我们去了解下脚手架为我们创建好的打包工程是怎么做的。</p>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p><code></code></p>
<pre><code>├── build --------------------------------- webpack相关配置文件
│   ├── build.js --------------------------webpack打包配置文件
│   ├── check-versions.js ------------------------------ 检查npm,nodejs版本
│   ├── logo.png ---------------------------------- 项目 logo
│   ├── utils.js --------------------------------------- 配置资源路径，配置css加载器
│   ├── vue-loader.conf.js ----------------------------- 配置css加载器等
│   ├── webpack.base.conf.js --------------------------- webpack基本配置
│   ├── webpack.dev.conf.js ---------------------------- 用于开发的webpack设置
│   ├── webpack.prod.conf.js --------------------------- 用于打包的webpack设置
├── config ---------------------------------- 配置文件
       ├── index.js ------------------------------ 开发和生产环境配置文件
├── node_modules ---------------------------- 存放依赖的目录
├── src ------------------------------------- 源码
│   ├── assets ------------------------------ 静态文件
│   ├── components -------------------------- 组件
│   ├── main.js ----------------------------- 主js
│   ├── App.vue ----------------------------- 项目入口组件
│   ├── router ------------------------------ 路由
├── package.json ---------------------------- node配置文件
├── .babelrc--------------------------------- babel配置文件
├── .editorconfig---------------------------- 编辑器配置
├── .gitignore------------------------------- 配置git可忽略的文件
</code></pre><p></p>
<h3 id="webpack配置划重点"><a href="#webpack配置划重点" class="headerlink" title="webpack配置划重点"></a>webpack配置划重点</h3><blockquote>
<p>在看项目配置文件之前，我们先了解下 webpack 几个常用的工具和插件，如果你已经十分熟悉，你可以跳过这一小节，直接去看，配置文件解析</p>
</blockquote>
<h4 id="1-path模块"><a href="#1-path模块" class="headerlink" title="1. path模块"></a>1. path模块</h4><p>path 是 node.js 中的一个模块，用于处理目录的对象，提高开发效</p>
<pre>

    常用方法：
    path.join(): 用于连接路径。该方法的主要用途在于，会正确使用当前系统的路径分隔符，Unix 系统是 ”/“，Windows系统是 ”\“
    path.resolve() 用于将相对路径转为绝对路径

    常使用的文件路径
    __dirname: 总是返回被执行的 js 所在文件夹的绝对路径
    __filename: 总是返回被执行的 js 的绝对路径
    process.cwd(): 总是返回运行 node 命令时所在的文件夹的绝对路径

</pre>

<h4 id="2-process"><a href="#2-process" class="headerlink" title="2.process"></a>2.process</h4><p>process对象是Node的一个全局对象，提供当前Node进程的信息。</p>
<pre>

    process 对象提供一系列属性，用于返回系统信息
    process.argv：返回当前进程的命令行参数数组。
    process.env：返回一个对象，成员为当前Shell的环境变量，比如process.env.HOME
    process.pid：当前进程的进程号

</pre>

<h4 id="3-Source-map"><a href="#3-Source-map" class="headerlink" title="3.Source map"></a>3.Source map</h4><p>简单说，<a href="http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html" target="_blank" rel="external">Source map</a>就是一个信息文件，里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。有了它，出错的时候，debug 工具将直接显示原始代码，而不是转换后的代码。这无疑给开发者带来了很大方便。<a href="https://juejin.im/post/58293502a0bb9f005767ba2f" target="_blank" rel="external">webpack 的 devtool里有 7种 SourceMap 模式</a></p>
<table>
<thead>
<tr>
<th>模式</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>eval</td>
<td>每个 module 会封装到 eval 里包裹起来执行，并且会在末尾追加注释 //@ sourceURL</td>
</tr>
<tr>
<td>source-map</td>
<td>生成一个 SourceMap 文件.</td>
</tr>
<tr>
<td>hidden-source-map</td>
<td>和 source-map 一样，但不会在 bundle 末尾追加注释.</td>
</tr>
<tr>
<td>inline-source-map</td>
<td>生成一个 DataUrl 形式的 SourceMap 文件.</td>
</tr>
<tr>
<td>eval-source-map</td>
<td>每个 module 会通过 eval() 来执行，并且生成一个 DataUrl 形式的 SourceMap .</td>
</tr>
<tr>
<td>cheap-source-map</td>
<td>生成一个没有列信息（column-mappings）的 SourceMaps 文件，不包含 loader 的 sourcemap（譬如 babel 的 sourcemap）</td>
</tr>
<tr>
<td>cheap-module-source-map</td>
<td>生成一个没有列信息（column-mappings）的 SourceMaps 文件，同时 loader 的 sourcemap 也被简化为只包含对应行的。</td>
</tr>
</tbody>
</table>
<h4 id="4-webpack-merge"><a href="#4-webpack-merge" class="headerlink" title="4. webpack-merge"></a>4. webpack-merge</h4><p>开发环境(development)和生产环境(production)的构建目标差异很大。在开发环境中，我们需要具有强大的、具有实时重新加载(live reloading)或热模块替换(hot module replacement)能力的 source map 和 localhost server。而在生产环境中，我们的目标则转向于关注更小的 bundle，更轻量的 source map，以及更优化的资源，以改善加载时间。由于要遵循逻辑分离，我们通常建议为每个环境编写彼此独立的 webpack 配置。通用的配置部分，我们抽象出一个公共文件，通过 <a href="https://doc.webpack-china.org/guides/production/" target="_blank" rel="external">webpack-merge</a> 工具的“通用”配置，我们不必在环境特定的配置中重复代码。</p>
<h4 id="5-ExtractTextWebpackPlugin"><a href="#5-ExtractTextWebpackPlugin" class="headerlink" title="5. ExtractTextWebpackPlugin"></a>5. ExtractTextWebpackPlugin</h4><p><a href="https://doc.webpack-china.org/plugins/extract-text-webpack-plugin/" target="_blank" rel="external">ExtractTextWebpackPlugin</a> 插件通常用来做样式文件的分离，被分离的文件不会被内嵌到  JS bundle 中，而会被放到一个单独的文件中，在样式文件比较大的时候，能够提前样式的加载,配置示例如下</p>
<pre>

    const ExtractTextPlugin = require("extract-text-webpack-plugin");
    module.exports = {
       module: {
          rules: [
          {
             test: /\.css$/,
             use: ExtractTextPlugin.extract({
             fallback: "style-loader",
             use: "css-loader"
          })
       }]
    },
        plugins: [
            new ExtractTextPlugin("styles.css"),
        ]
    }

</pre>

<p>它会将所有的入口 chunk(entry chunks)中引用的 *.css，移动到独立分离的 CSS 文件。因此，你的样式将不再内嵌到 JS bundle 中，而是会放到一个单独的 CSS 文件（即 styles.css）当中。 如果你的样式文件大小较大，这会做更快提前加载，因为 CSS bundle 会跟 JS bundle 并行加载。</p>
<h4 id="6-html-webpack-plugin"><a href="#6-html-webpack-plugin" class="headerlink" title="6.html-webpack-plugin"></a>6.html-webpack-plugin</h4><p>如果你有多个 webpack 入口点， 他们都会在生成的HTML文件中的 script 标签内。如果你有任何 CSS assets 在 webpack 的输出中（例如， 利用ExtractTextPlugin提取CSS）， 那么这些将被包含在HTML head中的<link>标签内。通常在开发中，我们为了避免 CDN 和浏览器的缓存通常会个输出文件 bundle.js 加上一个hash 值例如 <code>[hash].bundle.js</code>，使用 <a href="https://doc.webpack-china.org/plugins/html-webpack-plugin/" target="_blank" rel="external">html-webpack-plugin</a> 能够在创建新的 html 文件的时候将我们把带有哈希值的 bundle.js 引用到 html 文件.</p>
<h4 id="7-optimize-css-assets-webpack-plugin"><a href="#7-optimize-css-assets-webpack-plugin" class="headerlink" title="7.optimize-css-assets-webpack-plugin"></a>7.optimize-css-assets-webpack-plugin</h4><p>用来优化从脚本里提炼出来的 css ，配置示例如下</p>
<pre>

    var OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin');
    module.exports = {
      module: {
        rules: [
          {
            test: /\.css$/,
            loader: ExtractTextPlugin.extract('style-loader', 'css-loader')
          }
        ]
      },
      plugins: [
        new ExtractTextPlugin('styles.css'),
        new OptimizeCssAssetsPlugin({
          assetNameRegExp: /\.optimize\.css$/g,
          cssProcessor: require('cssnano'),
          cssProcessorOptions: { discardComments: { removeAll: true } },
          canPrint: true
        })
      ]
    };
</pre>

<h4 id="8-CopyWebpackPlugin"><a href="#8-CopyWebpackPlugin" class="headerlink" title="8.CopyWebpackPlugin"></a>8.CopyWebpackPlugin</h4><p><a href="https://doc.webpack-china.org/plugins/copy-webpack-plugin/" target="_blank" rel="external">CopyWebpackPlugin</a>从插件名称上我们不难看出他的作用，通常用来拷贝资源，对项目文件进行归类整合</p>
<h4 id="9-friendly-errors-webpack-plugin"><a href="#9-friendly-errors-webpack-plugin" class="headerlink" title="9.friendly-errors-webpack-plugin"></a>9.friendly-errors-webpack-plugin</h4><p><a href="https://www.npmjs.com/package/friendly-errors-webpack-plugin" target="_blank" rel="external">friendly-errors-webpack-plugin</a>能够更好在终端看到webapck运行的警告和错误，提高开发体验</p>
<h4 id="10-UglifyjsWebpackPlugin"><a href="#10-UglifyjsWebpackPlugin" class="headerlink" title="10.UglifyjsWebpackPlugin"></a>10.UglifyjsWebpackPlugin</h4><p><a href="https://doc.webpack-china.org/plugins/uglifyjs-webpack-plugin/" target="_blank" rel="external">UglifyjsWebpackPlugin</a>用来压缩 js 代码</p>
<h4 id="11-开发中-Server-DevServer"><a href="#11-开发中-Server-DevServer" class="headerlink" title="11.开发中 Server(DevServer)"></a>11.开发中 Server(DevServer)</h4><p>webpack 项目服务，我们通常会在开发阶段用来配置项目的热刷新，服务压缩，项目代理等，常用的几个配置参数介绍如下</p>
<pre>

    const config = require('../config')

    // config 文件里做了用户自定的服务参数配置

    devServer: {
        clientLogLevel: 'warning',  // 在开发攻击的控制台中显示信息，便于开发调试，你可以将参数配置成 "none" 来进行关闭
         historyApiFallback: { // 当使用 HTML5 History API 时，任意的 404 响应都可能需要被替代为 index.html
            rewrites: [
               { from: /.*/, to: path.posix.join(config.dev.assetsPublicPath, 'index.html') },
            ],
         },
         hot: true,   //启用项目的热刷新，即模块热替换特性
         contentBase: false,   // 告诉服务器从哪里提供内容。只有在你想要提供静态文件时才需要。这里禁用，因为配置了 CopyWebpackPlugin 的使用
         compress: true,
         host: HOST || config.dev.host,   //指定使用一个域名。默认是 localhost
         port: PORT || config.dev.port,   //指定要监听请求的端口号：
         open: config.dev.autoOpenBrowser, //open 参数配置，如果配置成 true ，项目启动后会自动打开浏览器
         overlay: config.dev.errorOverlay   //当有错误或则警告的时候在页面上显示一个全屏的遮罩提示
             ? { warnings: false, errors: true }
             : false,
         publicPath: config.dev.assetsPublicPath, //此路径下的打包文件可在浏览器中访问
         proxy: config.dev.proxyTable,           //代理API的请求
         quiet: true,       //启用 quiet 后，除了初始启动信息之外的任何内容都不会被打印到控制台,特别是使用了 FriendlyErrorsPlugin 插件的时候
         watchOptions: {   //与监视文件相关的控制选项。是否使用轮询
               poll: config.dev.poll,
         }
    },

</pre>


<h3 id="配置文件解析"><a href="#配置文件解析" class="headerlink" title="配置文件解析"></a>配置文件解析</h3><blockquote>
<p>通过了解了上面的配置，我们应该对 webpack 的常用插件和工具有了一定了解，我们来看下 vue-cli 脚手架给我们生成的配置情况</p>
</blockquote>
<h4 id="config-js"><a href="#config-js" class="headerlink" title="config.js"></a>config.js</h4><pre>

'use strict'

const path = require('path') // 引用项目的 path 模块

module.exports = {
  dev: {

    // 路径配置
    assetsSubDirectory: 'static',
    assetsPublicPath: '/',
    proxyTable: {},

    // 各种开发服务配置
    host: 'localhost', // 开发环境域名 可以被 node 全局变量process.env.HOST 重写
    port: 8080, //配置开发服务端口，可以被 node 全局变量 process.env.PORT 重写, 需要使用未被占用的端口
    autoOpenBrowser: false, //服务启动是否自动代开浏览器
    errorOverlay: true,   //是否在发生错误的时候，在页面整屏增加一个错误遮罩
    notifyOnErrors: true,  //是否通知错误 ，在我们的项目配置中和 friendly-errors-webpack-plugin 结合使用
    poll: false, // 服务监听是否轮询操作

    // 配饰是否使用 Eslint Loader 进行语法检测
    // 如果使用，在开发构建阶段，会对你的代码会进行检测
    // 检测出来的警告和错误会白展示在开发工具的控制台

    useEslint: true,  //进行语法检测

    // 配置是否将 eslint 语法检测的警告和错误展示在页面整屏的遮罩上

    showEslintErrorsInOverlay: false,  // 语法检测的警告和错误不展示在遮罩上

    /**
     * Source Maps
     */

    // https://webpack.js.org/configuration/devtool/#development
    // 在上面的介绍中，我们知道 source map 是用来将我们构建后被转化的代码对应构建前的代码，便于 debug
    // cheap-module-eval-source-map 和我们介绍的 cheap-module-source-map 很类似，但是 SourceMap 会被作为数据添加到包中
    devtool: 'cheap-module-eval-source-map',

    // 如果你的开发工具不能进行 vue-files 的 debug ，可以将以下设置设置成 false

    cacheBusting: true,

    cssSourceMap: true
  },

  build: {
    // index.html 文件模板
    index: path.resolve(__dirname, '../dist/index.html'),

    // 打包路径配置
    assetsRoot: path.resolve(__dirname, '../dist'),
    assetsSubDirectory: 'static',
    assetsPublicPath: '/',

    /**
     * Source Maps
     */

    //生产环境 source map 配置

    productionSourceMap: true,
    devtool: '#source-map',

    // 因为很多的主流服务都会 通过 gzip 压缩过你的所有静态资源，我们的配置默认不开启 gzip
    // 如果要设置成开启,请先确保已经安装好 compression-webpack-plugin 插件
    productionGzip: false,
    productionGzipExtensions: ['js', 'css'],

    // 启动 build 命令的时候，额外添加一个参数，打包后会自动生成一个分析报告文件，例如 npm run build --report ，可以通过配置 true ，false 来关闭
    bundleAnalyzerReport: process.env.npm_config_report
  }
}

</pre>

<h4 id="check-versions-js"><a href="#check-versions-js" class="headerlink" title="check-versions.js"></a>check-versions.js</h4><p>这个文件主要是用来检测当前环境中的node和npm版本和我们需要的是否一致的。</p>
<pre>

    'use strict'
    const chalk = require('chalk')  // 改变命令行中的字体颜色，大致这样用chalk.blue('Hello world')
    const semver = require('semver')  //是用来对特定的版本号做判断的

    const packageConfig = require('../package.json')  // 项目 npm 配置文件，获取依赖及版本信息，requrie返回的就是json对象
    const shell = require('shelljs') //用来执行Unix系统命令，调用系统命令更加方便

    //把cmd这个参数传递的值转化成前后没有空格的字符串，也就是版本号
    function exec (cmd) {
      return require('child_process').execSync(cmd).toString().trim()
    }


    const versionRequirements = [
      {
        name: 'node',
        currentVersion: semver.clean(process.version),  // 提取进程版本信息转化成规定格式，也就是 '  =v1.2.3  ' -> '1.2.3' 这种功能
        versionRequirement: packageConfig.engines.node // package.json 的 node 的版本信息
      }
    ]

    if (shell.which('npm')) {
      versionRequirements.push({
        name: 'npm',
        currentVersion: exec('npm --version'),   //当前的版本信息
        versionRequirement: packageConfig.engines.npm //package.json 的 node 的版本信息
      })
    }

    module.exports = function () {
      const warnings = []

      for (let i = 0; i < versionRequirements.length; i++) {
        const mod = versionRequirements[i]

        // 如果当前版本号不符合 package.json 要求的版本号，红色表示当前版本信息，绿色表示要求的版本信息，添加到 warnings 待输出
        if (!semver.satisfies(mod.currentVersion, mod.versionRequirement)) {
          warnings.push(mod.name + ': ' +
            chalk.red(mod.currentVersion) + ' should be ' +
            chalk.green(mod.versionRequirement)
          )
        }
      }

      //输出版本号不相符的提示 warnings
      if (warnings.length) {
        console.log('')
        console.log(chalk.yellow('To use this template, you must update following to modules:'))
        console.log()

        for (let i = 0; i < warnings.length; i++) {
          const warning = warnings[i]
          console.log('  ' + warning)
        }

        console.log()
        process.exit(1)
      }
    }


</pre>

<h4 id="build-js"><a href="#build-js" class="headerlink" title="build.js"></a>build.js</h4><pre>

    'use strict'

    //打包前判断当先开发环境的 node 和 npm 版本和 package.json 要求的时候一样
    require('./check-versions')()

    process.env.NODE_ENV = 'production'

    const ora = require('ora')  // 在用户打包的时候能够让用户知道正在进行，一个加载中的样式，转啊转
    const rm = require('rimraf') //这个模块是用来清除之前的打的包，因为在vue-cli中每次打包会生成不同的hash
    const path = require('path') //node 路径模块，便于我们操作文件路径
    const chalk = require('chalk') //带颜色的输出模块，能在控制台中输出不同的样色
    const webpack = require('webpack') //webpack 不解释
    const config = require('../config') // 项目中的配置文件，👆上面已经进行了配置介绍
    const webpackConfig = require('./webpack.prod.conf') // 生产环境的配置文件


    const spinner = ora('building for production...')// 实例一个打包加载中实例
    spinner.start() //开始转圈，营造一个正在打包的场景

    // 删除上一次打包的文件，删除成功，开始按照生产环境配置进行打包
    rm(path.join(config.build.assetsRoot, config.build.assetsSubDirectory), err => {
      if (err) throw err


        //开始打包，打包结束停止 spinner 转圈，有报错则在控制台输出
      webpack(webpackConfig, (err, stats) => {
        spinner.stop()
        if (err) throw err

        // node 环境里的输出配置，process.stdout.write 你可以理解成 js 里的 console
        process.stdout.write(stats.toString({
          colors: true, //让打包的时候有颜色。
          modules: false,  //去掉内置模块信息
          children: false, // 去掉子模块,如果你使用了 ts-loader，设置成 true 会在打包构建阶段展示错误信息
          chunks: false, // 增加包信息（设置为 false 能允许较少的冗长输出）
          chunkModules: false //去除包里内置模块的信息
        }) + '\n\n')


         //打包出错在控制台输出 Build failed with errors ，退出打包程序
        if (stats.hasErrors()) {
          console.log(chalk.red('  Build failed with errors.\n'))
          process.exit(1)
        }

        //打包成功则输出 Build complete 结束打包
        console.log(chalk.cyan('  Build complete.\n'))
        console.log(chalk.yellow(
          '  Tip: built files are meant to be served over an HTTP server.\n' +
          '  Opening index.html over file:// won\'t work.\n'
        ))
      })
    })
</pre>

<h4 id="webpack-base-conf-js"><a href="#webpack-base-conf-js" class="headerlink" title="webpack.base.conf.js"></a>webpack.base.conf.js</h4><pre>

    'use strict'
    const path = require('path')  // node 路径模块
    const utils = require('./utils') //node 内部常用的工具类，其中包括：格式化字符串、对象的序列化、实现对象继承等常用方法
    const config = require('../config') //👆上面我们介绍的，项目配置文件
    const vueLoaderConfig = require('./vue-loader.conf') //👆 上面我们介绍的 vue 加载器配置文件

    //返回当前配置文件位置是 build ，该方法放回 build/../dir 的相对路基
    function resolve (dir) {
      return path.join(__dirname, '..', dir)
    }

    // eslint 语法检测配置
    const createLintingRule = () => ({
      test: /\.(js|vue)$/,
      loader: 'eslint-loader',
      enforce: 'pre',
      include: [resolve('src'), resolve('test')],
      options: {
        formatter: require('eslint-friendly-formatter'),
        emitWarning: !config.dev.showEslintErrorsInOverlay
      }
    })

    // webpack 通用配置内容
    module.exports = {
      context: path.resolve(__dirname, '../'),  // 上下文，基础目录，用于从配置中解析入口起点和 loader
      entry: {
        app: './src/main.js'  //起点或是应用程序的起点入口。从这个起点开始，应用程序启动执行。如果传递一个数组，那么数组的每一项都会执行。
      },
      output: {
        path: config.build.assetsRoot,   //输出 bundle 的路径
        filename: '[name].js',          //输出 bundle 的名称
        publicPath: process.env.NODE_ENV === 'production' // 指定资源文件引用的目录，例如图片
          ? config.build.assetsPublicPath
          : config.dev.assetsPublicPath
      },
      resolve: {
        extensions: ['.js', '.vue', '.json'], //配置模块如何解析,
        alias: {                              // 创建应用的别名，
          'vue$': 'vue/dist/vue.esm.js',
          '@': resolve('src'),
        }
      },
  module: {
    rules: [
      //判断配置中是否要是用 eslint 语法检测，如果使用，就将 createLintingRule 配置对象返回
      ...(config.dev.useEslint ? [createLintingRule()] : []),

     //👇是一些比较常用的加载器，及配置，不做详细介绍了
      {
        test: /\.vue$/,
        loader: 'vue-loader',
        options: vueLoaderConfig
      },
      {
        test: /\.js$/,
        loader: 'babel-loader',
        include: [resolve('src'), resolve('test'), resolve('node_modules/webpack-dev-server/client')]
      },
      {
        test: /\.(css | scss)$/,
        loader: 'style-loader!css-loader!!sass-loader'
      },
      {
        test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,
        loader: 'url-loader',
        options: {
          limit: 10000,
          name: utils.assetsPath('img/[name].[hash:7].[ext]')
        }
      },
      {
        test: /\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/,
        loader: 'url-loader',
        options: {
          limit: 10000,
          name: utils.assetsPath('media/[name].[hash:7].[ext]')
        }
      },
      {
        test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/,
        loader: 'url-loader',
        options: {
          limit: 10000,
          name: utils.assetsPath('fonts/[name].[hash:7].[ext]')
        }
      }
    ]
  },
  node: {

    //防止因为 vue 资源本身就自带的 无用的 node 注入，浏览器兼容处理
    setImmediate: false,
    dgram: 'empty',
    fs: 'empty',
    net: 'empty',
    tls: 'empty',
    child_process: 'empty'
  }
}

</pre>


<h4 id="webpack-dev-conf-js"><a href="#webpack-dev-conf-js" class="headerlink" title="webpack.dev.conf.js"></a>webpack.dev.conf.js</h4><pre>

    'use strict'
    const utils = require('./utils')  //node 工具模块
    const webpack = require('webpack') //webpack 不解释
    const config = require('../config')//👆提到的配置文件
    const merge = require('webpack-merge') // merge 工具，用来合并生产和开发环境通用的基础 webpack 配置
    const path = require('path')            //node 的路径模块
    const baseWebpackConfig = require('./webpack.base.conf') //生产和开发环境通用的基础 webpack 配置
    const CopyWebpackPlugin = require('copy-webpack-plugin') //拷贝插件
    const HtmlWebpackPlugin = require('html-webpack-plugin')  //动态生成 html 插件
    const FriendlyErrorsPlugin = require('friendly-errors-webpack-plugin') //友好的错误输出插件
    const portfinder = require('portfinder') //能够获取一个可用的随机端口号

    const HOST = process.env.HOST   //node 全局环境变量的主机
    const PORT = process.env.PORT && Number(process.env.PORT)   //node 全局环境变量的端口

    //合并基础配置加载器的配置部分
    const devWebpackConfig = merge(baseWebpackConfig, {

      module: {
        // 为 .vue 文件意外的独立样式文件配置加载器
        rules: utils.styleLoaders({ sourceMap: config.dev.cssSourceMap, usePostCSS: true })
      },

      // cheap-module-eval-source-map 在开发环境中很快
      devtool: config.dev.devtool,

      // 开发服务配置，👆 已经细讲过，顺便回顾一下
      devServer: {
         clientLogLevel: 'warning',  // 在开发攻击的控制台中显示信息，便于开发调试，你可以将参数配置成 "none" 来进行关闭
         historyApiFallback: { // 当使用 HTML5 History API 时，任意的 404 响应都可能需要被替代为 index.html
            rewrites: [
               { from: /.*/, to: path.posix.join(config.dev.assetsPublicPath, 'index.html') },
            ],
         },
         hot: true,   //启用项目的热刷新，即模块热替换特性
         contentBase: false,   // 告诉服务器从哪里提供内容。只有在你想要提供静态文件时才需要。这里禁用，因为配置了 CopyWebpackPlugin 的使用
         compress: true,
         host: HOST || config.dev.host,   //指定使用一个域名。默认是 localhost
         port: PORT || config.dev.port,   //指定要监听请求的端口号：
         open: config.dev.autoOpenBrowser, //open 参数配置，如果配置成 true ，项目启动后会自动打开浏览器
         overlay: config.dev.errorOverlay   //当有错误或则警告的时候在页面上显示一个全屏的遮罩提示
               ? { warnings: false, errors: true }
               : false,
         publicPath: config.dev.assetsPublicPath, //此路径下的打包文件可在浏览器中访问
         proxy: config.dev.proxyTable,           //代理API的请求
         quiet: true,       //启用 quiet 后，除了初始启动信息之外的任何内容都不会被打印到控制台,特别是使用了 FriendlyErrorsPlugin 插件的时候
         watchOptions: {   //与监视文件相关的控制选项。是否使用轮询
               poll: config.dev.poll,
         }
       },

      plugins: [
        // DefinePlugin 允许创建一个在编译时可以配置的全局常量。这可能会对开发模式和发布模式的构建允许不同的行为非常有用
        new webpack.DefinePlugin({
          'process.env': require('../config/dev.env')
        }),
        new webpack.HotModuleReplacementPlugin(), //启用热替换模块(Hot Module Replacement)，也被称为 HMR
        new webpack.NamedModulesPlugin(), // 当开启 HMR 的时候使用该插件会显示模块的相对路径，建议用于开发环境
        new webpack.NoEmitOnErrorsPlugin(), 在编译出现错误时，使用 NoEmitOnErrorsPlugin 来跳过输出阶段

        //HtmlWebpackPlugin简化了HTML文件的创建，以便为你的webpack包提供服务。这对于在文件名中包含每次会随着编译而发生变化哈希的 webpack bundle 尤其有用
        new HtmlWebpackPlugin({
          filename: 'index.html',
          template: 'index.html',
          inject: true
        }),


        // 拷贝自定义的静态资源文件
        new CopyWebpackPlugin([
          {
            from: path.resolve(__dirname, '../static'),
            to: config.dev.assetsSubDirectory,
            ignore: ['.*']
          }
        ])
      ]
    })

    // 实例一个异步对象，执行 devWebpackConfig 配置编译
    module.exports = new Promise((resolve, reject) => {
      portfinder.basePort = process.env.PORT || config.dev.port  //设置基础端口
      portfinder.getPort((err, port) => {获取端口，输出构建新
        if (err) {
          reject(err)
        } else {
          // 如果进行 e2e 测试，需要发布新端口
          process.env.PORT = port

          // 更新 devServer 的端口
          devWebpackConfig.devServer.port = port

          devWebpackConfig.plugins.push(new FriendlyErrorsPlugin({
            compilationSuccessInfo: {
              messages: [`Your application is running here: http://${devWebpackConfig.devServer.host}:${port}`],
            },
            onErrors: config.dev.notifyOnErrors
            ? utils.createNotifierCallback()
            : undefined
          }))

           //执行打包配置文件
          resolve(devWebpackConfig)
        }
      })
    })

</pre>

<h4 id="webpack-prod-conf-js"><a href="#webpack-prod-conf-js" class="headerlink" title="webpack.prod.conf.js"></a>webpack.prod.conf.js</h4><pre>

    'use strict'
    const path = require('path') // node 路径模块
    const utils = require('./utils') //小工具函数
    const webpack = require('webpack') // webpack 不解释
    const config = require('../config')//👆提到的配置文件
    const merge = require('webpack-merge') // merge 工具，用来合并生产和开发环境通用的基础 webpack 配置
    const baseWebpackConfig = require('./webpack.base.conf')//产和开发环境通用的基础 webpack 配置
    const CopyWebpackPlugin = require('copy-webpack-plugin') //拷贝插件
    const HtmlWebpackPlugin = require('html-webpack-plugin')  //动态生成 html 插件
    const ExtractTextPlugin = require('extract-text-webpack-plugin')//用来做文件分离的插件
    const OptimizeCSSPlugin = require('optimize-css-assets-webpack-plugin')//优化提炼出来的css
    const UglifyJsPlugin = require('uglifyjs-webpack-plugin')// 压缩 js 文件插件

    //生产环境配置
    const env = require('../config/prod.env')

    //合并基础配置加载器的配置部分
    const webpackConfig = merge(baseWebpackConfig, {
    //为独立分离出来的样式配置加载器和source，map
      module: {
        rules: utils.styleLoaders({
          sourceMap: config.build.productionSourceMap,
          extract: true,
          usePostCSS: true
        })
      },
      //配置线上的 source map 便于排查问题
      devtool: config.build.productionSourceMap ? config.build.devtool : false,
      //配置输出，路径，文件名
      output: {
        path: config.build.assetsRoot,
        filename: utils.assetsPath('js/[name].[chunkhash].js'),
        chunkFilename: utils.assetsPath('js/[id].[chunkhash].js')
      },
      plugins: [
        // DefinePlugin 允许创建一个在编译时可以配置的全局常量。这可能会对开发模式和发布模式的构建允许不同的行为非常有用
        new webpack.DefinePlugin({
          'process.env': env
        }),

        // 使用 UglifyJsPlugin 插件对 js 进行压缩
        new UglifyJsPlugin({
          uglifyOptions: {
            compress: {
              warnings: false
            }
          },
          //配置插件的source map
          sourceMap: config.build.productionSourceMap,
          parallel: true
        }),
        // 提取 css 到单独的文件，分离文件异步加载，提高加载速度
        new ExtractTextPlugin({
          filename: utils.assetsPath('css/[name].[contenthash].css'),

          //如果把 allChunks 参数设置陈 false ，就不会把css 从代码块中分离出来
          //代码块加载的时候 css 会被 styles-loader 动态的加载
          allChunks: true,
        }),

        //使用这个插件，从不同的组件中复制脱离出来，进行 css 压缩
        new OptimizeCSSPlugin({
          cssProcessorOptions: config.build.productionSourceMap
            ? { safe: true, map: { inline: false } }
            : { safe: true }
        }),

        //自动生成 html 文件，通常 index.html 文件都会带一个哈希值来清除缓存
        new HtmlWebpackPlugin({
          filename: config.build.index,
          template: 'index.html',
          inject: true,
          minify: {
            removeComments: true,
            collapseWhitespace: true,
            removeAttributeQuotes: true
          },

          chunksSortMode: 'dependency'
        }),
        //该插件会根据模块的相对路径生成一个四位数的hash作为模块id, 渲染模块没有变化的时候，id 不会变。
        new webpack.HashedModuleIdsPlugin(),

        // 提升或者预编译所有模块到一个闭包中，提升你的代码在浏览器中的执行速度。
        new webpack.optimize.ModuleConcatenationPlugin(),

        // 分离渲染的js 到独立的文件中
        new webpack.optimize.CommonsChunkPlugin({
          name: 'vendor',
          minChunks (module) {
            //被引用到的包会从 node_modules 中提取出来
            return (
              module.resource &&
              /\.js$/.test(module.resource) &&
              module.resource.indexOf(
                path.join(__dirname, '../node_modules')
              ) === 0
            )
          }
        }),

        new webpack.optimize.CommonsChunkPlugin({
          name: 'manifest',
          minChunks: Infinity
        }),

        new webpack.optimize.CommonsChunkPlugin({
          name: 'app',
          async: 'vendor-async',
          children: true,
          minChunks: 3
        }),

        // 拷贝自定义的静态资源文件
        new CopyWebpackPlugin([
          {
            from: path.resolve(__dirname, '../static'),
            to: config.build.assetsSubDirectory,
            ignore: ['.*']
          }
        ])
      ]
    })

    //判断如果配置了生产环境压缩，是则使用插件进行压缩
    if (config.build.productionGzip) {
      const CompressionWebpackPlugin = require('compression-webpack-plugin')

      webpackConfig.plugins.push(
        new CompressionWebpackPlugin({
          asset: '[path].gz[query]',
          algorithm: 'gzip',
          test: new RegExp(
            '\\.(' +
            config.build.productionGzipExtensions.join('|') +
            ')$'
          ),
          threshold: 10240,
          minRatio: 0.8
        })
      )
    }

    //是否要生成代码打包分析报告
    if (config.build.bundleAnalyzerReport) {
      const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin
      webpackConfig.plugins.push(new BundleAnalyzerPlugin())
    }

    module.exports = webpackConfig


</pre>


<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>👆这篇文章详细的介绍了脚手架项目的 webpack 配置，但是只是 webpack 的一部分，还有很多内容值得我们去探究，如果你还感兴趣，可以阅读下面这些文章。也欢迎随时与我进行交流，微信号：646321933</p>
<p><a href="https://doc.webpack-china.org/guides/production/" target="_blank" rel="external">webpack指南 </a><br><a href="https://doc.webpack-china.org/concepts/" target="_blank" rel="external">webpack文档</a><br><a href="https://doc.webpack-china.org/configuration
[开发 ](https://doc.webpack-china.org/guides/development/#%E4%BD%BF%E7%94%A8-source-map" target="_blank" rel="external">webpack配置 </a><br><a href="https://juejin.im/post/5a31d210f265da431a43330e" target="_blank" rel="external">自己动手实现一个脚手架</a><br><a href="https://doc.webpack-china.org/plugins" target="_blank" rel="external">webpack 官方插件集合介绍文档 </a><br><a href="https://segmentfault.com/a/1190000007441374" target="_blank" rel="external">《 使用vue-cli脚手架创建新项目》</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2018/04/28/history/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/28/history/" itemprop="url">
                  你需要知道的单页面路由实现原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-28T09:43:21+08:00">
                2018-04-28
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2018/04/28/history/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/04/28/history/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近开发的埋点项目，需要记录用户行为轨迹即用户页面访问顺序。需要在页面跳转的时候，记录用户访问的信息（比如 url ，请求头部等），非单页面应用可以给 window 对象加上一个 beforeunload 事件，在页面离开时触发采集开关，但是现在很多业务是单页面应用，用户切换地址的时候，是无刷新的局部更新，没有办法触发 beforeunload。所以单页面应用的路由插件一定运用了 window 自带的无刷新修改用户浏览记录的方法，pushState 和 replaceState。</p>
<h3 id="pushState-和-replaceState-了解一下"><a href="#pushState-和-replaceState-了解一下" class="headerlink" title="pushState 和 replaceState 了解一下"></a>pushState 和 replaceState 了解一下</h3><blockquote>
<p>history 提供了两个方法，能够无刷新的修改用户的浏览记录，pushSate，和 replaceState，区别的 pushState 在用户访问页面后面添加一个访问记录， replaceState 则是直接替换了当前访问记录</p>
</blockquote>
<p>history 对象的详细信息已经有很多很好很详细的介绍文献，这里不再做总结，我们引用阮老师的教程介绍，<a href="http://javascript.ruanyifeng.com/bom/history.html" target="_blank" rel="external">history对象 – JavaScript 标准参考教程（alpha）</a></p>
<h4 id="history-pushState"><a href="#history-pushState" class="headerlink" title="history.pushState"></a>history.pushState</h4><p>history.pushState方法接受三个参数，依次为：</p>
<blockquote>
<p>state：一个与指定网址相关的状态对象，popstate事件触发时，该对象会传入回调函数。如果不需要这个对象，此处可以填null。<br>title：新页面的标题，但是所有浏览器目前都忽略这个值，因此这里可以填null。<br>url：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址。<br>假定当前网址是example.com/1.html，我们使用pushState方法在浏览记录（history对象）中添加一个新记录。</p>
</blockquote>
<pre>
    var stateObj = { foo: 'bar' };
    history.pushState(stateObj, 'page 2', '2.html');
</pre>

<p>添加上面这个新记录后，浏览器地址栏立刻显示 example.com/2.html，但并不会跳转到 2.html，甚至也不会检查2.html 是否存在，它只是成为浏览历史中的最新记录。这时，你在地址栏输入一个新的地址(比如访问 google.com )，然后点击了倒退按钮，页面的 URL 将显示 2.html；你再点击一次倒退按钮，URL 将显示 1.html。</p>
<p>总之，pushState 方法不会触发页面刷新，只是导致 history 对象发生变化，地址栏会有反应。</p>
<p>如果 pushState 的 url参数，设置了一个新的锚点值（即hash），并不会触发 hashchange 事件。如果设置了一个跨域网址，则会报错。</p>
<pre>
    // 报错
    history.pushState(null, null, 'https://twitter.com/hello');

    上面代码中，pushState想要插入一个跨域的网址，导致报错。这样设计的目的是，防止恶意代码让用户以为他们是在另一个网站上。
</pre>

<h4 id="history-replaceState"><a href="#history-replaceState" class="headerlink" title="history.replaceState"></a>history.replaceState</h4><p>history.replaceState 方法的参数与 pushState 方法一模一样，区别是它修改浏览历史中当前纪录,假定当前网页是 example.com/example.html。</p>
<pre>
    history.pushState({page: 1}, 'title 1', '?page=1');
    history.pushState({page: 2}, 'title 2', '?page=2');
    history.replaceState({page: 3}, 'title 3', '?page=3');

    history.back()
    // url显示为http://example.com/example.html?page=1

    history.back()
    // url显示为http://example.com/example.html

    history.go(2)
    // url显示为http://example.com/example.html?page=3

</pre>

<h3 id="单页面应用用户访问轨迹埋点"><a href="#单页面应用用户访问轨迹埋点" class="headerlink" title="单页面应用用户访问轨迹埋点"></a>单页面应用用户访问轨迹埋点</h3><p>开发过单页面应用的同学，一定比较清楚，单页面应用的路由切换是无感知的，不会重新进行 http 请求去获取页面，而是通过改变页面渲染视图来实现。所以他的实现原理一定也是通过原生的 pushState 或则 replaceState 来实现的。所以在页面跳转的时候一定会调用 pushState 或则 replaceState ，要记录用户的跳转信息，我们只要拦截 pushState 和 replaceState，在执行默行为<strong>前</strong>先执行我们的方法就能够采集到用户的跳转信息了</p>
<pre>

    // 改写思路：拷贝 window 默认的 replaceState 函数，重写 history.replaceState 在方法里插入我们的采集行为，在重写的 replaceState 方法最后调用，window 默认的 replaceState 方法

    collect = {}

    collect.onPushStateCallback : function(){}  // 自定义的采集方法

    (function(history){

        var replaceState = history.replaceState;   // 存储原生 replaceState

        history.replaceState = function(state, param) {     // 改写 replaceState
           var url = arguments[2];

           if (typeof collect.onPushStateCallback == "function") {
                 collect.onPushStateCallback({state: state, param: param, url: url});   //自定义的采集行为方法
           }

           return replaceState.apply(history, arguments);    // 调用原生的 replaceState
        };
     })(window.history);


</pre>

<h3 id="vue-router-的路由实现"><a href="#vue-router-的路由实现" class="headerlink" title="vue-router 的路由实现"></a>vue-router 的路由实现</h3><p>既然知道了这个原理，我们来看下 vue-router 的实现，我们打开 <a href="https://github.com/vuejs/vue-router" target="_blank" rel="external">vue-router 项目地址</a>,把项目克隆下来，或则直接在 github 上预览，在 Vue 开发的项目里，我们通过 router.push(‘home’) 来实现页面的跳转，所以我们检索下，push 方法的实现</p>
<p><img src="/images/history/search.jpeg" alt="push方法检索"></p>
<p>我们检索到了 20 个 js 文件，😂，一般到这个时候，我们会放弃源码阅读，那么我们今天的文章就到这结束，谢谢大家！</p>
<p>开个玩笑，源码阅读不能这么粗糙，我们找到 src 目录，点开 <code>index.js</code> 文件，看到 history对象的定义和 mode 参数有关</p>
<pre>
 if (!inBrowser) {
      mode = 'abstract'
    }
    this.mode = mode

    switch (mode) {
      case 'history':
        this.history = new HTML5History(this, options.base)
        break
      case 'hash':
        this.history = new HashHistory(this, options.base, this.fallback)
        break
      case 'abstract':
        this.history = new AbstractHistory(this, options.base)
        break
      default:
        if (process.env.NODE_ENV !== 'production') {
          assert(false, `invalid mode: ${mode}`)
        }
    }
</pre>

<p>看到 history 对象的实例与配置的 mode 有关，vue-router 通过3中方式实现了路由切换。与我们今天讲的内容相匹配的是 <code>HTML5History</code> 的实现方案，其他的将不再文章中做扩展，若果你感兴趣想要了解，可以看文章后面的扩展阅读</p>
<p>我们来看 vue-router 中的 HTML5History 源码：</p>
<pre>
    push (location: RawLocation, onComplete?: Function, onAbort?: Function) {
      const { current: fromRoute } = this
      this.transitionTo(location, route => {
        pushState(cleanPath(this.base + route.fullPath))
        handleScroll(this.router, route, fromRoute, false)
        onComplete && onComplete(route)
      }, onAbort)
    }

    replace (location: RawLocation, onComplete?: Function, onAbort?: Function) {
      const { current: fromRoute } = this
      this.transitionTo(location, route => {
        replaceState(cleanPath(this.base + route.fullPath))
        handleScroll(this.router, route, fromRoute, false)
        onComplete && onComplete(route)
      }, onAbort)
    }

    // src/util/push-state.js
    export function pushState (url?: string, replace?: boolean) {
      saveScrollPosition()
      // try...catch the pushState call to get around Safari
      // DOM Exception 18 where it limits to 100 pushState calls
      const history = window.history
      try {
        if (replace) {
          history.replaceState({ key: _key }, '', url)
        } else {
          _key = genKey()
          history.pushState({ key: _key }, '', url)
        }
      } catch (e) {
        window.location[replace ? 'replace' : 'assign'](url)
      }
    }

    export function replaceState (url?: string) {
      pushState(url, true)
    }
</pre>

<p>在使用 Vue 开发的过程中，我们一定用到过 push 和 replace 来改变路由，和视图。</p>
<p>router 实例调用的 push 实际是 history 的方法，通过 mode 来确定匹配 history 的实现方案，从代码中我们看到，push 调用了 src/util/push-state.js 中被改写过的 pushState 的方法，改写过的方法会根据传入的参数 <code>replace?: boolean</code>来进行判断调用 pushState 还是 replaceState ，同时做了错误捕获，如果，history 无刷新修改访问路径失败，则调用  <code>window.location.replace(url)</code> ,有刷新的切换用户访问地址 ，同理 <code>pushState</code> 也是这样。这里的 transitionTo 方法主要的作用是做视图的跟新及路由跳转监测，如果 url 没有变化（访问地址切换失败的情况），在 transitionTo 方法内部还会调用一个 ensureURL 方法，来修改 url。 transitionTo 方法中应用的父方法比较多，这里不做长篇赘述，具体代码分析可以关注后我以后的文章</p>
<h3 id="模拟单页面路由"><a href="#模拟单页面路由" class="headerlink" title="模拟单页面路由"></a>模拟单页面路由</h3><p>通过上面的学习，我们知道了，单页面应用路由的实现原理，我们也尝试去实现一个。在做管理系统的时候，我们通常会在页面的左侧放置一个固定的导航 sidebar，页面的右侧放与之匹配的内容 main 。点击导航时，我们只希望内容进行更新，如果刷新了整个页面，到时导航和通用的头部底部也进行重绘重排的话，十分浪费资源，体验也会不好。这个时候，我们就能用到我们今天学习到的内容，通过使用 HTML5 的 pushState 方法和 replaceState 方法来实现，</p>
<p>思路：首先绑定 click 事件。当用户点击一个链接时，通过 preventDefault 函数防止默认的行为（页面跳转），同时读取链接的地址（如果有 jQuery，可以写成$(this).attr(‘href’)），把这个地址通过pushState塞入浏览器历史记录中，再利用 AJAX 技术拉取（如果有 jQuery，可以使用$.get方法）这个地址中真正的内容，同时替换当前网页的内容。</p>
<p>为了处理用户前进、后退，我们监听 popstate 事件。当用户点击前进或后退按钮时，浏览器地址自动被转换成相应的地址，同时popstate事件发生。在事件处理函数中，我们根据当前的地址抓取相应的内容，然后利用 AJAX 拉取这个地址的真正内容，呈现，即可。</p>
<p>最后，整个过程是不会改变页面标题的，可以通过直接对 document.title 赋值来更改页面标题。</p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>好了,我们今天通过多个方面来讲了 pushState 方法和 replaceState 的应用，你应该对这个两个方法能有一个比较深刻的印象，如果想要了解更多，你可以参考以下链接</p>
<p><a href="http://javascript.ruanyifeng.com/bom/history.html" target="_blank" rel="external">history对象 – JavaScript 标准参考教程（alpha）</a><br><a href="https://zhuanlan.zhihu.com/p/27588422" target="_blank" rel="external">从vue-router看前端路由的两种实现</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2018/04/02/javascript-notes/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/02/javascript-notes/" itemprop="url">
                  你需要知道的 javascript 的细节
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-02T17:27:29+08:00">
                2018-04-02
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2018/04/02/javascript-notes/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/04/02/javascript-notes/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>现在的前端框架层出不穷，3个月就要重新入门一次前端的现状，让我们来不及学好基础就开始上手框架。常常就因为这样，我们会很快到达基础<code>技术瓶颈</code>，基础是所有技术的核心，在跳槽季重新温故了一遍 javascript 基础，有收获，整理出来分享给大家。</p>
</blockquote>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="变量可以当对象使用"><a href="#变量可以当对象使用" class="headerlink" title="变量可以当对象使用"></a>变量可以当对象使用</h4><p><code>javascript</code> 中所有的变量都可以当做对象使用，除了<code>undefined</code> 和 <code>null</code> ，我们测试下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">false.toString() // &quot;false&quot;</div><div class="line"></div><div class="line">[1,2,3].toString() //&quot;1,2,3&quot;</div><div class="line"></div><div class="line">1..toString() //&quot;1&quot;</div><div class="line"></div><div class="line">(&#123;a:&apos;33&apos;&#125;).toString() //&quot;[object Object]&quot;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">undefined.toString() //Uncaught TypeError</div><div class="line"></div><div class="line">null.toString()   //Uncaught TypeError</div></pre></td></tr></table></figure>
<p>数值和对象虽然能调用 <code>toString</code> 方法，但是在写法上需要注意下</p>
<p><code>number</code> 调用时不能直接数值后面直接调用<code>toString</code> 方法，因为 <code>js</code> 会将点运算符解析为数值的小数点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.toString() //Uncaught SyntaxError</div><div class="line"></div><div class="line">1..toString() //&quot;1&quot;</div></pre></td></tr></table></figure>
<p>对象直接调用<code>toString</code> 方法时，需要用小括号包裹起来，不然<code>js</code> 会将对象的花括号识别成块，从而报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;a:&apos;33&apos;&#125;.toString()  // Uncaught SyntaxError</div><div class="line"></div><div class="line">(&#123;a:&apos;33&apos;&#125;).toString() // &quot;[object Object]&quot;</div></pre></td></tr></table></figure>
<h4 id="对象删除属性"><a href="#对象删除属性" class="headerlink" title="对象删除属性"></a>对象删除属性</h4><blockquote>
<p>删除对象的属性唯一的方法是使用 <code>delete</code> 操作符，设置元素属性为 <code>undefined</code> 或则 <code>null</code> 并不能真正删除，只是移除了属性和值的关联</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var test = &#123;</div><div class="line">	name:&apos;bbt&apos;,</div><div class="line">	age:&apos;18&apos;,</div><div class="line">	love:&apos;dog&apos;</div><div class="line">&#125;</div><div class="line"></div><div class="line">test.name = undefined</div><div class="line">test.age = null</div><div class="line">delete test.love</div><div class="line"></div><div class="line">for (var i in test)&#123;</div><div class="line">  console.log(i+&apos;:&apos;+test[i])</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">name:undefined</div><div class="line">age:null</div><div class="line">undefined</div></pre></td></tr></table></figure>
<p>只有 <code>love</code> 被正则删除，<code>name</code> 和 <code>age</code> 还是能被遍历到</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><blockquote>
<p>在 <code>javascript</code> 中，通过关键字 <code>new</code> 调用的函数就被认为是构造函数，我们可以通过构造函数创建对象实例</p>
</blockquote>
<p>但是在使用过程中你一定发现了，每实例化一个对象，都会在实例对象上创造构造函数的方法和属性。倘若创建的实例比较多，重复创建同一个方法去开辟内存空间就会显得十分浪费，我们可以通过把被经常复用的方法放在原型链上。</p>
<h4 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h4><blockquote>
<p><code>javascript</code> 和一些我们所了解的面向对象编程的语言不太一样，在 <code>es6</code> 语法以前，我们是通过原型链来实现方法和属性的继承</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">function Child()&#123;</div><div class="line">  this.name = &apos;bbt&apos;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Child.prototype = &#123;</div><div class="line">	title:&apos;baba&apos;,</div><div class="line">    method: function() &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function Grandson()&#123;&#125;</div><div class="line"></div><div class="line">//设置 Grandson 的 prototype 为 Child 的实例</div><div class="line">Grandson.prototype = new Child()</div><div class="line"></div><div class="line">//为 Grandson 的原型添加添加属性 age</div><div class="line">Grandson.prototype.age = 40</div><div class="line"></div><div class="line">// 修正 Grandson.prototype.constructor 为 Grandson 本身</div><div class="line">Grandson.prototype.constructor = Grandson;</div><div class="line"></div><div class="line">var xiaomin = new Grandson()</div><div class="line"></div><div class="line">//原型链如下</div><div class="line">xiaomin // Grandson的实例</div><div class="line">    Grandson.prototype // Child的实例</div><div class="line">         Grandson.prototype //&#123;title:&apos;baba&apos;,...&#125;</div><div class="line">            Object.prototype</div><div class="line">                &#123;toString: ... /* etc. */&#125;;</div></pre></td></tr></table></figure>
<p>对象的属性查找，<code>javascript</code> 会在原型链上向上查找属性，直到查到 原型链顶部，所以，属性在原型链的越上端，查找的时间会越长，查找性能和复用属性方面需要开发者自己衡量下。</p>
<h4 id="获取自身对象属性"><a href="#获取自身对象属性" class="headerlink" title="获取自身对象属性"></a>获取自身对象属性</h4><p><code>hasOwnProperty</code> 方法能够判断一个对象是否包含自定义属性，而不是在原型链上的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var test = &#123;hello:&apos;123&apos;&#125;</div><div class="line"></div><div class="line">Object.prototype.name = &apos;bbt&apos;</div><div class="line"></div><div class="line">test.name  //&apos;bbt&apos;</div><div class="line">test.hasOwnProperty(&apos;hello&apos;) //true</div><div class="line">test.hasOwnProperty(&apos;name&apos;) //false</div></pre></td></tr></table></figure>
<p><code>for in</code> 循环可以遍历对象原型链上的所有属性，如此我们将 <code>hasOwnProperty</code>结合循环<code>for in</code> 能够获取到对象自定义属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var test = &#123;hello:&apos;222&apos;&#125;</div><div class="line">Object.prototype.name = &apos;bbt&apos;</div><div class="line"></div><div class="line">for(var i in test)&#123;</div><div class="line">  console.log(i) // 输出两个属性，hello ，name</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">for(var i in test)&#123;</div><div class="line">  if(test.hasOwnProperty(i))&#123;</div><div class="line">    console.log(i)//只输出 hello</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了上面的方法，<code>getOwnPropertyNames</code> 和 <code>Object.keys</code> 方法，能够返回对象自身的所有属性名，也是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有属性名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var test = &#123;hello:&apos;222&apos;&#125;</div><div class="line">Object.prototype.name = &apos;bbt&apos;</div><div class="line"></div><div class="line">Object.keys(test) //[&quot;hello&quot;]</div><div class="line">Object.getOwnPropertyNames(test) //[&quot;hello&quot;]</div></pre></td></tr></table></figure>
<p>那 <code>getOwnPropertyNames</code> 和 <code>Object.keys</code> 的用法有什么区别呢</p>
<p><code>Object.keys</code>方法只返回可枚举的属性，<code>Object.getOwnPropertyNames</code>  方法还返回不可枚举的属性名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var a = [&apos;Hello&apos;, &apos;World&apos;];</div><div class="line"></div><div class="line">Object.keys(a) // [&quot;0&quot;, &quot;1&quot;]</div><div class="line"></div><div class="line">Object.getOwnPropertyNames(a) // [&quot;0&quot;, &quot;1&quot;, &quot;length&quot;]  // length 是不可枚举属性</div></pre></td></tr></table></figure>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="函数声明的变量提升"><a href="#函数声明的变量提升" class="headerlink" title="函数声明的变量提升"></a>函数声明的变量提升</h4><p>我们通常会使用函数声明或函数赋值表达式来定义一个函数，函数声明和变量声明一样都存在提升的情况，函数可以在声明前调用，但是不可以在赋值前调用</p>
<p>函数声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">foo(); // 正常运行，因为foo在代码运行前已经被创建</div><div class="line">function foo() &#123;&#125;</div></pre></td></tr></table></figure>
<p>函数表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">foo; // &apos;undefined&apos;</div><div class="line">foo(); // 出错：TypeError</div><div class="line">var foo = function() &#123;&#125;;</div></pre></td></tr></table></figure>
<p>变量提升是在代码解析的时候进行的，foo() 方法调用的时候，已经在解析阶段将 foo 定义过了。赋值语句只在代码运行时才进行，所以在赋值前调用会报错</p>
<p>一种比较少用的函数赋值操作，将命名函数赋值给一个变量，此时的函数名只对函数内部可见</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var test = function foo()&#123;</div><div class="line">  console.log(foo) //正常输出</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log(foo) //Uncaught ReferenceError</div></pre></td></tr></table></figure>
<h4 id="this-的工作原理"><a href="#this-的工作原理" class="headerlink" title="this 的工作原理"></a>this 的工作原理</h4><blockquote>
<p>在 <code>javascript</code> 中 ，<code>this</code> 是一个比较难理解的点，不同的调用环境会导致 <code>this</code> 的不同指向，但是唯一不变的是 <code>this</code> 总是指向一个对象</p>
</blockquote>
<p>简单的说，<code>this</code> 就是属性和方法当前所在的对象（函数执行坐在的作用域），平时使用的 <code>this</code>  的情况可以大致分为5种</p>
<table>
<thead>
<tr>
<th>调用方式</th>
<th>指向</th>
</tr>
</thead>
<tbody>
<tr>
<td>1. 全局范围调用</td>
<td>指向 window 全局对象</td>
</tr>
<tr>
<td>2. 函数调用</td>
<td>指向 window 全局变量</td>
</tr>
<tr>
<td>3. 对象的方法调用</td>
<td>指向方法调用的对象</td>
</tr>
<tr>
<td>4. 构造函数调用</td>
<td>指向构造函数创建的实例</td>
</tr>
<tr>
<td>5. 通过，call ，apply ，bind 显示的指定 this指向</td>
<td>和传参有关</td>
</tr>
</tbody>
</table>
<p>Function.call</p>
<blockquote>
<p>语法：function.call(thisArg, arg1, arg2, …)，<code>thisArg</code>表示希望函数被调用的作用域，<code>arg1, arg2, …</code>表示希望被传入函数额参数 , 如果参数为空、<code>null</code>和<code>undefined</code>，则默认传入全局对象。</p>
</blockquote>
<p>代码示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var name = &apos;xiaomin&apos;</div><div class="line">var test = &#123;name : &apos;bbt&apos;&#125;</div><div class="line"></div><div class="line">function hello( _name )&#123;</div><div class="line">  _name ?console.log(this.name,_name): console.log(this.name)</div><div class="line">&#125;</div><div class="line"></div><div class="line">hello() //xiaomin</div><div class="line">hello.call(test) //bbt</div><div class="line">hello.call(test,&apos;xiaohong&apos;) //bbt xiaohong</div><div class="line">hello.call() //xiaomin</div><div class="line">hello.call(null) //xiaomin</div><div class="line">hello.call(undefined) //xiaomin</div></pre></td></tr></table></figure>
<p>Function.apply</p>
<blockquote>
<p>语法和<code>call</code> 方法类似，不同的是，传入调用函数的参数变成以数组的形式传入，即 func.apply(thisArg, [argsArray])</p>
</blockquote>
<p>改造上面的示例就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hello.apply(test,[&apos;xiaomin&apos;])</div></pre></td></tr></table></figure>
<p>Function.bind</p>
<blockquote>
<p><code>bind</code>方法用于将函数体内的<code>this</code>绑定到某个对象，然后返回一个新函数。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var d = new Date();</div><div class="line">d.getTime()</div><div class="line"></div><div class="line">var print = d.getTime; //赋值后 getTime 已经不指向 d 实例</div><div class="line">print() // Uncaught TypeError</div></pre></td></tr></table></figure>
<p>解决方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var print = d.getTime.bind(d)</div></pre></td></tr></table></figure>
<p>容易出错的地方</p>
<p>容易出错的地方，函数调用，<code>this</code> 总是指向 <code>window</code> 全局变量，所以在对象的方法里如果有函数的调用的话（闭包的情况），<code>this</code> 是会指向 全局对象的，不会指向调用的对象，具体示例如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var name = &apos;xiaomin&apos;</div><div class="line">var test = &#123;</div><div class="line">  name : &apos;bbt&apos;</div><div class="line">&#125;</div><div class="line">test.method = function()&#123;</div><div class="line">  function hello()&#123;</div><div class="line">      console.log(this.name)</div><div class="line">    &#125;</div><div class="line">    hello()</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 调用</div><div class="line">test.method() // 输出 xiaomin</div></pre></td></tr></table></figure>
<p>如果需要将 <code>this</code> 指向调用的对象，可以将对象的 <code>this</code> 指向存储起来，通常我们使用 <code>that</code> 变量来做这个存储。改进之后的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var name = &apos;xiaomin&apos;</div><div class="line">var test = &#123;</div><div class="line">  name : &apos;bbt&apos;</div><div class="line">&#125;</div><div class="line">test.method = function()&#123;</div><div class="line">  var that = this</div><div class="line">  function hello()&#123;</div><div class="line">      console.log(that.name)</div><div class="line">    &#125;</div><div class="line">    hello()</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 调用</div><div class="line">test.method() // 输出 bbt</div></pre></td></tr></table></figure>
<p>####闭包和引用</p>
<blockquote>
<p>闭包我们可以理解成是在函数内部定义的函数</p>
</blockquote>
<p>在 <code>javascript</code> 中，内部作用域可以访问到外部作用域的变量，但是外部作用域不能访问内部作用域，需要访问的时候，我们需要通过创建闭包，来操作内部变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function test(_count)&#123;</div><div class="line">  var count = _count</div><div class="line"></div><div class="line">  return &#123;</div><div class="line">    inc:function()&#123;</div><div class="line">      count++</div><div class="line">    &#125;,</div><div class="line">    get:function()&#123;</div><div class="line">      return count</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var a = test(4)</div><div class="line">a.get()//4</div><div class="line">a.inc()</div><div class="line">a.get()//5</div></pre></td></tr></table></figure>
<p>闭包中常会出错的面试题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for(var i = 0; i &lt; 10; i++) &#123;</div><div class="line">    setTimeout(function() &#123;</div><div class="line">        console.log(i);</div><div class="line">    &#125;, 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很多同学会觉得，上面的代码会正常输出0到9，但是实际是输出十次10。遇到这个题目，除了闭包的概念要理解清楚，你还需要知道，<code>setTimeout</code> 内的代码会被异步执行，代码会先执行所有的同步代码，即上面的这段代码会先将 <code>for</code> 循环执行，此时 <code>i</code> 的值为 10，console.log(i) 一直引用着全局变量的 i  所以会输出十次 10</p>
<p> 改进代码，我们在 <code>for</code> 循环里创建一个闭包，把循环自增的 <code>i</code> 作为参数传入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for(var i = 0; i &lt; 10; i++) &#123;</div><div class="line">    (function(e) &#123;</div><div class="line">        setTimeout(function() &#123;</div><div class="line">            console.log(e);</div><div class="line">        &#125;, 1000);</div><div class="line">    &#125;)(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="setTimeout-amp-amp-setInterval"><a href="#setTimeout-amp-amp-setInterval" class="headerlink" title="setTimeout &amp;&amp; setInterval"></a>setTimeout &amp;&amp; setInterval</h4><blockquote>
<p><code>javascript</code> 是异步的单线程运行语言，其他代码运行的时候可能会阻塞 <code>setTimeout</code> &amp;&amp; <code>setInterval</code> 的运行</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">console.log(1)</div><div class="line">setTimeout(function()&#123;</div><div class="line">  console.log(2)</div><div class="line">&#125;, 0);</div><div class="line">console.log(3)</div><div class="line"></div><div class="line">输出结果： 1，3，2  //setTimeout 被阻塞</div></pre></td></tr></table></figure>
<p>处理阻塞的方法是将<code>setTimeout</code> 和 <code>setInterval</code>放在回调函数里执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function test()&#123;</div><div class="line">  	setTimeout(function()&#123;</div><div class="line">  		console.log(2)</div><div class="line">	&#125;, 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>setTimeout</code> 和 <code>setInterval</code> 被调用时会返回一个 ID 用来清除定时器</p>
<p>手工清除某个定时器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var id = setTimeout(foo, 1000);</div><div class="line">clearTimeout(id);</div></pre></td></tr></table></figure>
<p>清楚所有的定时器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var lastId = setTimeout(function()&#123;</div><div class="line">  console.log(&apos;11&apos;)</div><div class="line">&#125;, 0);</div><div class="line"></div><div class="line">for(var i=0;i&lt;lastId;i++;)&#123;</div><div class="line">  clearTimeout(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>获取最后一个定时器的id，遍历清除定时器，可以清除所有的定时器。</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>####包装对象</p>
<blockquote>
<p>数值、字符串、布尔值——在一定条件下，也会自动转为对象，也就是原始类型的“包装对象”。</p>
</blockquote>
<p>我们可以通过构造函数，将原始类型转化为对应的对象即包装对象，从而是原始类型能够方便的调用某些方法</p>
<p>数值，字符串，布尔值的类型转换函数分别是 <code>Number，String，Boolean</code>，在调用的时候在函数前面加上New 就变成了构造函数，能够蒋对应的原始类型转化为“包装对象”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var v1 = new Number(123);</div><div class="line">var v2 = new String(&apos;abc&apos;);</div><div class="line">var v3 = new Boolean(true);</div><div class="line"></div><div class="line">typeof v1 // &quot;object&quot;</div><div class="line">typeof v2 // &quot;object&quot;</div><div class="line">typeof v3 // &quot;object&quot;</div><div class="line"></div><div class="line">v1 === 123 // false</div><div class="line">v2 === &apos;abc&apos; // false</div><div class="line">v3 === true // false</div></pre></td></tr></table></figure>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>类型转换分为强制类型转换和自动转换，<code>javascript</code> 是动态类型语言，在到吗解析运行时，需要的数据类型和传入的数据类型不一致的时候，<code>javascript</code> 会进行自动类型转化。当然，你也可以通过类型转换方法进行强制类型装换。</p>
<p>日常开发中，我们最常用的数据类型自动转换不过就下面三种情况</p>
<p>不同数据类型之间相互运算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&apos;2&apos;+4 // &apos;24&apos;</div></pre></td></tr></table></figure>
<p>对非布尔值进行布尔运算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if(&apos;22&apos;)&#123;</div><div class="line">  console.log(&apos;hello&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对非数据类型使用一元运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+&apos;12&apos;  //12</div></pre></td></tr></table></figure>
<p>我们也通过<code>Number ，String，Boolean</code> 来进行强制数据类型转换。强制类型转化的规则有点复杂，我们来了解一下。</p>
<p>Number 转换  <a href="http://javascript.ruanyifeng.com/grammar/conversion.html" target="_blank" rel="external">引用阮老师的详细解释</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">第一步，调用对象自身的valueOf方法。如果返回原始类型的值，则直接对该值使用Number函数，不再进行后续步骤。</div><div class="line"></div><div class="line">第二步，如果 valueOf 方法返回的还是对象，则改为调用对象自身的 toString 方法。如果 toString 方法返回原始类型的值，则对该值使用 Number 函数，不再进行后续步骤。</div><div class="line"></div><div class="line">第三步，如果 toString 方法返回的是对象，就报错。</div></pre></td></tr></table></figure>
<p><code>String</code> 转换方法同样也是通过调用原对象的 <code>toString</code> 方法和 <code>valueOf</code> 方法，但是不同的是 <code>String</code> 函数会先调用 <code>toString</code> 方法进行转换</p>
<p><code>Boolean</code> 的转换规则会相对简单一些，除了几个特殊的值，都会被转化为 <code>true</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">undefined</div><div class="line">null</div><div class="line">+0或-0</div><div class="line">NaN</div><div class="line">&apos;&apos;（空字符串）</div></pre></td></tr></table></figure>
<p>但是要注意</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Boolean(&apos;false&apos;) //true</div></pre></td></tr></table></figure>
<h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><blockquote>
<p><code>typeof</code> 操作符返回数据类型，但是由于 <code>javascript</code> 设计的历史原因，<code>typeof</code> 现已经不能满足我们现在对于类型判断的要求了</p>
</blockquote>
<table>
<thead>
<tr>
<th>Value</th>
<th>Class</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>“foo”</td>
<td>String</td>
<td>string</td>
</tr>
<tr>
<td>new String(“foo”)</td>
<td>String</td>
<td>object</td>
</tr>
<tr>
<td>1.2</td>
<td>Number</td>
<td>number</td>
</tr>
<tr>
<td>new Number(1.2)</td>
<td>Number</td>
<td>object</td>
</tr>
<tr>
<td>true</td>
<td>Boolean</td>
<td>boolean</td>
</tr>
<tr>
<td>new Boolean(true)</td>
<td>Boolean</td>
<td>object</td>
</tr>
<tr>
<td>new Date()</td>
<td>Date</td>
<td>object</td>
</tr>
<tr>
<td>new Error()</td>
<td>Error</td>
<td>object</td>
</tr>
<tr>
<td>[1,2,3]</td>
<td>Array</td>
<td>object</td>
</tr>
<tr>
<td>new Array(1, 2, 3)</td>
<td>Array</td>
<td>object</td>
</tr>
<tr>
<td>new Function(“”)</td>
<td>Function</td>
<td>functio</td>
</tr>
<tr>
<td>/abc/g</td>
<td>RegExp</td>
<td>object (function in Nitro/V8)</td>
</tr>
<tr>
<td>new RegExp(“meow”)</td>
<td>RegExp</td>
<td>object (function in Nitro/V8)</td>
</tr>
<tr>
<td>{}</td>
<td>Object</td>
<td>object</td>
</tr>
<tr>
<td>new Object()</td>
<td>Object</td>
<td>object</td>
</tr>
<tr>
<td>null</td>
<td>null</td>
<td>object</td>
</tr>
</tbody>
</table>
<p>我们可以看到，<code>typeof</code> 不能区分对象的数组和日期，还会把 <code>null</code> 判断成对象，那我们一般是什么时候用 <code>typeof</code> 呢。我们可以用来判断一个已经定义的变量是否被赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a</div><div class="line">if(typeof a == &apos;undefined&apos;)&#123;</div><div class="line">  console.log(&apos;a 已经被定义&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><blockquote>
<p><code>instanceof</code> 操作符通常用来判断，一个对象是否在另一个对象的原型链上，需要注意的是 <code>instanceof</code> 的左值是对象，右值是构造函数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// defining constructors</div><div class="line">function C() &#123;&#125;</div><div class="line">function D() &#123;&#125;</div><div class="line"></div><div class="line">var o = new C();</div><div class="line"></div><div class="line">// true, because: Object.getPrototypeOf(o) === C.prototype</div><div class="line">o instanceof C;</div><div class="line"></div><div class="line">// false, because D.prototype is nowhere in o&apos;s prototype chain</div><div class="line">o instanceof D;</div></pre></td></tr></table></figure>
<h4 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a>Object.prototype.toString</h4><blockquote>
<p>那么我们有没有可以用来区分变量数据类型的方法呢，有，<code>Object.prototype.toString</code></p>
</blockquote>
<p>一些原始数据类型也有 <code>toString</code> 方法，但是通常他们的 <code>toString</code> 方法都是改造过的，不能进行 数据类型判断，所以我们需要用 <code>Object</code> 原型链上的 <code>toString</code> 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a = 1234</div><div class="line">a.toString() // &apos;1234&apos;</div><div class="line"></div><div class="line">Object.prototype.toString.call(a) // &quot;[object Number]&quot;</div></pre></td></tr></table></figure>
<p> 不同类型返回的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">1. 数值 [object Number]</div><div class="line">2. 字符串 [object String]</div><div class="line">3.布尔值 [object Boolean]</div><div class="line">4.undefined [object undefined]</div><div class="line">5.null  [object Null]</div><div class="line">6.数组 [object Array]</div><div class="line">7.arguments [object Arguments]</div><div class="line">8.函数 [object function]</div><div class="line">9.Error [object Error]</div><div class="line">10.Date [object Date]</div><div class="line">11.RegExp [object RegExp]</div><div class="line">12.其他对象 [object object]</div></pre></td></tr></table></figure>
<p>那么我们就能够通过 <code>Object.prototype.toString</code> 方法，封装一个可以判断变量数据类型的函数了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function type(obj) &#123;</div><div class="line">    return Object.prototype.toString.call(obj).slice(8, -1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">type(function()&#123;&#125;) //&quot;Function&quot;</div></pre></td></tr></table></figure>
<blockquote>
<p>这次我们从对象、函数、类型三方面入手了解了<code>javascript</code> 中容易被忽视或则说比较难理解的地方，我会继续将我在学习中积累的内容分享给大家，如果大家觉得文章有需要改进或则有其他想要了解的内容的，欢迎私信，评论或则微信我，我的微信是：646321933</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2018/03/28/sanya/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/28/sanya/" itemprop="url">
                  三亚之旅
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-28T16:31:57+08:00">
                2018-03-28
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2018/03/28/sanya/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/03/28/sanya/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>大家总说，身体和心灵需要有一个在路上。读书不一定所有的人都能喜欢，但是旅行绝对是每一个年龄阶段的人都不会拒绝的的一种亦或是放松亦或是长见识的方式，如果说优缺点的话，那应该就是心疼钱了。我很喜欢旅游，我觉得每年一次旅行是必要的。</p>
</blockquote>
<p>旅行一般我都是临时起意的，看到哪里的机票便宜了，就买了准备走，所以我还是比较倾向于不需要办签证的地方，比如济州岛，或则国内。这次我们去了三亚。</p>
<p>因为是自由行，去之前做了一些粗略的攻略，确定几个自己想要游玩的景点。但是这次行程除了入住的地方和攻略是一致的，其他的都没有按照攻略来。</p>
<p>攻略是按照窝蜂上的推荐景点排序进行筛选的，但是到三亚的时候，当地居民推荐了我去其他景点，游客少的，消费更低一些的。</p>
<p>机票是在携程上买的，杭州出发到海口，海口动车到三亚（别问为啥不直飞，因为穷，哈哈哈）海口的火车站和飞机场在一个地方，掐着点的话，下飞机一个半小时就能到三亚了。担心飞机晚点问题，还有到机场需要去提行李，所以没有提前买动车票，到站买了最近一趟去三亚，所以下飞机后我们在火车站逗留了大概一个小时才出发去三亚。</p>
<h2 id="D1"><a href="#D1" class="headerlink" title="D1"></a>D1</h2><p>飞机是上午6点出发，8点55到海口，坐动车到三亚的时候已经是12点了，入住房间刚好，我们把房间定在三亚湾，190 一晚的海景房（一室一厅一厨一卫）感觉性价超级高，三亚的物价没有特别高，溜达的时候，有看到布丁酒店100多一晚的房间，但是不是在海边，具体房间是怎么样的，我也不太清楚，如果预算不够的话，可以住这种的。</p>
<p>因为出门就能到海边，虽然肚子又点饿，我们没有马上去觅食，而是去海边小坐了一会，没有坐太久，因为大中午的实在太热了，哈哈。在沙滩上看到了几个皮肤十分黑的男人在光着屁股晒太阳，以为是外国黑人，还在感叹他们奔放的时候发现其实是三亚本地人，脸上3条黑线</p>
<p>三亚湾上街购物和吃放也很方便，过一条马路就能到热闹的地方去，因为没有在淘宝上挑到自己喜欢的草帽，所以没有带，三亚很晒，所以在逛当地礼品店的时候买了一个，15块钱，和淘宝的价格差不多，没有很宰客，后面又买了一个自拍杆，20块，比淘宝上买略贵一些。</p>
<p>中午随便吃的重庆小面，2人吃了30多，这个比在杭州吃的时候贵一丢丢，在杭州吃可能 20多就搞定了。也说不上来，可能这个不是三亚本地的吃食吧，所以要贵一些，三亚的海鲜和热带水果还是很便宜的。</p>
<p>因为第一天早上为了赶飞机，3点多就起来了，我们两个都有点累，本来这一天也没有很特别的行程安排，所以我们就在酒店睡了一下午，晚上的时候本来想随意吃点，逛到了海鲜加工市场，就在市场里买了活海鲜加工着吃，2个人一共吃了300块，因为没有挑加工店，随意没有特别好吃也没有特别难吃，如果你们去的话，还是建议去第一海鲜市场，挑个开的时间长的加工店，</p>
<p>晚上我们吃完饭又去沙滩上坐了会，穿着拖鞋去海棠踏浪。快到10点的时候准备回房间，在沿着海滩边上的路牙上有好多大姐大妈在按摩，20块钱可以按20分钟，挺舒服的。</p>
<p><img src="/images/travel/yz.jpeg" alt="三亚路牙子"></p>
<h2 id="D2"><a href="#D2" class="headerlink" title="D2"></a>D2</h2><p>第二天，我们睡到9点起，打算坐公交车去亚龙湾潜水，在等公交的时候有个大叔问我们去哪，可以送。开始以为是黄牛，有点不太想搭理他。他和我们说可以送我们去亚龙湾，带我们去售票点买票，他们是通过带人去售票店买票积分，然后领礼品的。他和我们说潜水的话，亚龙湾398可以潜，水上项目想多玩点的话，可以去西岛，西岛的套票是 980 可以玩18项。送我们去西岛的话只要每人5块的路费</p>
<p>我们想着，反正也来了，就去多玩点吧，亚龙湾是在三亚的海岸边，海水可能也会比较浑浊，出海到岛上潜水体验应该能好点。于是我们坐了他老婆的车到西岛售票处，车子沿着海边开了半个小时左右，5块一个人的路费真是良心价。</p>
<p>到西岛后，我们买了980 的套票，里面包括珊瑚礁潜水，保礁潜水，香蕉船，飞鱼船，快艇，观光艇，划伞，中午的自助餐，鱼疗和台风体验等小项目，也不是所有的项目都好玩，一半一半吧，反正这么买套票我觉得是十分划算的</p>
<p>我们上岛第一个玩的项目是潜水，潜水有潜水服，但是你还是要穿自己的泳衣在里面，玩其他水上项目也会把衣服弄湿，所以潜完之后，你可以不换衣服，直接去玩其他水上项目了。</p>
<p>潜水很好玩，潜水前教练会教你一些简单的手势动作，全程教练牵着你移动，所以即使不会游泳也没有关系。潜水的时候最好自己带着鱼食，吸引小鱼。虽然我没有买，但是和我一起潜的其他同学买了，蹭了一把鱼食，小鱼在自己周边游动，十分有趣，壮观</p>
<p>潜完水，我们衣服没换去吃了自助餐，然后去划伞，划伞这个项目说不上好玩不好玩，就是快艇拉着你在海上兜一圈，不是很刺激，看起来很好玩，实际也没有特别好玩，如果没买套票的话，不是很建议单买着玩</p>
<p>然后我们去坐了香蕉船，飞羽船，快艇，基本上都是你坐在气垫小船上被快艇拉着在海上兜一圈，速度比较快，挺刺激的。（香蕉船千万别坐第一排，海水很咸，十分辣眼睛，一路海水打在脸上眼睛上，全程睁不开眼睛，飞鱼船可以坐第一排，不会有很多水贱上来，第一排视野还算开阔的）</p>
<p>水上项目都在一个地方，我们玩了全部的水上项目基本也到下午3点钟了，去做了鱼疗足浴，其实是热带小鱼吃你的角质，脚放进去会痒痒的，但是还满舒服的。然后坐环岛电瓶去了牛岛，因为赶着要在6点前离岛，我们就再牛岛上随意逛了下，拍了几张照片。</p>
<p>出岛的时候人比较多，我们排队差不多排了半个小时，晚上回去的时候我问了下，打车去三亚湾要60多，不是很划算，我们去坐了公交车，在等公交的时候我买了芒果，10块钱2小袋，我数了一下，一共有11个手掌心这么大的芒果，而且十分甜，很好吃。</p>
<p>到酒店的时候差不多7点多，我们洗个澡出门觅食，找到一条小吃街，在解放路上，我们住的地方过去需要走15分钟，也算方便，吃了海鲜烧烤和清补凉臭豆腐，买了泡椒鸡爪，一个人50块钱管够了</p>
<p>吃完饭，我们照例去海滩边逛了下，躺一会，晚上的海滩真的太舒服了，让人想融化在沙滩上。等老了真心可以在海滩边买一套房子养老，哈哈哈。晚上的海滩很热闹，很多游客在踩水，拍婚纱照，还有当地的老人歌舞团的聚会活动，到处是欢声笑语。从海滩边回来，我们在路牙边做了马杀鸡，好多老阿姨按摩，20块钱可以按20分钟，不贵，很舒服，按完然后回去睡觉<br><img src="/images/travel/hb.jpeg" alt="三亚路牙子"></p>
<h2 id="D3"><a href="#D3" class="headerlink" title="D3"></a>D3</h2><p>前一天玩水玩的比较累，第二天10点才起来，按照原来的计划，是想去南山文化旅游区，那边的108米的海上观音很出名，但是后来没有去，也幸好没去，30多度在外面逛露天的景点实在不太合适，昨天玩水一起认识的几个小伙伴去了，他们和我说让我别去，他们就逛了10几分钟就走了，因为实在太热了</p>
<p>在我们不知道要去哪里的时候，昨天带我们去西岛的大姐发微信和我说，我们可以去热带雨林，20块钱一个人带我们玩一天，在景点买票就行。而且雨林里有丛林飞跃，是我很想玩的项目，于是我们去了呀渃哒，大姐和我们说这个在海南话里是 1，2，3 的意思。呀渃哒 的门票加丛林飞跃项目是 300块一人，后来我们又加了踏步戏水的项目，每人150。踏步戏水不是很建议玩，感觉比较像是团建，因为大家的身体素质不一样，景区不太敢开放太冒险的路段，所以不是很刺激，没有特别好玩。丛林飞跃就是玉林滑索项目，索道从一个山头到另一个山头，一共有130米，速度不是很快，但是在玉林中飞过，眺看整个玉林的样子真是很舒服，值得一玩。可惜就是不让带手机，索道的终点会有人给你拍照，照片是要钱的，要不要照片就看你个人意愿了，反正我是不太喜欢。</p>
<p>丛林飞跃之后可以在玉林里闲逛一会，景区会给散客一个电子讲解器，讲解到是挺详细的，反正我是没有耐心听下来，全程拍照瞎晃。只记住槟榔树在海南是一个很重要的文化，以前小伙子要爬49颗槟榔树才能取到老婆。</p>
<p>雨林很舒服，有身处大自然的感觉，值得去，反正我是觉得一天雨林一天海滩的玩耍方案挺合适的，到是海滩和雨林的景点是比较多的，除了我玩的几个，你们可以自由选择下</p>
<p>晚上到酒店，我们又重复了前一天的活动，小吃，海滩，马杀鸡</p>
<p><img src="/images/travel/rx.jpeg" alt="三亚路牙子"></p>
<h2 id="D4"><a href="#D4" class="headerlink" title="D4"></a>D4</h2><p>第四天，我们晚上11点的飞机，而且需要从三亚坐动车到海口机场，所以我们12点退了房子，打算继续在海滩边玩到下午5，6点再出发。不过现实总是没有想象的美好，30度的海滩，也热，我们差不多在海滩边逗留了1个小时，去吃了午饭买了些菠萝和泡面就公交到动车站避暑了。</p>
<p>我们没有提前买动车票，总是买的就近一般有座位的，4点从三亚触发，到海口的检完票的时候差不多8点了。逛了免税店，买了2千的面膜和洗面奶，9刚好9点多。在机场吃了泡面，玩机场农药就开始回城机票检票了</p>
<p>总得来说第四天，没有很紧张的行程，就是瞎逛，买东西，吃东西。三亚的景点都离得比价远，去一个景点公交都差不多要2个小时的样子，来回需要4个小时在路上。如果要赶着玩的话其实可以把行李寄存起来再玩一个景点。但是想着太累了，我们还是把时间留下去逛免税店了。</p>
<p><img src="/images/travel/by.jpeg" alt="三亚路牙子"></p>
<h2 id="装备"><a href="#装备" class="headerlink" title="装备"></a>装备</h2><p>以下我罗列的非必要，但是很有用，哈哈哈</p>
<table>
<thead>
<tr>
<th style="text-align:center">防晒</th>
<th style="text-align:center">记录旅程</th>
<th style="text-align:center">玩水</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">防晒霜</td>
<td style="text-align:center">自拍杆</td>
<td style="text-align:center">手机防水袋</td>
</tr>
<tr>
<td style="text-align:center">防晒外套</td>
<td style="text-align:center">美美的衣服</td>
<td style="text-align:center">拖鞋</td>
</tr>
<tr>
<td style="text-align:center">帽子</td>
<td style="text-align:center">墨镜</td>
<td style="text-align:center">钱</td>
</tr>
</tbody>
</table>
<h2 id="你可能想要知道的东西"><a href="#你可能想要知道的东西" class="headerlink" title="你可能想要知道的东西"></a>你可能想要知道的东西</h2><ol>
<li>我们190订的海景房，是在爱彼迎上定的，这个平台主打民宿所以比携程上便宜，平台注册链接 <a href="https://zh.airbnb.com/c/09425c" target="_blank" rel="external">https://zh.airbnb.com/c/09425c</a></li>
<li>三亚水果很便宜，最便宜的是在槟榔谷，10块钱能买5个菠萝。市区0块钱只能买3个，如果想买没有削皮的菠萝，可以去就近的菜市场</li>
<li>马杀鸡在三亚湾的海岸上，20块1次，可以按20分钟</li>
<li>如果你有其他的想问，可以私我像我，我的微信：646321933</li>
</ol>
<blockquote>
<p>我们的行程是4天3夜，如果有时间的话，建议还是6天5夜，这样能把大部分的景点覆盖到，蜈支洲岛，分界洲，南山文化旅游区，槟榔谷，国家森林公园都可以去走一走。三亚是个很舒服的城市，在三亚，你会感觉整个时间都慢下来，很舒服很放松，你会喜欢的</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2018/03/05/cookie-share/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/05/cookie-share/" itemprop="url">
                  web 浏览器指纹跨域共享
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-05T17:41:49+08:00">
                2018-03-05
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2018/03/05/cookie-share/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/03/05/cookie-share/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>概念：设备id 即设备指纹，用来表示用户设备的唯一性</p>
</blockquote>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近在做用户行为分析项目的开发，需要采集用户的设备信息，需要用设备指纹来唯一表示用户操作设备。web 存储都和浏览器相关，我们无法通过js 来标识一台电脑，只能以浏览器作为设备维度来采集设备信息。即用户电脑中一个浏览器就是一个设备。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>web 变量存储，我们第一时间想到的就是 cookie，sessionStorage，localStorage，但是这3种存储方式都和访问资源的域名相关。我们总不能每次访问一个网站就新建一个设备指纹吧，所以我们需要通过一个方法来跨域共享设备指纹</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>我们想到的方案是，通过嵌套 iframe 加载一个静态页面，在 iframe 上加载的域名上存储设备id，通过跨域共享变量获取设备id，共享变量的原理是采用了iframe 的 contentWindow通讯，通过 postMessage 获取事件状态，调用封装好的回调函数进行数据处理</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>SDK 采集端，调用方初始化的时候调用方法</p>
<pre><code>collect.setIframe = function () {
      var that = this
      var iframe = document.createElement(&apos;iframe&apos;)
      iframe.src = &quot;http://localhost:82/&quot;
      iframe.style = &apos;display:none&apos;
      document.body.appendChild(iframe)
      iframe.onload = function () {
        iframe.contentWindow.postMessage(&apos;loaded&apos;,&apos;*&apos;);
      }

      //监听message事件
      window.addEventListener(&quot;message&quot;, function(){
            that.deviceId = event.data.deviceId

            console.log(&apos;获取设备id&apos;,that.deviceId)

            sessionStorage.setItem(&apos;PageSessionID&apos;,helper.upid())
            helper.send(that.getParames(), that.eventUrl);
            helper.sendDevice(that.getDevice(), that.deviceUrl);
      }, false);
}
</code></pre><p>嵌套在 iframe 静态页面里的脚本</p>
<pre><code>&lt;script&gt;

     var getDeviceId = function() {
             return &apos;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&apos;.replace(/[xy]/g, function (c) {
                     var r = Math.random() * 16 | 0, v = c == &apos;x&apos; ? r : (r &amp; 0x3 | 0x8);
                     return v.toString(16);
             });
     };

     var hasCreated = false
     var _deviceId = &apos;&apos;
     if(document.cookie){
             document.cookie.split(&apos;;&apos;).forEach(function(i){
                     if(i.indexOf(&apos;deviceId&apos;)&gt;-1){
                             hasCreated = true
                             _deviceId = i.split(&apos;=&apos;)[1]
                     }
             })
     }

     if(!_deviceId &amp;&amp; (sessionStorage.getItem(&apos;deviceId&apos;)||localStorage.getItem(&apos;deviceId&apos;))){
             hasCreated = true
             _deviceId = sessionStorage.getItem(&apos;deviceId&apos;)||localStorage.getItem(&apos;deviceId&apos;)
     }


     if(!hasCreated) {
             _deviceId =  getDeviceId()
             document.cookie = &apos;deviceId=&apos; + _deviceId
             sessionStorage.setItem(&apos;deviceId&apos;,_deviceId)
             localStorage.setItem(&apos;deviceId&apos;,_deviceId)
     }

     //回调函数
     function receiveMessageFromIndex ( event ) {
             console.log( &apos;receiveMessageFromIndex&apos;, event )
             parent.postMessage( {deviceId: _deviceId}, &apos;*&apos;);
     }
     //监听message事件
     window.addEventListener(&quot;message&quot;, receiveMessageFromIndex, false);

 &lt;/script&gt;
</code></pre><h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><p><a href="http://cxh.me/2014/11/25/flash-shared-cookie/" target="_blank" rel="external">跨浏览器cookie</a><br><a href="http://www.freebuf.com/articles/web/139984.html" target="_blank" rel="external">跨浏览器指纹识别</a><br><a href="https://paper.seebug.org/229/" target="_blank" rel="external">浏览器指纹追踪</a><br><a href="https://rockjins.js.org/2017/05/05/2017-05-05-iframe-cross-domain-Communication" target="_blank" rel="external">使用postMessage解决iframe跨域通信问题</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage" target="_blank" rel="external">window.postMessage</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/bbt.jpeg"
               alt="bailinlin" />
          <p class="site-author-name" itemprop="name">bailinlin</p>
          <p class="site-description motion-element" itemprop="description">前端,白霸天,博客</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">18</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bailinlin</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"baibatian"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  








  
  

  

  

  

  


</body>
</html>
