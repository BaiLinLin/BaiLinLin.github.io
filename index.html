<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="前端,白霸天,博客">
<meta property="og:type" content="website">
<meta property="og:title" content="白霸天的博客">
<meta property="og:url" content="https://bailinlin.github.com/index.html">
<meta property="og:site_name" content="白霸天的博客">
<meta property="og:description" content="前端,白霸天,博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="白霸天的博客">
<meta name="twitter:description" content="前端,白霸天,博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://bailinlin.github.com/"/>





  <title> 白霸天的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">白霸天的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2018/08/23/efficiency-javascript/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/08/23/efficiency-javascript/" itemprop="url">
                  精读《高性能 javascript》
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-23T10:46:05+08:00">
                2018-08-23
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2018/08/23/efficiency-javascript/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/08/23/efficiency-javascript/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本期我来给大家推荐的书是《高性能JavaScript》,在这本书中我们能够了解 javascript 开发过程中的性能瓶颈,如何提升各方面的性能，包括代码的加载、运行、DOM交互、页面生存周期等。同样我们今天还是用思维导图的方式来精读一遍。（思维导图图片可能有点小，记得点开看，你会有所收获）</p>
<h3 id="加载和执行"><a href="#加载和执行" class="headerlink" title="加载和执行"></a>加载和执行</h3><p><img src="https://user-gold-cdn.xitu.io/2018/8/23/16564db7a9ce59fa?w=1451&amp;h=720&amp;f=jpeg&amp;s=166456" alt=""><br>管理浏览器中的 JavaScript 代码是个棘手的问题,因为代码执行阻塞了其他浏览器处理过程,诸如用户 界面绘制。每次遇到<code>&lt;script&gt;</code>标签,页面必须停下来等待代码下载(如果是外部的)并执行,然后再继续处 理页面其他部分。但是,有几种方法可以减少 JavaScript 对性能的影响:</p>
<ol>
<li>将所有<code>&lt;script&gt;</code>标签放置在页面的底部,紧靠 body 关闭标签<code>&lt;/body&gt;</code>的上方。此法可以保证页面在脚本 运行之前完成解析。</li>
<li>将脚本成组打包。页面的<code>&lt;script&gt;</code>标签越少,页面的加载速度就越快,响应也更加迅速。不论外部脚本 文件还是内联代码都是如此。</li>
</ol>
<p>有几种方法可以使用非阻塞方式下载 JavaScript:</p>
<ul>
<li>为<code>&lt;script&gt;</code>标签添加 defer 属性(只适用于 Internet Explorer 和 Firefox 3.5 以上版本)</li>
<li>动态创建<code>&lt;script&gt;</code>元素,用它下载并执行代码</li>
<li>用 XHR 对象下载代码,并注入到页面中</li>
</ul>
<p>通过使用上述策略,你可以极大提高那些大量使用 JavaScript 代码的网页应用的实际性能。</p>
<h3 id="数据存取"><a href="#数据存取" class="headerlink" title="数据存取"></a>数据存取</h3><p><img src="https://user-gold-cdn.xitu.io/2018/8/23/16564dbb8c76a74b?w=1451&amp;h=810&amp;f=jpeg&amp;s=201094" alt=""><br><img src="https://user-gold-cdn.xitu.io/2018/8/23/16564dbd2ec84a69?w=1451&amp;h=252&amp;f=jpeg&amp;s=52096" alt=""></p>
<p>在 JavaScript 中,数据存储位置可以对代码整体性能产生重要影响。有四种数据访问类型:直接量,变 量,数组项,对象成员。它们有不同的性能考虑。</p>
<p>直接量和局部变量访问速度非常快,数组项和对象成员需要更长时间。局部变量比域外变量快,因为它位于作用域链的第一个对象中。变量在作用域链中的位置越深,访问所需 的时间就越长。全局变量总是最慢的,因为它们总是位于作用域链的最后一环。避免使用 with 表达式,因为它改变了运行期上下文的作用域链。而且应当小心对待 try-catch 表达式的 catch 子句,因为它具有同样效果。嵌套对象成员会造成重大性能影响,尽量少用。</p>
<p>一个属性或方法在原形链中的位置越深,访问它的速度就越慢。一般来说,你可以通过这种方法提高 JavaScript 代码的性能:将经常使用的对象成员,数组项,和域外变 量存入局部变量中。然后,访问局部变量的速度会快于那些原始变量。通过使用这些策略,你可以极大地提高那些需要大量 JavaScript 代码的网页应用的实际性能。</p>
<h3 id="DOM-编程"><a href="#DOM-编程" class="headerlink" title="DOM 编程"></a>DOM 编程</h3><p><img src="https://user-gold-cdn.xitu.io/2018/8/23/16564dc0af32a177?w=1445&amp;h=655&amp;f=jpeg&amp;s=147902" alt=""><br><img src="https://user-gold-cdn.xitu.io/2018/8/23/16564dc20f9ebc7e?w=1445&amp;h=780&amp;f=jpeg&amp;s=145651" alt=""><br><img src="https://user-gold-cdn.xitu.io/2018/8/23/16564dc383373494?w=1454&amp;h=227&amp;f=jpeg&amp;s=49963" alt=""><br>DOM 访问和操作是现代网页应用中很重要的一部分。但每次你通过桥梁从 ECMAScript 岛到达 DOM 岛 时,都会被收取“过桥费”。为减少 DOM 编程中的性能损失,请牢记以下几点:</p>
<p>最小化 DOM 访问,在 JavaScript 端做尽可能多的事情。在反复访问的地方使用局部变量存放 DOM 引用.小心地处理 HTML 集合,因为他们表现出“存在性”,总是对底层文档重新查询。将集合的 length 属性缓 存到一个变量中,在迭代中使用这个变量。如果经常操作这个集合,可以将集合拷贝到数组中。</p>
<p>如果可能的话,使用速度更快的 API,诸如 querySelectorAll()和 firstElementChild。注意重绘和重排版;批量修改风格,离线操作 DOM 树,缓存并减少对布局信息的访问。动画中使用绝对坐标,使用拖放代理。使用事件托管技术最小化事件句柄数量。</p>
<h3 id="算法和流程控制"><a href="#算法和流程控制" class="headerlink" title="算法和流程控制"></a>算法和流程控制</h3><p><img src="https://user-gold-cdn.xitu.io/2018/8/23/16564dc5d3958528?w=1447&amp;h=620&amp;f=jpeg&amp;s=123570" alt=""><br><img src="https://user-gold-cdn.xitu.io/2018/8/23/16564dc7a75a0a9e?w=1446&amp;h=643&amp;f=jpeg&amp;s=154820" alt=""><br>正如其他编程语言,代码的写法和算法选用影响 JavaScript 的运行时间。与其他编程语言不同的是, JavaScript 可用资源有限,所以优化技术更为重要。</p>
<p>for,while,do-while 循环的性能特性相似,谁也不比谁更快或更慢。除非你要迭代遍历一个属性未知的对象,否则不要使用 for-in 循环。改善循环性能的最好办法是减少每次迭代中的运算量,并减少循环迭代次数。</p>
<p>一般来说,switch 总是比 if-else 更快,但并不总是最好的解决方法。当判断条件较多时,查表法比 if-else 或者 switch 更快。</p>
<p>浏览器的调用栈尺寸限制了递归算法在 JavaScript 中的应用;栈溢出错误导致其他代码也不能正常执行。如果你遇到一个栈溢出错误,将方法修改为一个迭代算法或者使用制表法可以避免重复工作。</p>
<p>运行的代码总量越大,使用这些策略所带来的性能提升就越明显。</p>
<h3 id="字符串和正则表达式"><a href="#字符串和正则表达式" class="headerlink" title="字符串和正则表达式"></a>字符串和正则表达式</h3><p><img src="https://user-gold-cdn.xitu.io/2018/8/23/16564dca14ea0fe2?w=1453&amp;h=741&amp;f=jpeg&amp;s=166876" alt=""><br><img src="https://user-gold-cdn.xitu.io/2018/8/23/16564dcbaa613217?w=1450&amp;h=842&amp;f=jpeg&amp;s=194367" alt=""><br>密集的字符串操作和粗浅地编写正则表达式可能是主要性能障碍,但本章中的建议可帮助您避免常见缺陷。当连接数量巨大或尺寸巨大的字符串时,数组联合是 IE7 和它的早期版本上唯一具有合理性能的方法。如果你不关心 IE7 和它的早期版本,数组联合是连接字符串最慢的方法之一。使用简单的+和+=取而代之, 可避免(产生)不必要的中间字符串。</p>
<p>回溯既是正则表达式匹配功能基本的组成部分,又是正则表达式影响效率的常见原因。回溯失控发生在正则表达式本应很快发现匹配的地方,因为某些特殊的匹配字符串动作,导致运行缓慢 甚至浏览器崩溃。避免此问题的技术包括:使相邻字元互斥,避免嵌套量词对一个字符串的相同部分多次 匹配,通过重复利用前瞻操作的原子特性去除不必要的回溯。</p>
<p>提高正则表达式效率的各种技术手段,帮助正则表达式更快地找到匹配,以及在非匹配位置上花费更少 时间(见《更多提高正则表达式效率的方法》)。正则表达式并不总是完成工作的最佳工具,尤其当你只是搜索一个文本字符串时。</p>
<p>虽然有很多方法来修整一个字符串,使用两个简单的正则表达式(一个用于去除头部空格,另一个用于 去除尾部空格)提供了一个简洁、跨浏览器的方法,适用于不同内容和长度的字符串。从字符串末尾开始 循环查找第一个非空格字符,或者在一个混合应用中将此技术与正则表达式结合起来,提供了一个很好的 替代方案,它很少受到字符串整体长度的影响。</p>
<h3 id="快速响应用户界面"><a href="#快速响应用户界面" class="headerlink" title="快速响应用户界面"></a>快速响应用户界面</h3><p><img src="https://user-gold-cdn.xitu.io/2018/8/23/16564dcd70084551?w=1446&amp;h=740&amp;f=jpeg&amp;s=159046" alt=""><br>JavaScript 和用户界面更新在同一个进程内运行,同一时刻只有其中一个可以运行。这意味着当 JavaScript 代码正在运行时,用户界面不能响应输入,反之亦然。有效地管理 UI 线程就是要确保 JavaScript 不能运行 太长时间,以免影响用户体验。最后,请牢记如下几点:</p>
<ol>
<li>JavaScript 运行时间不应该超过 100 毫秒。过长的运行时间导致 UI 更新出现可察觉的延迟,从而对整体 用户体验产生负面影响。</li>
<li>JavaScript 运行期间,浏览器响应用户交互的行为存在差异。无论如何,JavaScript 长时间运行将导致用 户体验混乱和脱节。</li>
<li>定时器可用于安排代码推迟执行,它使得你可以将长运行脚本分解成一系列较小的任务。</li>
</ol>
<p>网页工人线程是新式浏览器才支持的特性,它允许你在 UI 线程之外运行 JavaScript 代码而避免锁定 UI。网页应用程序越复杂,积极主动地管理 UI 线程就越显得重要。没有什么 JavaScript 代码可以重要到允 许影响用户体验的程度。</p>
<h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><p><img src="https://user-gold-cdn.xitu.io/2018/8/23/16564dcfbdf4fb98?w=1447&amp;h=791&amp;f=jpeg&amp;s=194798" alt=""><br><img src="https://user-gold-cdn.xitu.io/2018/8/23/16564dd131e6075d?w=1449&amp;h=848&amp;f=jpeg&amp;s=202612" alt=""><br>高性能 Ajax 包括:知道你项目的具体需求,选择正确的数据格式和与之相配的传输技术。</p>
<p>作为数据格式,纯文本和 HTML 是高度限制的,但它们可节省客户端的 CPU 周期。XML 被广泛应用 普遍支持,但它非常冗长且解析缓慢。JSON 是轻量级的,解析迅速(作为本地代码而不是字符串),交 互性与 XML 相当。字符分隔的自定义格式非常轻量,在大量数据集解析时速度最快,但需要编写额外的 程序在服务器端构造格式,并在客户端解析。</p>
<p>当从页面域请求数据时,XHR 提供最完善的控制和灵活性,尽管它将所有传入数据视为一个字符串, 这有可能降低解析速度。另一方面,动态脚本标签插入技术允许跨域请求和本地运行 JavaScript 和 JSON, 虽然它的接口不够安全,而且不能读取信息头或响应报文代码。多部分 XHR 可减少请求的数量,可在一次响应中处理不同的文件类型,尽管它不能缓存收到的响应报文。当发送数据时,图像灯标是最简单和最 有效的方法。XHR 也可用 POST 方法发送大量数据。</p>
<p>除这些格式和传输技术之外,还有一些准则有助于进一步提高 Ajax 的速度:</p>
<ol>
<li>减少请求数量,可通过 JavaScript 和 CSS 文件打包,或者使用 MXHR。</li>
<li>缩短页面的加载时间,在页面其它内容加载之后,使用 Ajax 获取少量重要文件。</li>
<li>确保代码错误不要直接显示给用户,并在服务器端处理错误。</li>
<li>学会何时使用一个健壮的 Ajax 库,何时编写自己的底层 Ajax 代码。</li>
</ol>
<p>Ajax 是提升你网站潜在性能之最大的改进区域之一,因为很多网站大量使用异步请求,又因为它提供 了许多不相关问题的解决方案,这些问题诸如,需要加载太多资源。对 XHR 的创造性应用是如此的与众 不同,它不是呆滞不友好的界面,而是响应迅速且高效的代名词;它不会引起用户的憎恨,谁见了它都会 爱上它。</p>
<h3 id="编程实践"><a href="#编程实践" class="headerlink" title="编程实践"></a>编程实践</h3><p><img src="https://user-gold-cdn.xitu.io/2018/8/23/16564dd6b39a18cd?w=1436&amp;h=686&amp;f=jpeg&amp;s=145779" alt=""></p>
<p>JavaScript 提出了一些独特的性能挑战,关系到你组织代码的方法。网页应用变得越来越高级,包含的 JavaScript 代码越来越多,出现了一些模式和反模式。请牢记以下编程经验:</p>
<ol>
<li>通过避免使用 eval_r()和 Function()构造器避免二次评估。此外,给 setTimeout()和 setInterval()传递函数参 数而不是字符串参数。</li>
<li>创建新对象和数组时使用对象直接量和数组直接量。它们比非直接量形式创建和初始化更快。</li>
<li>避免重复进行相同工作。当需要检测浏览器时,使用延迟加载或条件预加载。</li>
<li>当执行数学远算时,考虑使用位操作,它直接在数字底层进行操作。</li>
<li>原生方法总是比 JavaScript 写的东西要快。尽量使用原生方法。</li>
</ol>
<h3 id="构建并部署高性能-javascript-应用"><a href="#构建并部署高性能-javascript-应用" class="headerlink" title="构建并部署高性能 javascript 应用"></a>构建并部署高性能 javascript 应用</h3><p>开发和部署过程对基于 JavaScript 的应用程序可以产生巨大影响,最重要的几个步骤如下:</p>
<ol>
<li>合并 JavaScript 文件,减少 HTTP 请求的数量</li>
<li>使用 YUI 压缩器紧凑处理 JavaScript 文件</li>
<li>以压缩形式提供 JavaScript 文件(gzip 编码)</li>
<li>通过设置 HTTP 响应报文头使 JavaScript 文件可缓存,通过向文件名附加时间戳解决缓存问题</li>
<li>使用内容传递网络(CDN)提供 JavaScript 文件,CDN 不仅可以提高性能,它还可以为你管理压缩和缓 存</li>
</ol>
<p>所有这些步骤应当自动完成,不论是使用公开的开发工具诸如 Apache Ant,还是使用自定义的开发工具 以实现特定需求。如果你使这些开发工具为你服务,你可以极大改善那些大量使用 JavaScript 代码的网页 应用或网站的性能。</p>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>当网页或应用程序变慢时,分析网上传来的资源,分析脚本的运行性能,使你能够集中精力在那些需要 努力优化的地方。使用网络分析器找出加载脚本和其它页面资源的瓶颈所在,这有助于决定哪些脚本需要延迟加载,或者 进行进一步分析。传统的智慧告诉我们应尽量减少 HTTP 请求的数量,尽量延迟加载脚本以使页面渲染速度更快,向用户 提供更好的整体体验。使用性能分析器找出脚本运行时速度慢的部分,检查每个函数所花费的时间,以及函数被调用的次数, 通过调用栈自身提供的一些线索来找出哪些地方应当努力优化。虽然花费时间和调用次数通常是数据中最有价值的点,还是应当仔细察看函数的调用过程,可能发现其 它优化方法。这些工具在那些现代代码所要运行的编程环境中不再神秘。在开始优化工作之前使用它们,确保开发时 间用在解决问题的刀刃上。</p>
<h3 id="😊往期的读书笔记-amp-amp-技术文章"><a href="#😊往期的读书笔记-amp-amp-技术文章" class="headerlink" title="😊往期的读书笔记 &amp;&amp; 技术文章"></a>😊往期的读书笔记 &amp;&amp; 技术文章</h3><blockquote>
<p>为了系统的串联前端知识，我平时喜欢用思维导图来记录读书笔记，我在 <a href="https://github.com/bailinlin/Awsome-Front-End-Xmind" target="_blank" rel="external">github</a> 建了仓库放这些思维导图的原件，和读书笔记。如果你也喜欢用思维导图的方式来记录读书笔记，也欢迎和我一同维护这个仓库，欢迎留言或则微信（646321933）与我交流</p>
</blockquote>
<p><a href="https://juejin.im/post/5b0cafad51882515624dc6d2" target="_blank" rel="external">精读《你不知道的 javascript（上卷）》</a></p>
<p><a href="https://juejin.im/post/5b2a07c16fb9a00e36425ef0" target="_blank" rel="external">精读《你不知道的javascript》中卷</a></p>
<p><a href="https://juejin.im/post/5b1a18de6fb9a01e312828dd" target="_blank" rel="external">精读《深入浅出Node.js》</a></p>
<p><a href="https://juejin.im/post/5b32f82a518825749e4a218b" target="_blank" rel="external">精读《图解HTTP》</a></p>
<p><a href="https://juejin.im/post/5b1f7e62e51d45068a6cb98f" target="_blank" rel="external">javascript 垃圾回收算法</a></p>
<p><a href="https://juejin.im/post/5ae95896f265da0b84553bd7" target="_blank" rel="external">你需要知道的单页面路由实现原理</a></p>
<p><a href="https://juejin.im/post/5afe7ec7518825426f3104cf" target="_blank" rel="external">javascript 实现高仿 growingIO</a></p>
<p><a href="https://juejin.im/post/5b6945b2f265da0f5d4cf64a" target="_blank" rel="external">新鲜出炉的8月前端面试题</a></p>
<p><a href="https://github.com/bailinlin/Awsome-Front-End-Xmind" target="_blank" rel="external">思维导图下载地址</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2018/08/07/interview/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/08/07/interview/" itemprop="url">
                  新鲜出炉的8月前端面试题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-07T10:50:11+08:00">
                2018-08-07
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2018/08/07/interview/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/08/07/interview/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近参加了几场面试，积累了一些高频面试题，我把面试题分为两类，一种是基础试题: 主要考察前端技基础是否扎实，是否能够将前端知识体系串联。一种是开放式问题: 考察业务积累，是否有自己的思考，思考问题的方式，这类问题没有标准答案。</p>
<h3 id="基础题"><a href="#基础题" class="headerlink" title="基础题"></a>基础题</h3><blockquote>
<p>题目的答案提供了一个思考的方向，答案不一定正确全面，有错误的地方欢迎大家请在评论中指出，共同进步。</p>
</blockquote>
<h4 id="怎么去设计一个组件封装"><a href="#怎么去设计一个组件封装" class="headerlink" title="怎么去设计一个组件封装"></a>怎么去设计一个组件封装</h4><ol>
<li>组件封装的目的是为了重用，提高开发效率和代码质量</li>
<li>低耦合，单一职责，可复用性，可维护性</li>
<li><a href="ijse blog http://ijser.cn/2017-06-25-web-component-design-in-front-end/">前端组件化设计思路</a></li>
</ol>
<h4 id="js-异步加载的方式"><a href="#js-异步加载的方式" class="headerlink" title="js 异步加载的方式"></a>js 异步加载的方式</h4><ol>
<li>渲染引擎遇到 script 标签会停下来，等到执行完脚本，继续向下渲染</li>
<li>defer 是“渲染完再执行”，async 是“下载完就执行”，defer 如果有多个脚本，会按照在页面中出现的顺序加载，多个async 脚本不能保证加载顺序</li>
<li>加载 es6模块的时候设置 type=module，异步加载不会造成阻塞浏览器，页面渲染完再执行，可以同时加上async属性，异步执行脚本（利用顶层的this等于undefined这个语法点，可以侦测当前代码是否在 ES6 模块之中）</li>
</ol>
<h4 id="css-动画和-js-动画的差异"><a href="#css-动画和-js-动画的差异" class="headerlink" title="css 动画和 js 动画的差异"></a>css 动画和 js 动画的差异</h4><ol>
<li>代码复杂度，js 动画代码相对复杂一些</li>
<li>动画运行时，对动画的控制程度上，js 能够让动画，暂停，取消，终止，css动画不能添加事件</li>
<li>动画性能看，js 动画多了一个js 解析的过程，性能不如 css 动画好</li>
</ol>
<h4 id="XSS-与-CSRF-两种跨站攻击"><a href="#XSS-与-CSRF-两种跨站攻击" class="headerlink" title="XSS 与 CSRF 两种跨站攻击"></a>XSS 与 CSRF 两种跨站攻击</h4><ol>
<li>xss 跨站脚本攻击，主要是前端层面的，用户在输入层面插入攻击脚本，改变页面的显示，或则窃取网站 cookie，预防方法：不相信用户的所有操作，对用户输入进行一个转义，不允许 js 对 cookie 的读写</li>
<li>csrf 跨站请求伪造，以你的名义，发送恶意请求，通过 cookie 加参数等形式过滤</li>
<li>我们没法彻底杜绝攻击，只能提高攻击门槛</li>
</ol>
<h4 id="事件委托，目的，功能，写法"><a href="#事件委托，目的，功能，写法" class="headerlink" title="事件委托，目的，功能，写法"></a>事件委托，目的，功能，写法</h4><ol>
<li>把一个或者一组元素的事件委托到它的父层或者更外层元素上</li>
<li>优点，减少内存消耗，动态绑定事件</li>
<li>target 是触发事件的最具体的元素，currenttarget是绑定事件的元素(在函数中一般等于this)</li>
<li><a href="https://zhuanlan.zhihu.com/p/26536815" target="_blank" rel="external">JavaScript 事件委托详解</a></li>
</ol>
<h4 id="线程，进程"><a href="#线程，进程" class="headerlink" title="线程，进程"></a>线程，进程</h4><ol>
<li>线程是最小的执行单元，进程是最小的资源管理单元</li>
<li>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程</li>
</ol>
<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><ol>
<li>当系统面临大量用户访问，负载过高的时候，通常会使用增加服务器数量来进行横向扩展，使用集群和负载均衡提高整个系统的处理能力</li>
<li><a href="https://www.zhihu.com/question/22610352" target="_blank" rel="external">服务器集群负载均衡原理？</a></li>
</ol>
<h4 id="什么是CDN缓存"><a href="#什么是CDN缓存" class="headerlink" title="什么是CDN缓存"></a>什么是CDN缓存</h4><ol>
<li>CDN 是一种部署策略，根据不同的地区部署类似nginx 这种服务服务，会缓存静态资源。前端在项目优化的时候，习惯在讲台资源上加上一个 hash 值，每次更新的时候去改变这个 hash，hash 值变化的时候，服务会去重新取资源</li>
<li>(CDN)是一个经策略性部署的整体系统，包括分布式存储、负载均衡、网络请求的重定向和内容管理4个要件</li>
<li><a href="https://baike.baidu.com/item/CDN" target="_blank" rel="external">CDN_百度百科</a></li>
</ol>
<h4 id="闭包的写法，闭包的作用，闭包的缺点"><a href="#闭包的写法，闭包的作用，闭包的缺点" class="headerlink" title="闭包的写法，闭包的作用，闭包的缺点"></a>闭包的写法，闭包的作用，闭包的缺点</h4><ol>
<li>使用闭包的目的——隐藏变量，间接访问一个变量,在定义函数的词法作用域外，调用函数</li>
<li>闭包的内存泄露，是IE的一个 bug，闭包使用完成之后，收回不了闭包的引用，导致内存泄露</li>
<li><a href="https://zhuanlan.zhihu.com/p/22486908?refer=study-fe" target="_blank" rel="external">「每日一题」JS 中的闭包是什么？</a></li>
<li><a href="http://www.cnblogs.com/rubylouvre/p/3345294.html" target="_blank" rel="external">闭包造成内存泄露的实验</a></li>
</ol>
<h4 id="跨域问题，谁限制的跨域，怎么解决"><a href="#跨域问题，谁限制的跨域，怎么解决" class="headerlink" title="跨域问题，谁限制的跨域，怎么解决"></a>跨域问题，谁限制的跨域，怎么解决</h4><ol>
<li>浏览器的同源策略导致了跨域</li>
<li>用于隔离潜在恶意文件的重要安全机制</li>
<li>[jsonp ，允许 script 加载第三方资源]<a href="https://segmentfault.com/a/1190000008445998" target="_blank" rel="external">https://segmentfault.com/a/1190000008445998</a></li>
<li>nginx 反向代理（nginx 服务内部配置 Access-Control-Allow-Origin *）</li>
<li>cors 前后端协作设置请求头部，Access-Control-Allow-Origin  等头部信息</li>
<li>iframe 嵌套通讯，postmessage</li>
</ol>
<h4 id="javascript-中常见的内存泄露陷阱"><a href="#javascript-中常见的内存泄露陷阱" class="headerlink" title="javascript 中常见的内存泄露陷阱"></a>javascript 中常见的内存泄露陷阱</h4><ol>
<li>内存泄露会导致一系列问题，比如：运行缓慢，崩溃，高延迟</li>
<li>内存泄露是指你用不到（访问不到）的变量，依然占居着内存空间，不能被再次利用起来</li>
<li>意外的全局变量，这些都是不会被回收的变量（除非设置 null 或者被重新赋值），特别是那些用来临时存储大量信息的变量</li>
<li>周期函数一直在运行，处理函数并不会被回收，jq 在移除节点前都会，将事件监听移除</li>
<li>js 代码中有对 DOM 节点的引用，dom 节点被移除的时候，引用还维持</li>
<li><a href="http://web.jobbole.com/88463/" target="_blank" rel="external">JavaScript 中 4 种常见的内存泄露陷阱</a></li>
</ol>
<h4 id="babel把ES6转成ES5或者ES3之类的原理是什么"><a href="#babel把ES6转成ES5或者ES3之类的原理是什么" class="headerlink" title="babel把ES6转成ES5或者ES3之类的原理是什么"></a>babel把ES6转成ES5或者ES3之类的原理是什么</h4><ol>
<li>它就是个编译器，输入语言是ES6+，编译目标语言是ES5</li>
<li><a href="thejameskyle/the-super-tiny-compiler">babel 官方工作原理</a></li>
<li>解析：将代码字符串解析成抽象语法树</li>
<li>变换：对抽象语法树进行变换操作</li>
<li>再建：根据变换后的抽象语法树再生成代码字符串</li>
</ol>
<h4 id="Promise-模拟终止"><a href="#Promise-模拟终止" class="headerlink" title="Promise 模拟终止"></a>Promise 模拟终止</h4><ol>
<li>当新对象保持“pending”状态时，原Promise链将会中止执行。</li>
<li>return new Promise(()=&gt;{});  // 返回“pending”状态的Promise对象</li>
</ol>
<h4 id="promise-放在try-catch里面有什么结果"><a href="#promise-放在try-catch里面有什么结果" class="headerlink" title="promise 放在try catch里面有什么结果"></a>promise 放在try catch里面有什么结果</h4><ol>
<li>Promise 对象的错误具有冒泡性质，会一直向后传递，直到被捕获为止，也即是说，错误总会被下一个catch语句捕获</li>
<li>当Promise链中抛出一个错误时，错误信息沿着链路向后传递，直至被捕获</li>
</ol>
<h4 id="网站性能优化"><a href="#网站性能优化" class="headerlink" title="网站性能优化"></a>网站性能优化</h4><ol>
<li>http 请求方面，减少请求数量，请求体积，对应的做法是，对项目资源进行压缩，控制项目资源的 dns 解析在2到4个域名，提取公告的样式，公共的组件，雪碧图，缓存资源，</li>
<li>压缩资源，提取公共资源压缩，提取 css ，js 公共方法</li>
<li>不要缩放图片，使用雪碧图，使用字体图表（阿里矢量图库）</li>
<li>使用 CDN，抛开无用的 cookie</li>
<li>减少重绘重排，CSS属性读写分离，最好不要用js 修改样式，dom 离线更新，渲染前指定图片的大小</li>
<li>js 代码层面的优化，减少对字符串的计算，合理使用闭包，首屏的js 资源加载放在最底部</li>
</ol>
<h4 id="js-自定义事件实现"><a href="#js-自定义事件实现" class="headerlink" title="js 自定义事件实现"></a>js 自定义事件实现</h4><ol>
<li>原生提供了3个方法实现自定义事件</li>
<li>createEvent，设置事件类型，是 html 事件还是 鼠标事件</li>
<li>initEvent  初始化事件，事件名称，是否允许冒泡，是否阻止自定义事件</li>
<li>dispatchEvent  触发事件</li>
</ol>
<h4 id="angular-双向数据绑定与vue数据的双向数据绑定"><a href="#angular-双向数据绑定与vue数据的双向数据绑定" class="headerlink" title="angular 双向数据绑定与vue数据的双向数据绑定"></a>angular 双向数据绑定与vue数据的双向数据绑定</h4><ol>
<li>二者都是 MVVM 模式开发的典型代表</li>
<li>angular 是通过脏检测实现，angular 会将 UI 事件，请求事件，settimeout 这类延迟，的对象放入到事件监测的脏队列，当数据变化的时候，触发 $diget 方法进行数据的更新，视图的渲染</li>
<li>vue 通过数据属性的数据劫持和发布订阅的模式实现，大致可以理解成由3个模块组成，observer 完成对数据的劫持，compile 完成对模板片段的渲染，watcher 作为桥梁连接二者，订阅数据变化及更新视图</li>
</ol>
<h4 id="get与post-通讯的区别"><a href="#get与post-通讯的区别" class="headerlink" title="get与post 通讯的区别"></a>get与post 通讯的区别</h4><ol>
<li>Get 请求能缓存，Post 不能</li>
<li>Post 相对 Get 安全一点点，因为Get 请求都包含在 URL 里，且会被浏览器保存历史纪录，Post 不会，但是在抓包的情况下都是一样的。</li>
<li>Post 可以通过 request body来传输比 Get 更多的数据，Get 没有这个技术</li>
<li>URL有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的</li>
<li>Post 支持更多的编码类型且不对数据类型限制</li>
</ol>
<h4 id="有没有去研究webpack的一些原理和机制，怎么实现的"><a href="#有没有去研究webpack的一些原理和机制，怎么实现的" class="headerlink" title="有没有去研究webpack的一些原理和机制，怎么实现的"></a>有没有去研究webpack的一些原理和机制，怎么实现的</h4><ol>
<li>解析webpack配置参数，合并从shell传入和webpack.config.js文件里配置的参数，生产最后的配置结果。</li>
<li>注册所有配置的插件，好让插件监听webpack构建生命周期的事件节点，以做出对应的反应。</li>
<li>从配置的entry入口文件开始解析文件构建AST语法树，找出每个文件所依赖的文件，递归下去。</li>
<li>在解析文件递归的过程中根据文件类型和loader配置找出合适的loader用来对文件进行转换。</li>
<li>递归完后得到每个文件的最终结果，根据entry配置生成代码块chunk。</li>
<li>输出所有chunk到文件系统。</li>
</ol>
<h4 id="ES6模块与CommonJS模块的差异"><a href="#ES6模块与CommonJS模块的差异" class="headerlink" title="ES6模块与CommonJS模块的差异"></a>ES6模块与CommonJS模块的差异</h4><ol>
<li>CommonJs 模块输出的是一个值的拷贝，ES6模块输出的是一个值的引用</li>
<li>CommonJS 模块是运行时加载，ES6模块是编译时输出接口</li>
<li>ES6输入的模块变量，只是一个符号链接，所以这个变量是只读的，对它进行重新赋值就会报错</li>
</ol>
<h4 id="模块加载AMD，CMD，CommonJS-Modules-2-0-规范"><a href="#模块加载AMD，CMD，CommonJS-Modules-2-0-规范" class="headerlink" title="模块加载AMD，CMD，CommonJS Modules/2.0 规范"></a>模块加载AMD，CMD，CommonJS Modules/2.0 规范</h4><ol>
<li>这些规范的目的都是为了 JavaScript 的模块化开发，特别是在浏览器端的</li>
<li>对于依赖的模块，AMD 是提前执行，CMD 是延迟执行</li>
<li>CMD 推崇依赖就近，AMD 推崇依赖前置</li>
</ol>
<h4 id="Node-事件循环，js-事件循环差异"><a href="#Node-事件循环，js-事件循环差异" class="headerlink" title="Node 事件循环，js 事件循环差异"></a>Node 事件循环，js 事件循环差异</h4><ol>
<li>Node.js 的事件循环分为6个阶段</li>
<li>浏览器和Node 环境下，microtask 任务队列的执行时机不同<ul>
<li>Node.js中，microtask 在事件循环的各个阶段之间执行</li>
<li>浏览器端，microtask 在事件循环的 macrotask 执行完之后执行</li>
</ul>
</li>
<li>递归的调用process.nextTick()会导致I/O starving，官方推荐使用setImmediate()</li>
</ol>
<h4 id="浅拷贝和深拷贝的问题"><a href="#浅拷贝和深拷贝的问题" class="headerlink" title="浅拷贝和深拷贝的问题"></a>浅拷贝和深拷贝的问题</h4><ol>
<li>深拷贝和浅拷贝是只针对Object和Array这样的复杂类型的</li>
<li>也就是说a和b指向了同一块内存，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝</li>
<li>浅拷贝， ”Object.assign() 方法用于将所有可枚举的属性的值从一个或多个源对象复制到目标对象。它将返回目标对象</li>
<li>深拷贝，JSON.parse()和JSON.stringify()给了我们一个基本的解决办法。但是函数不能被正确处理</li>
</ol>
<h3 id="开放性问题"><a href="#开放性问题" class="headerlink" title="开放性问题"></a>开放性问题</h3><blockquote>
<p>开放性问题主要是考察候选人业务积累，是否有自己的思考，思考问题的方式，没有标准答案。不过有些问题挺刁的，哈哈哈哈，比如：”  你见过的最好的代码是什么？ “总之提前准备下没错。</p>
</blockquote>
<ol>
<li>先自我介绍一下，说一下项目的技术栈，以及项目中遇到的一些问题</li>
<li>从整体中，看你对项目的认识，框架的认识和自己思考</li>
<li>项目中有没有遇到什么难点，怎么解决</li>
<li>如果你在创业公司你怎么从0开始做（选择什么框架，选择什么构建工具）</li>
<li>说一下你项目中用到的技术栈，以及觉得得意和出色的点，以及让你头疼的点，怎么解决的</li>
<li>一个业务场景，面对产品不断迭代，以及需求的变动该怎么应对，具体技术方案实现</li>
<li>你的学习来源是什么</li>
<li>你觉得哪个框架比较好，好在哪里</li>
<li>你觉得最难得技术难点是什么</li>
<li>你见过的最好的代码是什么</li>
</ol>
<h3 id="😊往期的读书笔记"><a href="#😊往期的读书笔记" class="headerlink" title="😊往期的读书笔记"></a>😊往期的读书笔记</h3><blockquote>
<p>为了系统的串联前端知识，我平时喜欢用思维导图来记录读书笔记，我在 <a href="https://github.com/bailinlin/Awsome-Front-End-Xmind" target="_blank" rel="external">github</a> 建了仓库放这些思维导图的原件，和读书笔记。如果你也喜欢用思维导图的方式来记录读书笔记，也欢迎和我一同维护这个仓库，欢迎留言或则微信（646321933）与我交流</p>
</blockquote>
<p><a href="https://juejin.im/post/5b0cafad51882515624dc6d2" target="_blank" rel="external">精读《你不知道的 javascript（上卷）》</a></p>
<p><a href="https://juejin.im/post/5b2a07c16fb9a00e36425ef0" target="_blank" rel="external">精读《你不知道的javascript》中卷</a></p>
<p><a href="https://juejin.im/post/5b1a18de6fb9a01e312828dd" target="_blank" rel="external">精读《深入浅出Node.js》</a></p>
<p><a href="https://juejin.im/post/5b1f7e62e51d45068a6cb98f" target="_blank" rel="external">javascript 垃圾回收算法</a></p>
<p><a href="https://juejin.im/post/5b32f82a518825749e4a218b" target="_blank" rel="external">精读《图解HTTP》</a></p>
<p><a href="https://github.com/bailinlin/Awsome-Front-End-Xmind" target="_blank" rel="external">思维导图下载地址</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2018/07/05/jianrong/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/07/05/jianrong/" itemprop="url">
                  如何机智地回答浏览器兼容性问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-05T10:31:52+08:00">
                2018-07-05
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2018/07/05/jianrong/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/07/05/jianrong/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>有过面试经验的同学应该都被问过浏览器兼容性的问题，对于面试官的问题，常常猝不及防，因为通常他们都是这么问的。”来谈谈浏览器兼容的问题吧”，”你对浏览器的兼容性有了解过吗”，那么如何才是我们正确回答这个问题的姿势呢。</p>
<blockquote>
<p>虽然面试官的问题十分的笼统，浏览器的兼容性无非还是样式兼容性（css），交互兼容性（javascript），浏览器 hack 三个方面。</p>
</blockquote>
<h3 id="样式兼容性（css）方面"><a href="#样式兼容性（css）方面" class="headerlink" title="样式兼容性（css）方面"></a>样式兼容性（css）方面</h3><p><img src="https://user-gold-cdn.xitu.io/2018/7/5/16468bfe8343415c?w=1152&amp;h=412&amp;f=jpeg&amp;s=257125" alt=""></p>
<ol>
<li><p>因为历史原因，不同的浏览器样式存在差异，可以通过 Normalize.css 抹平差异，也可以定制自己的 reset.css，例如通过通配符选择器，全局重置样式</p>
<pre><code>* { margin: 0; padding: 0; }
</code></pre></li>
<li><p>在CSS3还没有成为真正的标准时，浏览器厂商就开始支持这些属性的使用了。CSS3样式语法还存在波动时，浏览器厂商提供了针对浏览器的前缀，直到现在还是有部分的属性需要加上浏览器前缀。在开发过程中我们一般通过IDE开发插件、css 预处理器以及前端自动化构建工程帮我们处理。</p>
<p> 浏览器内核与前缀的对应关系如下</p>
<p> 内核 | 主要代表的浏览器 | 前缀<br> :-: | :-: | :-:<br> Trident | IE浏览器| -ms<br> Gecko| Firefox| -moz<br> Presto| Opera | -o<br> Webkit|Chrome和Safari|-webkit</p>
</li>
<li><p>在还原设计稿的时候我们常常会需要用到透明属性，所以解决 IE9 以下浏览器不能使用 opacit。</p>
</li>
</ol>
<pre><code>opacity: 0.5;
filter: alpha(opacity = 50); //IE6-IE8我们习惯使用filter滤镜属性来进行实现
filter: progid:DXImageTransform.Microsoft.Alpha(style = 0, opacity = 50); //IE4-IE9都支持滤镜写法progid:DXImageTransform.Microsoft.Alpha(Opacity=xx)
</code></pre><h3 id="交互兼容性（javascript）"><a href="#交互兼容性（javascript）" class="headerlink" title="交互兼容性（javascript）"></a>交互兼容性（javascript）</h3><p><img src="https://user-gold-cdn.xitu.io/2018/7/5/16468c023f296879?w=1272&amp;h=678&amp;f=jpeg&amp;s=332606" alt=""></p>
<ol>
<li>事件兼容的问题，我们通常需要会封装一个适配器的方法，过滤事件句柄绑定、移除、冒泡阻止以及默认事件行为处理</li>
</ol>
<pre><code>var  helper = {}

//绑定事件
helper.on = function(target, type, handler) {
    if(target.addEventListener) {
        target.addEventListener(type, handler, false);
    } else {
        target.attachEvent(&quot;on&quot; + type,
            function(event) {
                return handler.call(target, event);
            }, false);
    }
};

//取消事件监听
helper.remove = function(target, type, handler) {
    if(target.removeEventListener) {
        target.removeEventListener(type, handler);
    } else {
        target.detachEvent(&quot;on&quot; + type,
        function(event) {
            return handler.call(target, event);
        }, true);
    }
};
</code></pre><ol>
<li><p>new Date()构造函数使用，’2018-07-05’是无法被各个浏览器中，使用new Date(str)来正确生成日期对象的。 正确的用法是’2018/07/05’.</p>
</li>
<li><p>获取 scrollTop 通过 document.documentElement.scrollTop 兼容非chrome浏览器</p>
<pre><code>var scrollTop = document.documentElement.scrollTop||document.body.scrollTop;
</code></pre></li>
</ol>
<h3 id="浏览器-hack"><a href="#浏览器-hack" class="headerlink" title="浏览器 hack"></a>浏览器 hack</h3><p><img src="https://user-gold-cdn.xitu.io/2018/7/5/16468c060484968d?w=985&amp;h=393&amp;f=jpeg&amp;s=167570" alt=""></p>
<ol>
<li>快速判断 IE 浏览器版本</li>
</ol>
<pre><code>&lt;!--[if IE 8]&gt; ie8 &lt;![endif]--&gt;

&lt;!--[if IE 9]&gt; 骚气的 ie9 浏览器 &lt;![endif]--&gt;
</code></pre><ol>
<li><p>判断是否是 Safari 浏览器</p>
<pre><code>/* Safari */
var isSafari = /a/.__proto__==&apos;//&apos;;
</code></pre></li>
<li><p>判断是否是 Chrome 浏览器</p>
<pre><code>/* Chrome */
var isChrome = Boolean(window.chrome);
</code></pre></li>
</ol>
<h3 id="身段不能掉，我们是个有逼格的前端"><a href="#身段不能掉，我们是个有逼格的前端" class="headerlink" title="身段不能掉，我们是个有逼格的前端"></a>身段不能掉，我们是个有逼格的前端</h3><p>“什么？你们公司要兼容IE6，我们今天的面试就到这里为止吧，再见”。现在如果还有哪个公司要兼容IE6的话就不要去了，开发起来得多不幸福。</p>
<h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><p><a href="https://www.w3cplus.com/css3/autoprefixer-css-vender-prefixes.html" target="_blank" rel="external">如何处理CSS3属性前缀_Autoprefixer</a></p>
<p><a href="https://blog.csdn.net/freshlover/article/details/17143341" target="_blank" rel="external">CSS透明opacity和IE各版本透明度滤镜filter的最准确用法</a></p>
<h3 id="往期文章"><a href="#往期文章" class="headerlink" title="往期文章"></a>往期文章</h3><p><a href="https://juejin.im/post/5b0cafad51882515624dc6d2" target="_blank" rel="external">精读《你不知道的 javascript（上卷）》</a></p>
<p><a href="https://juejin.im/post/5b2a07c16fb9a00e36425ef0" target="_blank" rel="external">精读《你不知道的javascript》中卷</a></p>
<p><a href="https://juejin.im/post/5b1a18de6fb9a01e312828dd" target="_blank" rel="external">精读《深入浅出Node.js》</a></p>
<p><a href="https://juejin.im/post/5b1f7e62e51d45068a6cb98f" target="_blank" rel="external">javascript 垃圾回收算法</a></p>
<p><a href="https://juejin.im/post/5b32f82a518825749e4a218b" target="_blank" rel="external">精读《图解HTTP》</a></p>
<p><a href="https://github.com/bailinlin/Awsome-Front-End-Xmind" target="_blank" rel="external">思维导图下载地址</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2018/06/25/http-read/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/06/25/http-read/" itemprop="url">
                  精读《图解HTTP》
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-25T10:27:04+08:00">
                2018-06-25
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2018/06/25/http-read/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/06/25/http-read/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p> 作为一个前端，如果能够深刻理解 HTTP 通信，能够让我们在日常开发工作中快速定位问题。所以我十分建议大家去读一下《图解HTTP》和《HTTP权威指南》。权威指南讲解的十分详细，内容也十分的全面，但是这本书的厚度也让很多同学望而却步。推荐大家从 《图解HTTP》 这本书开始学习，这本书虽然没有权威指南详细，但涵盖了很多我们日常开发需要的知识点，理解他，能让我们的开发效率事半功倍。</p>
<p>《图解HTTP》这本书对互联网基盘—— HTTP 协议进行了全面系统的介绍。作者从 HTTP 发展史开始，严谨地剖析了 HTTP 协议的结构，列举很多常见通信场景及实战案例，最后延伸到Web安全、最新技术动向等方面。通过书中大量生动形象的通信图例，我们能够更全面地理解 HTTP 通信过程中客户端与服务器之间的交互情况。在读这本书的过程中我收获颇多，并用思维导图的方式记录下来，方便自己后期温故。如果你刚好没有读过，可以当做度这本书的预习阅读，相信你也会有所收获（思维导图图片可能有点小，记得点开看）</p>
<h3 id="了解-HTTP-协议访问-Web"><a href="#了解-HTTP-协议访问-Web" class="headerlink" title="了解 HTTP 协议访问 Web"></a>了解 HTTP 协议访问 Web</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/27/1643f1a63ea9a2e0?w=1562&amp;h=857&amp;f=jpeg&amp;s=195547" alt=""></p>
<p>这一章介绍了 Web 及网络协议的基础，http 通讯被拆分成四层，应用层，传输层，网络层和链路层，每层只要考虑分派给自己的任务，不需要弄清整个协议链路的细节。应用层使我们肉眼能看见的，我们常用的 http 协议和 FTP 协议就处在这一层，往下就是传输层，TCP/IP 协议工作的地方（我们的IP是IP地址，和这里的IP 协议有做区分），再往下是网络层，传输层建立连接之后，网络层负责将数据包的传输（数据包是网络传输的最小单位）。最后是链路层，用来连接网络配件的部分，举个栗子就是我们常说的网卡啊，光纤啊。在一个完整的数据传输中，客户端会按照应用层，传输层，网络层，链路层的顺序进行进行处理，每一层都会加一个首部，服务器端在接收的时候按照链路层，网路层，传输层，应用层的顺序去移除首部。</p>
<p>我们常说的3次握手就是 TCP 协议采用的策略，为了传输方便，TCP 将大数据分割成以报文为单位的数据包，IP 协议负责把数据包发送出去。在发送的过程中常常需要经过多个路由器的中转，这个时候会运用 ARP 协议来查找下一个路由器的地址。</p>
<p>通常用户的习惯会去访问域名而不是IP地址，将域名解析成对应的 IP 就需要用到 DNS 协议域名解析的服务。</p>
<h3 id="简单的-HTTP-协议"><a href="#简单的-HTTP-协议" class="headerlink" title="简单的 HTTP 协议"></a>简单的 HTTP 协议</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/27/1643f1a97d7961d7" alt=""></p>
<p>日常开发中我们感知不到 http 协议的底层实现，我们所了解的 HTTP 协议总是由客户端发起，服务端接收。我们关注到的请求，常常是请求的URI，协议版本，头部信息，及内容实体，我们常使用的响应信息则包括了响应状态，响应内容。</p>
<p>我们常常会使用不通的 http 方法来执行不同的操作。我们常使用 GET 来获取资源，使用 POST 传输实体主题，使用 PUT 传输文件，使用 DELETE 删除文件，使用 OPTIONS 询问支持的方法（常常在跨域的场景中使用），使用TRACE 获取访问路径，使用 CONNECT 用隧道协议链接代理。</p>
<p>http 协议是一种无状态协议，不会去记录上一次访问状态，这使得当我们要做类似于登录这样的公能的时候，需要通过 cookie 来进行状态的管理。</p>
<h3 id="HTTP-报文内的-HTTP-信息"><a href="#HTTP-报文内的-HTTP-信息" class="headerlink" title="HTTP 报文内的 HTTP 信息"></a>HTTP 报文内的 HTTP 信息</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/27/1643f1ae31d809e0?w=1480&amp;h=856&amp;f=jpeg&amp;s=177072" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/27/1643f1b0372ea19f?w=1480&amp;h=382&amp;f=jpeg&amp;s=93168" alt=""><br>通常HTTP报文（用于HTTP协议交互的信息）的结构包括，请求行，状态行，首部字段等，从 HTTP 的报文中，我们可以获得很多信息。在 MIME 扩展中会使用一种称为多部分对象集合的方法，来容纳多份不同的数据类型， 在 HTTP 报文中使用多部分对象时，需要在首部字段上加上 Content-type 。</p>
<p>通过设置首部字段，来达到获取部分内容范围请求（请求资源中断后，不需要重新开始请求),将传输内容编码的目的，来提高加载效率。</p>
<p>有的时候不同的场景需要我们获取不同的内容，就比如页面的中英文切换的功能，在HTTP请求中，我们通过设置 accept 类的请求头字段实现，也就是内容协商的方式，返回最合适的内容。协商方式分为，服务器驱动协商，客户端驱动协商，透明协商。</p>
<h3 id="返回结果的-HTTP-状态"><a href="#返回结果的-HTTP-状态" class="headerlink" title="返回结果的 HTTP 状态"></a>返回结果的 HTTP 状态</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/27/1643f1b307e6623f?w=1466&amp;h=859&amp;f=jpeg&amp;s=245755" alt=""></p>
<p>在HTTP通讯中，通过转态码，告知客户端的请求状态。状态码大致可以被分为 5 大类，1xx 表示接受的请求正在处理，2xx 表示请求正常处理完毕，3xx 表示需要进行附加操作以完成请求，4xx 表示客户端无法处理请求，5xx 表示服务器处理出错。</p>
<p>在这5大类请求中，我们常用的十几种状态码，需要我们重点去掌握，详细介绍看👆的思维导图。</p>
<h3 id="与-HTTP-协作的-Web-服务器"><a href="#与-HTTP-协作的-Web-服务器" class="headerlink" title="与 HTTP 协作的 Web 服务器"></a>与 HTTP 协作的 Web 服务器</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/27/1643f1b578adf6cd" alt=""></p>
<p>通过使用虚拟机，可以实现单台主机多个域名的站点部署。在实际通讯中，我们常常使用，代理，网关，隧道协助请求转发，安全通信。</p>
<p>为了提高网站性能，我们会使用缓存方式来提高站点请求速率，通常是通过设置代理服务器缓存和客户端缓存来实现。需要注意的是，缓存都会设置一个过期时间，站点内容更新时，缓存内容也需要及时更新。</p>
<h3 id="HTTP-头部"><a href="#HTTP-头部" class="headerlink" title="HTTP 头部"></a>HTTP 头部</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/27/1643f1b89773bfc0?w=1339&amp;h=607&amp;f=jpeg&amp;s=114773" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/27/1643f1d9e9e58cfd?w=1340&amp;h=582&amp;f=jpeg&amp;s=121933" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/27/1643f1dbbe71bcc5?w=1342&amp;h=805&amp;f=jpeg&amp;s=146900" alt=""></p>
<p>在请求中，HTTP 报文由请求方法，URI，HTTP版本，HTTP 首部字段等部分构成。在响应中，HTTP 的报文有 HTTP 版本，状态码，HTTP首部字段3部分构成。首部信息尤为重要，我们可以通过首部字段的设置来传递请求信息，类比于缓存控制，报文创建时间，是否压缩编码，是否支持跨域等。</p>
<h3 id="确保-Web-安全的-HTTPS"><a href="#确保-Web-安全的-HTTPS" class="headerlink" title="确保 Web 安全的 HTTPS"></a>确保 Web 安全的 HTTPS</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/27/1643f1ded196ed33?w=1757&amp;h=757&amp;f=jpeg&amp;s=199221" alt=""><br>HTTP 简单灵活的设置也造就了他的缺点。1. 通信使用明文，内容可能被窃听。2、不验证通讯方省份，因此有可能会遭遇伪装。3、无法证明报文的完整性，所有有可能被篡改。HTTPS 其实也不算是一个全新的协议，HTTPS =  HTTP + 加密 + 认证 + 完整性保护。HTTPS 完善了 HTTP 的相关缺点，在 HTTP 的部分通信接口采用 SSL 和 TLS 协议替代，使用了数字证书认证机构和其他相关机关颁发的公开秘钥证书</p>
<h3 id="何为认证"><a href="#何为认证" class="headerlink" title="何为认证"></a>何为认证</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/27/1643f1e642add91e?w=1519&amp;h=580&amp;f=jpeg&amp;s=85904" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/27/1643f1e8931b3b8e?w=1522&amp;h=867&amp;f=jpeg&amp;s=310600" alt=""><br>HTTP 的认证方式通常是 BASIC认证（基本认证），DIGEST认证（摘要认证），SSL 客户端认证，FormBase 认证（基于表单认证）。BASIC 认证和 DIGEST 认证通过首部字段 Authorization 确认认证信息，SSL 借由 HTTPS 客户端证书完成认证方式。 表单认证则是依赖于 cookie 保存用户的登录状态。</p>
<h3 id="基于-HTTP-的功能追加协议"><a href="#基于-HTTP-的功能追加协议" class="headerlink" title="基于 HTTP 的功能追加协议"></a>基于 HTTP 的功能追加协议</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/27/1643f1eacf6af00b?w=1547&amp;h=873&amp;f=jpeg&amp;s=231791" alt=""></p>
<p>SPDY 在TCP/IP 的应用层与运输层之间通过新加会话层的形式运作，使用 SPDY 使得 HTTP 协议的功能得到了扩展，实现了多路复用流，赋予请求优先级，压缩 HTTP 首部，推送功能，服务器提醒功能。</p>
<p>使用 WebSocket 进行全双工通信，只要建立了链接，客户端和服务器都能都主动得向对方发送信息。和 HTTP 相比，减少了每次建立连接的开销，减少了通信首部信息。</p>
<p>HTTP/2.0 改善了使用 web 时的速度体验。</p>
<h3 id="构建-Web-内容的技术"><a href="#构建-Web-内容的技术" class="headerlink" title="构建 Web 内容的技术"></a>构建 Web 内容的技术</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/27/1643f1ecb65228ef?w=1655&amp;h=720&amp;f=jpeg&amp;s=189926" alt=""></p>
<p>web 应用开发语言的三剑客，HTML，CSS，javascript 。书出版的有点久所以书中没有提到，现在火爆的 web 构建技术，Vue，React 等流行前端框架。XML，JSON 数据发布语言，其中 JSON 比较常用，日常开发都离不了他。</p>
<h3 id="web-的攻击技术"><a href="#web-的攻击技术" class="headerlink" title="web 的攻击技术"></a>web 的攻击技术</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/27/1643f1ef858e8495?w=1679&amp;h=305&amp;f=jpeg&amp;s=74588" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/27/1643f1f2063461d3?w=1679&amp;h=764&amp;f=jpeg&amp;s=193638" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/27/1643f1f3ee6ca4a2?w=1679&amp;h=623&amp;f=jpeg&amp;s=188622" alt=""><br>在 Web 应用中，从浏览器那接收到的 HTTP 请求的全部内容，都可以在客户端自由的变更、篡改，在HTTP请求报文中加载攻击代码，就能发起对 Web 应用的攻击。Web 应用的攻击模式主要是主动攻击和被动攻击。</p>
<p>常见的攻击方式有，跨站脚本攻击，SQL 注入攻击，HTTP 首部注入攻击。这些攻击造成的影响见👆思维导图。通常简单的 HTTP 协议本身不会存在安全性的问题，协议本身也不会成为攻击对象，黑客利用的常常是因为设计和设置上的缺陷，会话管理疏忽等引发的安全漏洞进行攻击。</p>
<h3 id="😊往期的读书笔记"><a href="#😊往期的读书笔记" class="headerlink" title="😊往期的读书笔记"></a>😊往期的读书笔记</h3><blockquote>
<p>《图解HTTP》这本书读完啦，下一期我们来读读《HTTP权威指南》，我在 <a href="https://github.com/bailinlin/Awsome-Front-End-Xmind" target="_blank" rel="external">github</a> 建了仓库放这些思维导图的原件，如果觉得图片不清晰，同学们可以去 <a href="https://github.com/bailinlin/Awsome-Front-End-Xmind" target="_blank" rel="external">github</a> 上下载查阅。如果你也喜欢用思维导图的方式来记录读书笔记，也欢迎和我一同维护这个仓库，欢迎留言或则微信（646321933）与我交流</p>
</blockquote>
<p><a href="https://juejin.im/post/5b0cafad51882515624dc6d2" target="_blank" rel="external">精读《你不知道的 javascript（上卷）》</a></p>
<p><a href="https://juejin.im/post/5b2a07c16fb9a00e36425ef0" target="_blank" rel="external">精读《你不知道的javascript》中卷</a></p>
<p><a href="https://juejin.im/post/5b1a18de6fb9a01e312828dd" target="_blank" rel="external">精读《深入浅出Node.js》</a></p>
<p><a href="https://juejin.im/post/5b1f7e62e51d45068a6cb98f" target="_blank" rel="external">javascript 垃圾回收算法</a></p>
<p><a href="https://github.com/bailinlin/Awsome-Front-End-Xmind" target="_blank" rel="external">思维导图下载地址</a></p>
<p><a href="http://ot2hu9qoc.bkt.clouddn.com/%E5%9B%BE%E8%A7%A3HTTP+%E5%BD%A9%E8%89%B2%E7%89%88@www.java1234.com.pdf" target="_blank" rel="external">《图解HTTP》 PDF下载地址</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2018/06/20/javascript2/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/06/20/javascript2/" itemprop="url">
                  精读《你不知道的javascript》中卷
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-20T14:04:36+08:00">
                2018-06-20
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2018/06/20/javascript2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/06/20/javascript2/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>《你不知道的 javascript》是一个前端学习必读的系列，让不求甚解的JavaScript开发者迎难而上，深入语言内部，弄清楚JavaScript每一个零部件的用途。本书《你不知道的javascript》中卷介绍了该系列的两个主题：“类型和语法”以及“异步与性能”。这两块也是值得我们反复去学习琢磨的两块只是内容，今天我们用思维导图的方式来精读一遍。（思维导图图片可能有点小，记得点开看，你会有所收获）</p>
<h3 id="第一部分-作用域和闭包"><a href="#第一部分-作用域和闭包" class="headerlink" title="第一部分 作用域和闭包"></a>第一部分 作用域和闭包</h3><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c2f4d3ede46a?w=1105&amp;h=870&amp;f=jpeg&amp;s=140823" alt=""><br>JavaScript 有 七 种 内 置 类 型: null 、 undefined 、 boolean 、 number 、 string 、 object 和 symbol ,可以使用 typeof 运算符来查看。</p>
<p>变量没有类型,但它们持有的值有类型。类型定义了值的行为特征。</p>
<p>很多开发人员将 undefined 和 undeclared 混 为 一 谈, 但 在 JavaScript 中 它 们 是 两 码 事。 undefined 是值的一种。 undeclared 则表示变量还没有被声明过。</p>
<p>遗憾的是, JavaScript 却将它们混为一谈, 在我们试图访问 “undeclared” 变量时这样报 错:ReferenceError: a is not defined, 并 且 typeof 对 undefined 和 undeclared 变 量 都 返 回 “undefined” 。</p>
<p>然而,通过 typeof 的安全防范机制(阻止报错)来检查 undeclared 变量,有时是个不错的办法。</p>
<h3 id="值"><a href="#值" class="headerlink" title="值"></a>值</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c2f9fd654d30?w=1299&amp;h=398&amp;f=jpeg&amp;s=77055" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c2fbdebcded2?w=1300&amp;h=894&amp;f=jpeg&amp;s=195120" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c2fdca914292?w=1303&amp;h=706&amp;f=jpeg&amp;s=150852" alt=""></p>
<p>JavaScript 中的数组是通过数字索引的一组任意类型的值。字符串和数组类似,但是它们的 行为特征不同, 在将字符作为数组来处理时需要特别小心。 JavaScript 中的数字包括“整 数”和“浮点型”。</p>
<p>基本类型中定义了几个特殊的值。</p>
<p>null 类型只有一个值 null , undefined 类型也只有一个值 undefined 。 所有变量在赋值之 前默认值都是 undefined 。 void 运算符返回 undefined 。</p>
<p>数 字 类 型 有 几 个 特 殊 值, 包 括 NaN ( 意 指“not a number” , 更 确 切 地 说 是“invalid number” )、 +Infinity 、 -Infinity 和 -0 。</p>
<p>简单标量基本类型值(字符串和数字等)通过值复制来赋值 / 传递, 而复合值(对象等) 通过引用复制来赋值 / 传递。 JavaScript 中的引用和其他语言中的引用 / 指针不同,它们不 能指向别的变量 / 引用,只能指向值。</p>
<h3 id="原生函数"><a href="#原生函数" class="headerlink" title="原生函数"></a>原生函数</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c303afb22377?w=1450&amp;h=770&amp;f=jpeg&amp;s=128562" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c306f032cf04?w=1450&amp;h=682&amp;f=jpeg&amp;s=180566" alt=""></p>
<p>JavaScript 为基本数据类型值提供了封装对象,称为原生函数(如 String 、 Number 、 Boolean 等)。它们为基本数据类型值提供了该子类型所特有的方法和属性(如: String#trim() 和 Array#concat(..) )。</p>
<p>对于简单标量基本类型值,比如 “abc” ,如果要访问它的 length 属性或 String.prototype 方法, JavaScript 引擎会自动对该值进行封装(即用相应类型的封装对象来包装它)来实现对这些属性和方法的访问。</p>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c30a226085fc?w=1499&amp;h=239&amp;f=jpeg&amp;s=43515" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c30d238ec375?w=1499&amp;h=891&amp;f=jpeg&amp;s=213161" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c30efc487344?w=1499&amp;h=887&amp;f=jpeg&amp;s=203319" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c310cc70fdcc?w=1499&amp;h=823&amp;f=jpeg&amp;s=164996" alt=""></p>
<p>本章介绍了 JavaScript 的数据类型之间的转换,即强制类型转换:包括显式和隐式。</p>
<p>强制类型转换常常为人诟病, 但实际上很多时候它们是非常有用的。 作为有使命感的 JavaScript 开发人员,我们有必要深入了解强制类型转换,这样就能取其精华,去其糟粕。</p>
<p>显式强制类型转换明确告诉我们哪里发生了类型转换, 有助于提高代码可读性和可维 护性。</p>
<p>隐式强制类型转换则没有那么明显,是其他操作的副作用。感觉上好像是显式强制类型转 换的反面,实际上隐式强制类型转换也有助于提高代码的可读性。</p>
<p>在处理强制类型转换的时候要十分小心,尤其是隐式强制类型转换。在编码的时候,要知 其然,还要知其所以然,并努力让代码清晰易读。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c313229058fc?w=1250&amp;h=857&amp;f=jpeg&amp;s=153667" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c315bee42707?w=1253&amp;h=870&amp;f=jpeg&amp;s=194344" alt=""><br>JavaScript 语法规则中的许多细节需要我们多花点时间和精力来了解。 从长远来看, 这有 助于更深入地掌握这门语言。</p>
<p>语句和表达式在英语中都能找到类比——语句就像英语中的句子,而表达式就像短语。表 达式可以是简单独立的,否则可能会产生副作用。</p>
<p>JavaScript 语法规则之上是语义规则(也称作上下文)。例如, { } 在不同情况下的意思不 尽相同,可以是语句块、对象常量、解构赋值(ES6)或者命名函数参数(ES6)。</p>
<p>JavaScript 详细定义了运算符的优先级(运算符执行的先后顺序)和关联(多个运算符的 组合方式)。只要熟练掌握了这些规则,就能对如何合理地运用它们作出自己的判断。</p>
<p>ASI(自动分号插入)是 JavaScript 引擎的代码解析纠错机制, 它会在需要的地方自动插 入分号来纠正解析错误。问题在于这是否意味着大多数的分号都不是必要的(可以省略), 或者由于分号缺失导致的错误是否都可以交给 JavaScript 引擎来处理。</p>
<p>JavaScript 中有很多错误类型, 分为两大类:早期错误(编译时错误, 无法被捕获)和运 行时错误(可以通过 try..catch 来捕获)。所有语法错误都是早期错误,程序有语法错误 则无法运行。</p>
<p>函数参数和命名参数之间的关系非常微妙。尤其是 arguments 数组,它的抽象泄漏给我们 挖了不少坑。因此,尽量不要使用 arguments ,如果非用不可,也切勿同时使用 arguments 和其对应的命名参数。</p>
<p>finally 中代码的处理顺序需要特别注意。它们有时能派上很大用场,但也容易引起困惑, 特别是在和带标签的代码块混用时。总之,使用 finally 旨在让代码更加简洁易读,切忌 弄巧成拙。</p>
<p>switch 相对于 if..else if.. 来说更为简洁。需要注意的一点是,如果对其理解得不够透 彻,稍不注意就很容易出错。</p>
<h3 id="第二部分-this-和对象原型"><a href="#第二部分-this-和对象原型" class="headerlink" title="第二部分 this 和对象原型"></a>第二部分 this 和对象原型</h3><h3 id="异步：现在与将来"><a href="#异步：现在与将来" class="headerlink" title="异步：现在与将来"></a>异步：现在与将来</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c318a66b1032?w=1200&amp;h=619&amp;f=jpeg&amp;s=126139" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c31aeeeaae13?w=1200&amp;h=698&amp;f=jpeg&amp;s=138515" alt=""><br>实际上, JavaScript 程序总是至少分为两个块:第一块 现在 运行;下一块 将来 运行, 以响 应某个事件。尽管程序是一块一块执行的,但是所有这些块共享对程序作用域和状态的访 问,所以对状态的修改都是在之前累积的修改之上进行的。</p>
<p>一旦有事件需要运行, 事件循环就会运行, 直到队列清空。 事件循环的每一轮称为一个 tick。 用户交互、IO 和定时器会向事件队列中加入事件。</p>
<p>任意时刻,一次只能从队列中处理一个事件。执行事件的时候,可能直接或间接地引发一 个或多个后续事件。</p>
<p>并发是指两个或多个事件链随时间发展交替执行,以至于从更高的层次来看,就像是同时 在运行(尽管在任意时刻只处理一个事件)。</p>
<p>通常需要对这些并发执行的“进程”(有别于操作系统中的进程概念)进行某种形式的交 互协调,比如需要确保执行顺序或者需要防止竞态出现。这些“进程”也可以通过把自身 分割为更小的块,以便其他“进程”插入进来。</p>
<h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c31dc255b722?w=1200&amp;h=845&amp;f=jpeg&amp;s=169244" alt=""></p>
<p>回调函数是 JavaScript 异步的基本单元。但是随着 JavaScript 越来越成熟,对于异步编程领域的发展,回调已经不够用了。</p>
<p>第一,大脑对于事情的计划方式是线性的、阻塞的、单线程的语义,但是回调表达异步流 程的方式是非线性的、非顺序的,这使得正确推导这样的代码难度很大。难于理解的代码 是坏代码,会导致坏 bug。</p>
<p>我们需要一种更同步、更顺序、更阻塞的的方式来表达异步,就像我们的大脑一样。</p>
<p>第二,也是更重要的一点,回调会受到控制反转的影响,因为回调暗中把控制权交给第三 方(通常是不受你控制的第三方工具!)来调用你代码中的 continuation。 这种控制转移导 致一系列麻烦的信任问题,比如回调被调用的次数是否会超出预期。</p>
<p>可以发明一些特定逻辑来解决这些信任问题,但是其难度高于应有的水平,可能会产生更 笨重、更难维护的代码,并且缺少足够的保护,其中的损害要直到你受到 bug 的影响才会 被发现。</p>
<p>我们需要一个通用的方案来解决这些信任问题。不管我们创建多少回调,这一方案都应可 以复用,且没有重复代码的开销。</p>
<p>我们需要比回调更好的机制。到目前为止,回调提供了很好的服务,但是未来的 JavaScript 需要更高级、功能更强大的异步模式。本书接下来的几章会深入探讨这些新型技术。</p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c3210ed1135d?w=1559&amp;h=321&amp;f=jpeg&amp;s=81813" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c322b9dce156?w=1559&amp;h=712&amp;f=jpeg&amp;s=219007" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c32579139ed3?w=1561&amp;h=715&amp;f=jpeg&amp;s=201171" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c3279bb0a8d7?w=1506&amp;h=773&amp;f=jpeg&amp;s=236818" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c3299cc4a0d4?w=1504&amp;h=330&amp;f=jpeg&amp;s=101344" alt=""></p>
<p>Promise 非常好,请使用。它们解决了我们因只用回调的代码而备受困扰的控制反转问题。</p>
<p>它们并没有摈弃回调,只是把回调的安排转交给了一个位于我们和其他工具之间的可信任 的中介机制。</p>
<p>Promise 链也开始提供(尽管并不完美)以顺序的方式表达异步流的一个更好的方法,这 有助于我们的大脑更好地计划和维护异步 JavaScript 代码。我们将在第 4 章看到针对这个 问题的一种更好的解决方案!</p>
<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c32bc25ce357?w=1430&amp;h=893&amp;f=jpeg&amp;s=251348" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c32dfa81cca0?w=1429&amp;h=875&amp;f=jpeg&amp;s=220277" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c32feeacf0c8?w=1429&amp;h=330&amp;f=jpeg&amp;s=82989" alt=""><br>生成器是 ES6 的一个新的函数类型, 它并不像普通函数那样总是运行到结束。 取而代之 的是, 生成器可以在运行当中(完全保持其状态)暂停, 并且将来再从暂停的地方恢复 运行。</p>
<p>这种交替的暂停和恢复是合作性的而不是抢占式的,这意味着生成器具有独一无二的能力 来暂停自身,这是通过关键字 yield 实现的。不过,只有控制生成器的迭代器具有恢复生 成器的能力(通过 next(..) )。</p>
<p>yield / next(..) 这一对不只是一种控制机制,实际上也是一种双向消息传递机制。 yield .. 表 达式本质上是暂停下来等待某个值,接下来的 next(..) 调用会向被暂停的 yield 表达式传回 一个值(或者是隐式的 undefined )。</p>
<p>在异步控制流程方面,生成器的关键优点是:生成器内部的代码是以自然的同步 / 顺序方 式表达任务的一系列步骤。其技巧在于,我们把可能的异步隐藏在了关键字 yield 的后面, 把异步移动到控制生成器的迭代器的代码部分。</p>
<p>换句话说,生成器为异步代码保持了顺序、同步、阻塞的代码模式,这使得大脑可以更自 然地追踪代码,解决了基于回调的异步的两个关键缺陷之一。</p>
<h3 id="程序性能"><a href="#程序性能" class="headerlink" title="程序性能"></a>程序性能</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c33279d14790?w=1150&amp;h=757&amp;f=jpeg&amp;s=152257" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c334668ebefc?w=1150&amp;h=273&amp;f=jpeg&amp;s=64116" alt=""></p>
<p>本部分的前四章都是基于这样一个前提:异步编码模式使我们能够编写更高效的代码,通 常能够带来非常大的改进。但是,异步特性只能让你走这么远,因为它本质上还是绑定在 一个单事件循环线程上。</p>
<p>因此,在这一章里,我们介绍了几种能够进一步提高性能的程序级别的机制。</p>
<p>Web Worker 让你可以在独立的线程运行一个 JavaScript 文件(即程序),使用异步事件在 线程之间传递消息。 它们非常适用于把长时间的或资源密集型的任务卸载到不同的线程 中,以提高主 UI 线程的响应性。</p>
<p>SIMD 打算把 CPU 级的并行数学运算映射到 JavaScript API, 以获得高性能的数据并行运算,比如在大数据集上的数字处理。</p>
<p>最后, asm.js 描述了 JavaScript 的一个很小的子集, 它避免了 JavaScript 难以优化的部分 (比如垃圾收集和强制类型转换),并且让 JavaScript 引擎识别并通过激进的优化运行这样 的代码。可以手工编写 asm.js, 但是会极端费力且容易出错,类似于手写汇编语言(这也 是其名字的由来)。实际上, asm.js 也是高度优化的程序语言交叉编译的一个很好的目标, 比如 Emscripten 把 C/C++ 转换成 JavaScript(<a href="https://github.com/kripken/emscripten/wiki" target="_blank" rel="external">https://github.com/kripken/emscripten/wiki</a>) 。</p>
<p>JavaScript 还有一些更加激进的思路已经进入非常早期的讨论, 尽管本章并没有明确包含 这些内容,比如近似的直接多线程功能(而不是藏在数据结构 API 后面)。不管这些最终 会不会实现,还是我们将只能看到更多的并行特性偷偷加入 JavaScript, 但确实可以预见, 未来 JavaScript 在程序级别将获得更加优化的性能。</p>
<h3 id="性能测试与调优"><a href="#性能测试与调优" class="headerlink" title="性能测试与调优"></a>性能测试与调优</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/20/1641c336f145c542?w=1486&amp;h=883&amp;f=jpeg&amp;s=206732" alt=""></p>
<p>对一段代码进行有效的性能测试,特别是与同样代码的另外一个选择对比来看看哪种方案 更快,需要认真注意细节。</p>
<p>与其打造你自己的统计有效的性能测试逻辑,不如直接使用 Benchmark.js 库,它已经为你 实现了这些。但是,编写测试要小心,因为我们很容易就会构造一个看似有效实际却有缺 陷的测试,即使是微小的差异也可能扭曲结果,使其完全不可靠。</p>
<p>从尽可能多的环境中得到尽可能多的测试结果以消除硬件/ 设备的偏差, 这一点很重要。 jsPerf.com 是很好的网站,用于众包性能测试运行。</p>
<p>遗憾的是,很多常用的性能测试执迷于无关紧要的微观性能细节,比如 x++ 对比 ++x 。编 写好的测试意味着理解如何关注大局, 比如关键路径上的优化以及避免落入类似不同的 JavaScript 实现细节这样的陷阱中。</p>
<p>尾调用优化是 ES6 要求的一种优化方法。它使 JavaScript 中原本不可能的一些递归模式变 得实际。 TCO 允许一个函数在结尾处调用另外一个函数来执行,不需要任何额外资源。这意味着,对递归算法来说,引擎不再需要限制栈深度。</p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>思维导图能比较清晰的还原整本书的知识结构体系，如果你还没用看过这本书，可以按照这个思维导图的思路快速预习一遍，提高学习效率。学习新事物总容易遗忘，我比较喜欢在看书的时候用思维导图做些记录，便于自己后期复习，如果你已经看过了这本书，也建议你收藏复习。如果你有神马建议或则想法，欢迎留言或加我微信交流：646321933，备注技术交流</p>
<p><a href="https://bailinlin.github.io/2018/05/28/javascript1/" target="_blank" rel="external">精读《你不知道的javascript》上卷</a></p>
<p><a href="https://bailinlin.github.io/2018/06/08/node-notes/" target="_blank" rel="external">精读《深入浅出Node.js》</a></p>
<p><a href="https://github.com/bailinlin/Awsome-Front-End-Xmind" target="_blank" rel="external">思维导图下载地址</a></p>
<p><a href="https://github.com/threerocks/studyFiles/blob/master/js/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%EF%BC%88%E4%B8%AD%E5%8D%B7%EF%BC%89.pdf" target="_blank" rel="external">你不知道的 javascript（中卷）PDF 下载地址</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2018/06/12/ljhs/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/06/12/ljhs/" itemprop="url">
                  你需要知道的 javascript 垃圾回收机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-12T15:11:38+08:00">
                2018-06-12
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2018/06/12/ljhs/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/06/12/ljhs/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>我们通常理解的 javascript 垃圾回收机制都停留在表面，”会释放不被引用变量内存”，最近在读《深入浅出node.js》的书，详细了解了下 v8 垃圾回收的算法，记录了一些学习笔记。</p>
</blockquote>
<h3 id="敲黑板：v8引擎的垃圾回收算法"><a href="#敲黑板：v8引擎的垃圾回收算法" class="headerlink" title="敲黑板：v8引擎的垃圾回收算法"></a>敲黑板：v8引擎的垃圾回收算法</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/12/163f306c4254c932?w=1064&amp;h=492&amp;f=jpeg&amp;s=114417" alt=""></p>
<p>V8的垃圾回收策略主要基于分代式垃圾回收机制，现代的垃圾回收算法中按对象的存活时间将内存的垃圾回收进行不同的分代,然后分别对不同分代的内存施以更高效的算法。在V8中,主要将内存分为新生代和老生代两代。新生代中的对象为存活时间较短的对象, 老生代中的对象为存活时间较长或常驻内存的对象。</p>
<h3 id="Scavenge算法"><a href="#Scavenge算法" class="headerlink" title="Scavenge算法"></a>Scavenge算法</h3><blockquote>
<p>在分代的基础上,新生代中的对象主要通过Scavenge算法进行垃圾回收,在Scavenge的具体 实现中,主要采用了Cheney算法</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/12/163f30742b0bf065?w=1130&amp;h=568&amp;f=jpeg&amp;s=175952" alt=""></p>
<p>Cheney 算法是一种采用复制的方式实现的垃圾回收算法。它将堆内存一分为二,每一部分空间称为 semispace。在这两个 semispace 空间中,只有一个处于使用中,另一个处于闲置状态。处于使用状态的 semispace 空间称为 From 空间,处于闲置状态的空间称为 To 空间。当我们分配对象时,先是在 From 空间中进行分配。当开始进行垃圾回收时,会检查 From 空间中的存活对象,这 些存活对象将被复制到 To 空间中,而非存活对象占用的空间将会被释放。完成复制后,From 空 间和To空间的角色发生对换。 简而言之, 在垃圾回收的过程中, 就是通过将存活对象在两个 semispace 空间之间进行复制。</p>
<h3 id="Mark-Sweep-amp-Mark-Compact"><a href="#Mark-Sweep-amp-Mark-Compact" class="headerlink" title="Mark-Sweep &amp; Mark-Compact"></a>Mark-Sweep &amp; Mark-Compact</h3><blockquote>
<p>Scavenge算法通过牺牲空间换时间的算法非常适合生命周期短的新生代，但是，当一个对象经过多次复制，生命周期较长的时候或则To空间不足的时候，对象会被分配到进入到老生代中，需要采用新的算法进行垃圾回收。</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/12/163f307747161f7d?w=1175&amp;h=609&amp;f=jpeg&amp;s=184055" alt=""></p>
<p>Mark-Sweep 并不将内存空间划分为两半,所以不存在浪费一半空间的行为。与 Scavenge 复制活着的对象不同, Mark-Sweep 在标记阶段遍历堆中的所有对象,并标记活着的对象,在随后的清除阶段中,只清除没有被标记的对象。可以看出,Scavenge 中只复制活着的对象,而 Mark-Sweep 只清理死亡对象。</p>
<p>Mark-Sweep 在进行一次标记清除回收后,内存空间会出现不连续的状态。这种内存碎片会对后续的内存分配造成问题,因为很可能出现需要分配一个大对象的情况,这时所有的碎片空间都无法完成此次分配,就会提前触发垃圾回收,而这次回收是不必要的。Mark-Compact 对象在标记为死亡后,在整理的过程中,将活着的对象往一端移动,移动完成后,直接清理掉边界外的内存</p>
<h3 id="增量标记"><a href="#增量标记" class="headerlink" title="增量标记"></a>增量标记</h3><p>为了避免出现 JavaScript 应用逻辑与垃圾回收器看到的不一致的情况,垃圾回收的 3 种基本算法都需要将应用逻辑暂停下来,待执行完垃圾回收后再恢复执行应用逻辑,这种行为被称为“全停顿”，长时间的”全停顿”垃圾回收会让用户感受到明显的卡顿，带来体验的影响。以1.5 GB的垃圾回收堆内存为例,V8做一次小的垃圾回收需要50毫秒以上,做一次非增量式的垃圾回收甚至要1秒以上。这是垃圾回收中引起JavaScript线程暂停执行的时间,在 这样的时间花销下,应用的性能和响应能力都会直线下降。</p>
<p>为了降低全堆垃圾回收带来的停顿时间,V8先从标记阶段入手,将原本要一口气停顿完成的动作改为增量标记(incremental marking),也就是拆分为许多小“步进”,每做完一“步进” 就让 JavaScript 应用逻辑执行一小会儿,垃圾回收与应用逻辑交替执行直到标记阶段完成</p>
<h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><p><a href="http://www.ruanyifeng.com/blog/2017/04/memory-leak.html" target="_blank" rel="external">JavaScript 内存泄漏教程</a></p>
<p><a href="https://bailinlin.github.io/2018/06/08/node-notes/" target="_blank" rel="external">精读《深入浅出Node.js》</a></p>
<p><a href="chrome-extension://ikhdkkncnoglghljlkmcimlnlhkeamad/pdf-viewer/web/viewer.html?file=http%3A%2F%2Fblog.songqingbo.cn%2Fpdf%2Fnodejs%2F%25E6%25B7%25B1%25E5%2585%25A5%25E6%25B5%2585%25E5%2587%25BANode.js.pdf" target="_blank" rel="external">《深入浅出Node.js》PDF</a></p>
<p><a href="https://github.com/bailinlin/Awsome-Front-End-Xmind" target="_blank" rel="external">思维导图下载地址</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2018/06/08/node-notes/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/06/08/node-notes/" itemprop="url">
                  精读《深入浅出Node.js》
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-08T14:04:36+08:00">
                2018-06-08
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2018/06/08/node-notes/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/06/08/node-notes/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>如果你想要深入学习Node，那你不能错过《深入浅出Node.js》这本书，它从不同的视角介绍了 Node 内在的特点和结构。由首章Node 介绍为索引，涉及Node 的各个方面，主要内容包含模块机制的揭示、异步I/O 实现原理的展现、异步编程的探讨、内存控制的介绍、二进制数据Buffer 的细节、Node 中的网络编程基础、Node 中的Web 开发、进程间的消息传递、Node 测试以及通过Node 构建产品需要的注意事项。最后的附录介绍了Node 的安装、调试、编码规范和NPM 仓库等事宜。在读这本书的过程中我收获颇多，并用思维导图的方式记录下来，方便自己后期温故。如果你刚好没有读过，可以当做度这本书的预习阅读，相信你也会有所收获（思维导图图片可能有点小，记得点开看）</p>
<h3 id="第1章-Node简介"><a href="#第1章-Node简介" class="headerlink" title="第1章　Node简介"></a>第1章　Node简介</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/8/163ddf797e5ca946?w=1087&amp;h=694&amp;f=jpeg&amp;s=112844" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/8/163ddf7beac28eea?w=1088&amp;h=445&amp;f=jpeg&amp;s=39820" alt=""></p>
<h3 id="第2章-模块机制"><a href="#第2章-模块机制" class="headerlink" title="第2章　模块机制"></a>第2章　模块机制</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/8/163ddf7f53fdae09?w=1180&amp;h=393&amp;f=jpeg&amp;s=36439" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/8/163ddf823d7036bf?w=1180&amp;h=734&amp;f=jpeg&amp;s=141761" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/8/163ddf850d0a355e?w=1183&amp;h=745&amp;f=jpeg&amp;s=164967" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/8/163ddf8757804e03?w=1180&amp;h=527&amp;f=jpeg&amp;s=80154" alt=""><br>CommonJS提出的规范均十分简单,但是现实意义却十分强大。Node通过模块规范,组织了 自身的原生模块,弥补JavaScript弱结构性的问题,形成了稳定的结构,并向外提供服务。NPM 通过对包规范的支持,有效地组织了第三方模块,这使得项目开发中的依赖问题得到很好的解决, 并有效提供了分享和传播的平台,借助第三方开源力量,使得Node第三方模块的发展速度前所未 有,这对于其他后端JavaScript语言实现而言是从未有过的。从一定的角度上讲,CommonJS规范 帮助Node形成了它的骨骼。只有茁壮的根,才能培养出茂盛的枝叶,并成长为参天大树。正是这 些底层的规范和实践,使得Node有序地发展着,摆脱掉过去JavaScript纷乱和被误解的局面,进 而进化成良性的生态系统。</p>
<h3 id="第3章-异步I-O"><a href="#第3章-异步I-O" class="headerlink" title="第3章　异步I/O"></a>第3章　异步I/O</h3><p><img src="https://user-gold-cdn.xitu.io/2018/6/8/163de079a7e88a57?w=1193&amp;h=658&amp;f=jpeg&amp;s=118066" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/8/163ddfd11745edcd?w=1383&amp;h=613&amp;f=jpeg&amp;s=152907" alt=""><br>本章介绍了异步I/O和另一些非I/O的异步方法。可以看出,事件循环是异步实现的核心,它 与浏览器中的执行模型基本保持了一致。而像古老的Rhino,尽管是较早就能在服务器端运行的 JavaScript运行时,但是执行模型并不像浏览器采用事件驱动,而是像其他语言一般采用同步I/O 作为主要模型,这造成它在性能上无所发挥。Node正是依靠构建了一套完善的高性能异步I/O框 架,打破了JavaScript在服务器端止步不前的局面。</p>
          <!--noindex-->
          <div class="post-more-link text-center">
            <a class="btn" href="/2018/06/08/node-notes/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2018/05/28/javascript1/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/05/28/javascript1/" itemprop="url">
                  精读《你不知道的javascript》上卷
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-28T14:04:36+08:00">
                2018-05-28
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2018/05/28/javascript1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/05/28/javascript1/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>《你不知道的 javascript》是一个前端学习必读的系列，让不求甚解的JavaScript开发者迎难而上，深入语言内部，弄清楚JavaScript每一个零部件的用途。本书介绍了该系列的两个主题：“作用域和闭包”以及“this和对象原型”。这两块也是值得我们反复去学习琢磨的两块只是内容，今天我们用思维导图的方式来精读一遍。（思维导图图片可能有点小，记得点开看，你会有所收获）</p>
<h3 id="第一部分-作用域和闭包"><a href="#第一部分-作用域和闭包" class="headerlink" title="第一部分 作用域和闭包"></a>第一部分 作用域和闭包</h3><h4 id="作用域是什么"><a href="#作用域是什么" class="headerlink" title="作用域是什么"></a>作用域是什么</h4><p><img src="https://user-gold-cdn.xitu.io/2018/5/29/163a99495f8829f7?w=1377&amp;h=872&amp;f=jpeg&amp;s=209079" alt=""></p>
<p>作用域是一套规则,用于确定在何处以及如何查找变量(标识符)。如果查找的目的是对 变量进行赋值,那么就会使用 LHS 查询;如果目的是获取变量的值,就会使用 RHS 查询。赋值操作符会导致 LHS 查询。 的赋值操作。 =操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。<br>JavaScript 引擎首先会在代码执行前对其进行编译,在这个过程中,像 var a = 2 这样的声 明会被分解成两个独立的步骤：</p>
<ol>
<li>首先, var a 在其作用域中声明新变量。这会在最开始的阶段,也就是代码执行前进行。</li>
<li>接下来, a = 2 会查询(LHS 查询)变量 a 并对其进行赋值。</li>
</ol>
<p>LHS 和 RHS 查询都会在当前执行作用域中开始,如果有需要(也就是说它们没有找到所 需的标识符),就会向上级作用域继续查找目标标识符,这样每次上升一级作用域(一层 楼),最后抵达全局作用域(顶层),无论找到或没找到都将停止。</p>
<p>不成功的RHS引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式地创建一个全局变量(非严格模式下),该变量使用 LHS 引用的目标作为标识符,或者抛 出 ReferenceError 异常(严格模式下)。</p>
<h4 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h4><p><img src="https://user-gold-cdn.xitu.io/2018/5/29/163a994edf51a32f?w=1105&amp;h=471&amp;f=jpeg&amp;s=50305" alt=""></p>
<p>词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段 基本能够知道全部标识符在哪里以及是如何声明的,从而能够预测在执行过程中如何对它 们进行查找。</p>
<p>JavaScript 中有两个机制可以“欺骗”词法作用域: eval(..) 和 with 。 前者可以对一段包 含一个或多个声明的“代码”字符串进行演算,并借此来修改已经存在的词法作用域(在 运行时)。后者本质上是通过将一个对象的引用 当作 作用域来处理,将对象的属性当作作 用域中的标识符来处理,从而创建了一个新的词法作用域(同样是在运行时)。</p>
<p>这两个机制的副作用是引擎无法在编译时对作用域查找进行优化,因为引擎只能谨慎地认 为这样的优化是无效的。使用这其中任何一个机制都 将 导致代码运行变慢。 不要使用它们。</p>
<h4 id="函数作用域和块作用域"><a href="#函数作用域和块作用域" class="headerlink" title="函数作用域和块作用域"></a>函数作用域和块作用域</h4><p><img src="https://user-gold-cdn.xitu.io/2018/5/29/163a9954593cc366?w=1689&amp;h=828&amp;f=jpeg&amp;s=160928" alt=""></p>
<p>函数是 JavaScript 中最常见的作用域单元。本质上,声明在一个函数内部的变量或函数会 在所处的作用域中“隐藏”起来,这是有意为之的良好软件的设计原则。</p>
<p>但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域, 也可以属于某个代码块(通常指 { .. } 内部)。</p>
<p>从 ES3 开始, try/catch 结构在 catch 分句中具有块作用域。在 ES6 中引入了 let 关键字( var 关键字的表亲), 用来在任意代码块中声明变量。 if(..) { let a = 2; } 会声明一个劫持了 if 的 { .. } 块的变量,并且将变量添加到这个块 中。</p>
<p>有些人认为块作用域不应该完全作为函数作用域的替代方案。两种功能应该同时存在,开 发者可以并且也应该根据需要选择使用何种作用域,创造可读、可维护的优良代码。</p>
<h4 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h4><p><img src="https://user-gold-cdn.xitu.io/2018/5/29/163a995873202ea4?w=1651&amp;h=539&amp;f=jpeg&amp;s=98748" alt=""></p>
<p>我们习惯将 var a = 2; 看作一个声明,而实际上 JavaScript 引擎并不这么认为。它将 var a 和 a = 2 当作两个单独的声明,第一个是编译阶段的任务,而第二个则是执行阶段的任务。</p>
<p>这意味着无论作用域中的声明出现在什么地方,都将在代码本身被执行前 首先 进行处理。 可以将这个过程形象地想象成所有的声明(变量和函数)都会被“移动”到各自作用域的最顶端,这个过程被称为提升。</p>
<p>声明本身会被提升,而包括函数表达式的赋值在内的赋值操作并不会提升。</p>
<p>要注意避免重复声明,特别是当普通的 var 声明和函数声明混合在一起的时候,否则会引 起很多危险的问题!</p>
<h4 id="作用域闭包"><a href="#作用域闭包" class="headerlink" title="作用域闭包"></a>作用域闭包</h4><p><img src="https://user-gold-cdn.xitu.io/2018/5/29/163a995bb92570eb?w=1549&amp;h=731&amp;f=jpeg&amp;s=158866" alt=""></p>
<p>闭包就好像从 JavaScript 中分离出来的一个充满神秘色彩的未开化世界,只有最勇敢的人 才能够到达那里。但实际上它只是一个标准,显然就是关于如何在函数作为值按需传递的 词法环境中书写代码的。</p>
<p>当函数可以记住并访问所在的词法作用域,即使函数是在当前词法作用域之外执行,这时 就产生了闭包。</p>
<p>如果没能认出闭包,也不了解它的工作原理,在使用它的过程中就很容易犯错,比如在循 环中。但同时闭包也是一个非常强大的工具,可以用多种形式来实现 模块 等模式。模块有两个主要特征:</p>
<p>(1)为创建内部作用域而调用了一个包装函数;<br>(2)包装函数的返回 值必须至少包括一个对内部函数的引用,这样就会创建涵盖整个包装函数内部作用域的闭 包。</p>
<p>现在我们会发现代码中到处都有闭包存在,并且我们能够识别闭包然后用它来做一些有用 的事!</p>
<h3 id="第二部分-this-和对象原型"><a href="#第二部分-this-和对象原型" class="headerlink" title="第二部分 this 和对象原型"></a>第二部分 this 和对象原型</h3><h4 id="this-全面解析"><a href="#this-全面解析" class="headerlink" title="this 全面解析"></a>this 全面解析</h4><p><img src="https://user-gold-cdn.xitu.io/2018/5/29/163a996bcbf28e91" alt=""></p>
<p>如果要判断一个运行中函数的 this 绑定,就需要找到这个函数的直接调用位置。找到之后 就可以顺序应用下面这四条规则来判断 this 的绑定对象。</p>
<ol>
<li><p>由 new 调用?绑定到新创建的对象。</p>
</li>
<li><p>由 call 或者 apply (或者 bind )调用?绑定到指定的对象。</p>
</li>
<li><p>由上下文对象调用?绑定到那个上下文对象。</p>
</li>
<li><p>默认:在严格模式下绑定到 undefined ,否则绑定到全局对象。</p>
</li>
</ol>
<p>一定要注意,有些调用可能在无意中使用默认绑定规则。如果想“更安全”地忽略 this 绑 定,你可以使用一个 DMZ 对象,比如 ø = Object.create(null) ,以保护全局对象。ES6中的箭头函数并不会使用四条标准的绑定规则, 而是根据当前的词法作用域来决定 this ,具体来说,箭头函数会继承外层函数调用的 this 绑定(无论 this 绑定到什么)。这 其实和 ES6 之前代码中的 self = this 机制一样。</p>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p><img src="https://user-gold-cdn.xitu.io/2018/6/4/163c85faf904cf73?w=1378&amp;h=708&amp;f=jpeg&amp;s=79898" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/4/163c85fd6750a810?w=1260&amp;h=798&amp;f=jpeg&amp;s=138155" alt=""></p>
<p>JavaScript 中的对象有字面形式(比如 var a = { .. } )和构造形式(比如 var a = new Array(..) )。字面形式更常用,不过有时候构造形式可以提供更多选项。</p>
<p>许多人都以为“JavaScript 中万物都是对象”,这是错误的。对象是 6 个(或者是 7 个,取 决于你的观点)基础类型之一。对象有包括 function 在内的子类型,不同子类型具有不同 的行为,比如内部标签 [object Array] 表示这是对象的子类型数组。</p>
<p>对象就是键 / 值对的集合。可以通过 .propName 或者 [“propName”] 语法来获取属性值。访 问属性时, 引擎实际上会调用内部的默认 [[Get]] 操作(在设置属性值时是 [[Put]] ), [[Get]] 操作会检查对象本身是否包含这个属性,如果没找到的话还会查找 [[Prototype]] 链(参见第 5 章)。</p>
<p>属性的特性可以通过属性描述符来控制,比如 writable 和 configurable 。此外,可以使用 Object.preventExtensions(..) 、 Object.seal(..) 和 Object.freeze(..) 来设置对象(及其 属性)的不可变性级别。</p>
<p>属性不一定包含值——它们可能是具备 getter/setter 的“访问描述符”。此外,属性可以是 可枚举或者不可枚举的,这决定了它们是否会出现在 for..in 循环中。</p>
<p>你可以使用 ES6 的 for..of 语法来遍历数据结构(数组、对象, 等等)中的值, for..of 会寻找内置或者自定义的 @@iterator 对象并调用它的 next() 方法来遍历数据值。</p>
<h4 id="混合对象”类”"><a href="#混合对象”类”" class="headerlink" title="混合对象”类”"></a>混合对象”类”</h4><p><img src="https://user-gold-cdn.xitu.io/2018/5/29/163a9977ad530352?w=1428&amp;h=862&amp;f=jpeg&amp;s=135448" alt=""></p>
<p>类是一种设计模式。 许多语言提供了对于面向类软件设计的原生语法。 JavaScript 也有类 似的语法,但是和其他语言中的类完全不同。</p>
<p>类意味着复制。</p>
<p>传统的类被实例化时,它的行为会被复制到实例中。类被继承时,行为也会被复制到子类 中。</p>
<p>多态(在继承链的不同层次名称相同但是功能不同的函数)看起来似乎是从子类引用父 类,但是本质上引用的其实是复制的结果。</p>
<p>JavaScript 并不会(像类那样)自动创建对象的副本。</p>
<p>混入模式(无论显式还是隐式)可以用来模拟类的复制行为,但是通常会产生丑陋并且脆 弱的语法,比如显式伪多态( OtherObj.methodName.call(this, …) ),这会让代码更加难 懂并且难以维护。</p>
<p>此外, 显式混入实际上无法完全模拟类的复制行为, 因为对象(和函数!别忘了函数也 是对象)只能复制引用, 无法复制被引用的对象或者函数本身。 忽视这一点会导致许多 问题。</p>
<p>总地来说,在 JavaScript 中模拟类是得不偿失的,虽然能解决当前的问题,但是可能会埋下更多的隐患。</p>
<h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><p><img src="https://user-gold-cdn.xitu.io/2018/5/29/163a997b039a7ade?w=1458&amp;h=603&amp;f=jpeg&amp;s=159321" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/29/163a997def15b21f?w=1458&amp;h=781&amp;f=jpeg&amp;s=178700" alt=""></p>
<p>如果要访问对象中并不存在的一个属性, [[Get]] 操作(参见第 3 章)就会查找对象内部 [[Prototype]] 关联的对象。这个关联关系实际上定义了一条“原型链”(有点像嵌套的作用域链),在查找属性时会对它进行遍历。</p>
<p>所有普通对象都有内置的 Object.prototype ,指向原型链的顶端(比如说全局作用域),如 果在原型链中找不到指定的属性就会停止。 toString() 、 valueOf() 和其他一些通用的功能 都存在于 Object.prototype 对象上,因此语言中所有的对象都可以使用它们。</p>
<p>关联两个对象最常用的方法是使用 new 关键词进行函数调用, 在调用的 章)中会创建一个关联其他对象的新对象。4个步骤(第2章)中会创建一个关联其他对象的新对象。</p>
<p>使用 new 调用函数时会把新对象的 .prototype 属性关联到“其他对象”。带 new 的函数调用 通常被称为“构造函数调用”,尽管它们实际上和传统面向类语言中的 类构造函数 不一样。</p>
<p>JavaScript 是 中的机制有一个核心区别, 那就是不会进行复制, 对象之间是通过内部的</p>
<p>虽然这些 机制和传统面向类语言中的“类初始化”和“类继承”很相似, 但是  javascript 机制和传统面向对象类语言中的“类初始化”和“类继承”很相似但是 javascript 中的机制有一个核心区别，就是不会进行复制，对象之间是通过内部的 [[Prototype]] 链关联的。</p>
<p>出于各种原因,以“继承”结尾的术语(包括“原型继承”)和其他面向对象的术语都无 法帮助你理解 JavaScript 的 真实 机制(不仅仅是限制我们的思维模式)。</p>
<p>相比之下,“委托”是一个更合适的术语,因为对象之间的关系不是 复制 而是委托。</p>
<h4 id="行为委托"><a href="#行为委托" class="headerlink" title="行为委托"></a>行为委托</h4><p><img src="https://user-gold-cdn.xitu.io/2018/5/29/163a998194b182d8?w=1754&amp;h=763&amp;f=jpeg&amp;s=132903" alt=""></p>
<p>在软件架构中你可以 选择是否 使用类和继承设计模式。大多数开发者理所当然地认为类是 唯一(合适)的代码组织方式,但是本章中我们看到了另一种更少见但是更强大的设计模式: 行为委托 。</p>
<p>行为委托认为对象之间是兄弟关系, 互相委托, 而不是父类和子类的关系。 JavaScript 的 [[Prototype]] 机制本质上就是行为委托机制。也就是说,我们可以选择在 JavaScript 中努 力实现类机制(参见第 4 和第 5 章),也可以拥抱更自然的 [[Prototype]] 委托机制。</p>
<p>当你只用对象来设计代码时,不仅可以让语法更加简洁,而且可以让代码结构更加清晰。</p>
<p>对象关联(对象之前互相关联)是一种编码风格,它倡导的是直接创建和关联对象,不把 它们抽象成类。对象关联可以用基于 [[Prototype]] 的行为委托非常自然地实现。</p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>思维导图能比较清晰的还原整本书的知识结构体系，如果你还没用看过这本书，可以按照这个思维导图的思路快速预习一遍，提高学习效率。学习新事物总容易遗忘，我比较喜欢在看书的时候用思维导图做些记录，便于自己后期复习，如果你已经看过了这本书，也建议你收藏复习。如果你有神马建议或则想法，欢迎留言或加我微信交流：646321933</p>
<p><a href="https://www.kancloud.cn/kancloud/you-dont-know-js-this-object-prototypes/516674" target="_blank" rel="external">你不知道的javascript上卷第二部分在线文档</a></p>
<p><a href="https://github.com/threerocks/studyFiles/blob/master/js/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%EF%BC%88%E4%B8%8A%E5%8D%B7%EF%BC%89.pdf" target="_blank" rel="external">你不知道的 javascript（上卷）PDF 下载地址</a></p>
<p><a href="https://github.com/bailinlin/Awsome-Front-End-Xmind" target="_blank" rel="external">思维导图下载地址</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2018/05/15/maidian/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/05/15/maidian/" itemprop="url">
                  埋点的实现原理了解一下么
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-15T16:08:20+08:00">
                2018-05-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2018/05/15/maidian/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/05/15/maidian/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>埋点，是网站分析的一种常用的数据采集方法。我们主要用来采集用户行为数据（例如页面访问路径，点击了什么元素）进行数据分析，从而让运营同学更加合理的安排运营计划。现在市面上有很多第三方埋点服务商，百度统计，友盟，growingIO 等大家应该都不太陌生，大多情况下大家都只是使用，最近我研究了下 web 埋点，你要不要了解下。</p>
<h3 id="现有埋点三大类型"><a href="#现有埋点三大类型" class="headerlink" title="现有埋点三大类型"></a>现有埋点三大类型</h3><blockquote>
<p>用户行为分析是一个大系统，一个典型的数据平台。由用户数据采集，用户行为建模分析，可视化报表展示几个模块构成。现有的埋点采集方案可以大致被分为三种，手动埋点，可视化埋点，无埋点</p>
</blockquote>
<ol>
<li>手动埋点<br> 手动代码埋点比较常见，需要调用埋点的业务方在需要采集数据的地方调用埋点的方法。优点是流量可控，业务方可以根据需要在任意地点任意场景进行数据采集，采集信息也完全由业务方来控制。这样的有点也带来了一些弊端，需要业务方来写死方法，如果采集方案变了，业务方也需要重新修改代码，重新发布。</li>
<li>可视化埋点<br> 可是化埋点是近今年的埋点趋势，很多大厂自己的数据埋点部门也都开始做这块。优点是业务方工作量少，缺点则是技术上推广和实现起来有点难（业务方前端代码规范是个大前提）。阿里的活动页很多都是运营通过可视化的界面拖拽配置实现，这些活动控件元素都带有唯一标识。通过埋点配置后台，将元素与要采集事件关联起来，可以自动生成埋点代码嵌入到页面中。</li>
<li>无埋点<br> 无埋点则是前端自动采集全部事件，上报埋点数据，由后端来过滤和计算出有用的数据，优点是前端只要加载埋点脚本。缺点是流量和采集的数据过于庞大，服务器性能压力山大，主流的 GrowingIO 就是这种实现方案。</li>
</ol>
<p>我们暂时放弃可视化埋点的实现，在 <code>手动埋点</code> 和 <code>无埋点</code> 上进行了尝试，为了便于描述，下文我会称采集脚本为 SDK。</p>
<h3 id="思考几个问题"><a href="#思考几个问题" class="headerlink" title="思考几个问题"></a>思考几个问题</h3><blockquote>
<p>埋点开发需要考虑很多内容，贯穿着不轻易动手写代码的原则，我们在开发前先思考下面这几个问题</p>
</blockquote>
<ol>
<li>我们要采集什么内容，进行哪些采集接口的约定</li>
<li>业务方通过什么方式来调用我们的采集脚本</li>
<li>手动埋点：SDK 需要封装一个方法给业务方进行调用，传参方式业务方可控</li>
<li>无埋点：考虑到数据量对于服务器的压力，我们需要对无埋点进行开关配置，可以配置进行哪些元素进行无埋点采集</li>
<li>用户标识：游客用户和登录用户的采集数据怎么进行区分关联</li>
<li>设备Id：用户通过浏览器来访问 web 页面，设备Id需要存储在浏览器上，同一个用户访问不同的业务方网站，设备Id要保持一样，怎么实现</li>
<li>单页面应用：现在流行的单页面应用和普通 web 页面的数据采集是否有差异</li>
<li>混合应用：app 与 h5 的混合应用我们要怎么进行通讯</li>
</ol>
<h4 id="我们要采集什么内容，进行哪些采集接口的约定"><a href="#我们要采集什么内容，进行哪些采集接口的约定" class="headerlink" title="我们要采集什么内容，进行哪些采集接口的约定"></a>我们要采集什么内容，进行哪些采集接口的约定</h4><p>第一期我们先实现对 PV（即页面浏览量或点击量） 、UV（一天内同个访客多次访问） 、点击量、用户的访问路径的基础指标的采集。精细化分析的流量转化需要和业务相关，需要和数据分析方做约定，我们预留扩展。所以我们的采集接口需要进行以下的约定</p>
<pre>

    {
        "header":{ // HTTP 头部
            "X-Device-Id":" 550e8400-e29b-41d4-a716-446655440000", //设备ID，用来区分用户设备
            "X-Source-Url":"https://www.baidu.com/", //源地址，关联用户的整个操作流程，用于用户行为路径分析，例如登录，到首页，进入商品详情，退出这一整个完整的路径
            "X-Current-Url":"", //当前地址，用户行为发生的页面
            "X-User-Id":"",//用户ID，统计登录用户行为
        },
        "body":[{ // HTTP Body体
            "PageSessionID":"", //页面标识ID，用来区分页面事件，例如加载和离开我们会发两个事件，这个标识可以让我们知道这个事件是发生在一个页面上
            "Event":"loaded", //事件类型，区分用户行为事件
            "PageTitle":  "埋点测试页",  //页面标题，直观看到用户访问页面
            "CurrentTime":  “1517798922201”,  //事件发生的时间
            "ExtraInfo":  {
             }    //扩展字段，对具体业务分析的传参
        }]
    }

</pre>

<p>以上就是我们现在约定好了的通用的事件采集的接口，所传的参数基本上会根据采集事件的不同而发生变化。但是在用户的整一个访问行为中，用户的设备是不会变化的，如果你想采集设备信息可以重新约定一个接口，在整个采集开始之前发送设备信息，这样可以避免在事件采集接口上重复采集固定数据。</p>
<pre>

    {
        "header":{ // HTTP 头部
              "X-Device-Id"  ："550e8400-e29b-41d4-a716-446655440000"  ,      //  设备id
        },
        "body":{ // HTTP Body体
                  "DeviceType":  "web" ,   //设备类型
                 "ScreenWide"  :  768 , //  屏幕宽
                 "ScreenHigh":  1366 , //  屏幕高
                 "Language":    "zh-cn"  //语言
        }
    }

</pre>

<h4 id="业务方通过什么方式来调用我们的采集脚本"><a href="#业务方通过什么方式来调用我们的采集脚本" class="headerlink" title="业务方通过什么方式来调用我们的采集脚本"></a>业务方通过什么方式来调用我们的采集脚本</h4><p>埋点应该让调用的业务方，尽可能少有工作量，最好是什么都不用做，😁，但是实现起来有点难额。我们采用的方案是让业务方在代码里通过 script 脚本来引用我们的 SDK ，业务方只要配置一些需要的参数进行埋点定制（👆我们讲到过的无埋点的流量控制），然后什么都不做就可以进行基础数据的采集。</p>
<pre>

    (function() {
                var collect = document.createElement('script');
                collect.type = 'text/javascript';
                collect.async = true;
                collect.src =  'http://collect.trc.com/index.js';
                var s = document.getElementsByTagName('script')[0];
                s.parentNode.insertBefore(collect, s);
        })();


    //用户自定义要进行无埋点采集的元素，如果不进行无埋点采集，可以不配置
     var _XT = [];
      _XT.push(['Target','div']);

</pre>

<h4 id="手动埋点：SDK"><a href="#手动埋点：SDK" class="headerlink" title="手动埋点：SDK"></a>手动埋点：SDK</h4><p>如果业务方需要采集更多业务定制的数据，可以调用我们暴露出的方法进行采集</p>
<pre>

    //自定义事件
      sdk.dispatch('customEvent',{extraInfo:'自定义事件的额外信息'})

</pre>

<h4 id="游客与用户关联"><a href="#游客与用户关联" class="headerlink" title="游客与用户关联"></a>游客与用户关联</h4><p>我们使用 userId 来做用户标识，同一个设备的用户，从游客用户切换到登录用户，如果我们要把他们关联起来，需要有一个设备Id 做关联</p>
<h4 id="web-设备Id"><a href="#web-设备Id" class="headerlink" title="web 设备Id"></a>web 设备Id</h4><p>用户通过浏览器来访问 web 页面，设备Id需要存储在浏览器上，同一个用户访问不同的业务方网站，设备Id要保持一样。web 变量存储，我们第一时间想到的就是 cookie，sessionStorage，localStorage，但是这3种存储方式都和访问资源的域名相关。我们总不能每次访问一个网站就新建一个设备指纹吧，所以我们需要通过一个方法来跨域共享设备指纹</p>
<p>我们想到的方案是，通过嵌套 iframe 加载一个静态页面，在 iframe 上加载的域名上存储设备id，通过跨域共享变量获取设备id，共享变量的原理是采用了iframe 的 contentWindow通讯，通过 postMessage 获取事件状态，调用封装好的回调函数进行数据处理具体的实现方式</p>
<pre>

    //web 应用，通过嵌入 iframe 进行跨域 cookie 通讯，设置设备id,
        collect.setIframe = function () {
            var that = this
            var iframe = document.createElement('iframe')
            iframe.id = "frame",
            iframe.src = 'http://collectiframe.trc.com' // 配置域名代理，目的是让开发测试生产环境代码一致
            iframe.style.display='none' //iframe 设置的目的是用来生成固定的设备id，不展示
            document.body.appendChild(iframe)

            iframe.onload = function () {
                    iframe.contentWindow.postMessage('loaded','*');
            }

            //监听message事件，iframe 加载完成，获取设备id ，进行相关的数据采集
            helper.on(window,"message",function(event){
                that.deviceId = event.data.deviceId

                if(event.data && event.data.type == 'loaded'){
                    that.sendDevice(that.getDevice(), that.deviceUrl);
                    setTimeout(function () {
                        that.send(that.beforeload)
                        that.send(that.loaded)
                    },1000)
                }
            })
        }

</pre>

<p>iframe 与 SDK 通讯</p>
<pre>

    function receiveMessageFromIndex ( event ) {
        getDeviceInfo() // 获取设备信息
        var data =  {
                deviceId: _deviceId,
                type:event.data
        }

        event.source.postMessage(data, '*'); // 将设备信息发送给 SDK
    }

    //监听message事件
    if(window.addEventListener){
            window.addEventListener("message", receiveMessageFromIndex, false);
    }else{
            window.attachEvent("onmessage", receiveMessageFromIndex, false)

</pre>

<p>如果你想知道可以看我的另一篇博客 <a href="https://bailinlin.github.io/2018/03/05/cookie-share/" target="_blank" rel="external">web 浏览器指纹跨域共享</a></p>
<h4 id="单页面应用：现在流行的单页面应用和普通-web-页面的数据采集是否有差异"><a href="#单页面应用：现在流行的单页面应用和普通-web-页面的数据采集是否有差异" class="headerlink" title="单页面应用：现在流行的单页面应用和普通 web 页面的数据采集是否有差异"></a>单页面应用：现在流行的单页面应用和普通 web 页面的数据采集是否有差异</h4><blockquote>
<p>我们知道单页面应用都是无刷新的页面加载，所以我们在页面<code>跳转</code>的处理和我们的普通的页面会有所不同。单页面应用的路由插件运用了 window 自带的无刷新修改用户浏览记录的方法，pushState 和 replaceState。</p>
</blockquote>
<p>window 的 history 对象 提供了两个方法，能够无刷新的修改用户的浏览记录，pushSate，和 replaceState，区别的 pushState 在用户访问页面后面添加一个访问记录， replaceState 则是直接替换了当前访问记录，所以我们只要改写 history 的方法，在方法执行前执行我们的采集方法就能实现对单页面应用的页面跳转事件的采集了</p>
<pre>

     // 改写思路：拷贝 window 默认的 replaceState 函数，重写 history.replaceState 在方法里插入我们的采集行为，在重写的 replaceState 方法最后调用，window 默认的 replaceState 方法

        collect = {}
        collect.onPushStateCallback : function(){}  // 自定义的采集方法

        (function(history){
            var replaceState = history.replaceState;   // 存储原生 replaceState
            history.replaceState = function(state, param) {     // 改写 replaceState
               var url = arguments[2];
               if (typeof collect.onPushStateCallback == "function") {
                     collect.onPushStateCallback({state: state, param: param, url: url});   //自定义的采集行为方法
               }
               return replaceState.apply(history, arguments);    // 调用原生的 replaceState
            };
         })(window.history);

</pre>


<p>这块介绍起来也比较的复杂，如果你想了解更多，可以看我的另一篇博客<a href="https://bailinlin.github.io/2018/04/28/history/" target="_blank" rel="external">你需要知道的单页面路由实现原理</a></p>
<h4 id="混合应用：app-与-h5-的混合应用我们要怎么进行通讯"><a href="#混合应用：app-与-h5-的混合应用我们要怎么进行通讯" class="headerlink" title="混合应用：app 与 h5 的混合应用我们要怎么进行通讯"></a>混合应用：app 与 h5 的混合应用我们要怎么进行通讯</h4><blockquote>
<p>现在大部分的应用都不是纯原生的应用， app 与 h5 的混合的应用是现在的一种主流。</p>
</blockquote>
<p>纯 web 数据采集我们考虑到前端存储数据容易丢失，我们在每一次事件触发的时候都用采集接口传输采集到的数据。考虑到现在很多用户的手机会有流量管家的软件监控，如果在 App 中 h5 还是采集到数据就传输给服务端，很有可能会让流量管家检测到，给用户报警，从而使得用户不再信任你的 App , 所以我们在用户操作的时候将数据传给 app 端，存储到 app。用户切换应用到后台的时候，通过 app 端的 SDK 打包传输到服务器，我们给 app 提供的方法封装了一个适配器</p>
<pre>

    // app 与 h5 混合应用，直接将数信息发给 app
    collect.saveEvent = function (jsonString) {

        collect.dcpDeviceType && setTimeout(function () {
            if(collect.dcpDeviceType=='android'){
                android.saveEvent(jsonString)
            } else {
                window.webkit && window.webkit.messageHandlers ? window.webkit.messageHandlers.nativeBridge.postMessage(jsonString) : window.postBridgeMessage(jsonString)
            }

        },1000)
        }

</pre>

<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><blockquote>
<p>通过上面几个问题的思考，我们对埋点的实现大致已经有了一些想法，我们使用思维导图来还原下我们即将要做的事情，图片记得放大看哦，太小了可能看不清。</p>
</blockquote>
<ol>
<li>我们需要暴露给业务方调用的方法<br><img src="/images/sdk/method.jpeg" alt="nginx作用域"></li>
<li>我们需要处理的事件类型<br><img src="/images/sdk/event.jpeg" alt="nginx作用域"></li>
<li>SDK 的基本实现思路<br><img src="/images/sdk/logic.jpeg" alt="nginx作用域"></li>
</ol>
<h3 id="我们来看下几个核心代码的实现"><a href="#我们来看下几个核心代码的实现" class="headerlink" title="我们来看下几个核心代码的实现"></a>我们来看下几个核心代码的实现</h3><h4 id="工具方法"><a href="#工具方法" class="headerlink" title="工具方法"></a>工具方法</h4><p>我们定义了几个工具方法，提高开发的幸福指数 😝</p>
<pre>

        var helper = {};

        // 生成一个唯一的标识，pageSessionId （用这个变量来关联开始加载、加载完成、离开页面的事件，计算出页面加菜时间，停留时间）
        helper.uuid = function(){}

        // 元素绑定事件监听，兼容浏览器到IE8
        helper.on = function(){}

        //元素移除事件监听的适配器函数，兼容浏览器到IE8
        helper.remove = function(){}

        //将json转为字符串,事件传输的参数类型转化
        helper.changeJSON2Query = function(){}

        //将相对路径解析成文档全路径
        helper.normalize = function(){}
</pre>

<h4 id="采集逻辑"><a href="#采集逻辑" class="headerlink" title="采集逻辑"></a>采集逻辑</h4><pre>

        var collect = {
            deviceUrl:'http://collect.trc.com/rest/collect/device/h5/v1',
            eventUrl:'http://collect.trc.com/rest/collect/event/h5/v1',
            isuploadUrl:'http://collect.trc.com/rest/collect/isupload/app/v1',
            parmas:{ ExtraInfo:{} },
            device:{}
        };

        //获取埋点配置
        collect.setParames = function(){}

        //更新访问路径及页面信息
        collect.updatePageInfo = function(){}

        //获取事件参数
        collect.getParames = function(){}

        //获取设备信息
        collect.getDevice = function(){}

        //事件采集
        collect.send = function(){}

        //设备采集
        collect.sendDevice = function(){}

        //判断才否采集，埋点采集的开关
        collect.isupload = function(){

            1. 判断是否采集，不采集就注销事件监听（项目中区分游客身份和用户身份的采集情况，这个方法会被判断两次）
            2. 采集则判断是否已经采集过
                a.已经采集过不做任何操作
                b.没有采集过添加事件监听
            3. 判断是 混合应用还是纯 web 应用
                a.如果是web 应用，调用 collect.setIframe 设置 iframe
                b.如果是混合应用 将开始加载和加载完成事件传输给 app
        }

        //点击事件处理函数
        collect.clickHandler = function(){}

        //离开页面的事件处理函数
        collect.beforeUnloadHandler = function(){}

        //页面回退事件处理函数
        collect.onPopStateHandler = function(){}

        //系统事件初始化，注册离开事件，浏览器后退事件
        collect.event = function(){}

        //获取记录开始加载数据信息
        collect.getBeforeload = function(){}

        //存储加载完成，获取设备类型，记录加载完成信息
        collect.onload = function(){

            1. 判断cookie是否有存设备类型信息，有表示混合应用
            2. 采集加载完成时间等信息
            3. 调用 collect.isupload 判断是否进行采集
        }

        //web 应用，通过嵌入 iframe 进行跨域 cookie 通讯，设置设备id
        collect.setIframe = function(){}

        //app 与 h5 混合应用，直接将数信息发给 app,判断设备类型做原生方法适配器
        collect.saveEvent = function(){}

        //采集自定义事件类型
        collect.dispatch = function(){}

        //将参数 userId 存入sessionStorage
        collect.storeUserId = function(){}

        //采集H5信息,如果是混合应用，将采集到的信息发送给 app 端
        collect.saveEventInfo = function(){}

        //页面初始化调用方法
        collect.init = function(){

            1. 获取开始加载的采集信息
            2. 获取 SDK 配置信息，设备信息
            3. 改写 history 两个方法，单页面应用页面跳转前调用我们自己的方法
            4. 页面加载完成，调用 collect.onload 方法

        }


        collect.init(); // 初始化

        //暴露给业务方调用的方法
        return {
            dispatch:collect.dispatch,
            storeUserId:collect.storeUserId,
        }
</pre>


<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><blockquote>
<p>代码的篇幅比较长，就不放在博客里了，感兴趣的同学可以在 <a href="https://github.com/bailinlin/web-sdk" target="_blank" rel="external">github</a> 上看完整的项目。如果你有什么不懂的或者想和我交流的，欢迎在文章下面留言联系我</p>
</blockquote>
<p><a href="https://bailinlin.github.io/2018/03/05/cookie-share/" target="_blank" rel="external">web 浏览器指纹跨域共享</a><br><a href="https://bailinlin.github.io/2018/04/28/history/" target="_blank" rel="external">你需要知道的单页面路由实现原理</a></p>
<p><a href="https://www.zhihu.com/question/36411025" target="_blank" rel="external">数据埋点是什么？设置埋点的意义是什么？</a><br><a href="https://sensorsdata.cn/blog/shu-ju-jie-ru-yu-mai-dian/" target="_blank" rel="external">数据采集与埋点</a><br><a href="https://tech.meituan.com/mt-mobile-analytics-practice.html" target="_blank" rel="external">美团点评前端无痕埋点实践</a><br><a href="https://www.zhihu.com/question/20448467" target="_blank" rel="external">如何清楚易懂的解释“UV和PV＂的定义</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2018/05/07/vue-cli-webpack/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/05/07/vue-cli-webpack/" itemprop="url">
                  vue-cli#4.7项目结构分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-07T14:11:04+08:00">
                2018-05-07
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2018/05/07/vue-cli-webpack/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/05/07/vue-cli-webpack/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>使用过 vue 进行项目开发的同学，一定知道或者使用过 vue-cli 脚手架，他能够很好的搭建项目结构和工程，让我们能够把足够的精力放在业务开发上。也正是因为这样，很多时候我们会因为项目工期短等原因来不及或则不会刻意去了解项目工程配置，我们今天不去介绍脚手架的使用，我们去了解下脚手架为我们创建好的打包工程是怎么做的。</p>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p><code></code></p>
<pre><code>├── build --------------------------------- webpack相关配置文件
│   ├── build.js --------------------------webpack打包配置文件
│   ├── check-versions.js ------------------------------ 检查npm,nodejs版本
│   ├── logo.png ---------------------------------- 项目 logo
│   ├── utils.js --------------------------------------- 配置资源路径，配置css加载器
│   ├── vue-loader.conf.js ----------------------------- 配置css加载器等
│   ├── webpack.base.conf.js --------------------------- webpack基本配置
│   ├── webpack.dev.conf.js ---------------------------- 用于开发的webpack设置
│   ├── webpack.prod.conf.js --------------------------- 用于打包的webpack设置
├── config ---------------------------------- 配置文件
       ├── index.js ------------------------------ 开发和生产环境配置文件
├── node_modules ---------------------------- 存放依赖的目录
├── src ------------------------------------- 源码
│   ├── assets ------------------------------ 静态文件
│   ├── components -------------------------- 组件
│   ├── main.js ----------------------------- 主js
│   ├── App.vue ----------------------------- 项目入口组件
│   ├── router ------------------------------ 路由
├── package.json ---------------------------- node配置文件
├── .babelrc--------------------------------- babel配置文件
├── .editorconfig---------------------------- 编辑器配置
├── .gitignore------------------------------- 配置git可忽略的文件
</code></pre><p></p>
<h3 id="webpack配置划重点"><a href="#webpack配置划重点" class="headerlink" title="webpack配置划重点"></a>webpack配置划重点</h3><blockquote>
<p>在看项目配置文件之前，我们先了解下 webpack 几个常用的工具和插件，如果你已经十分熟悉，你可以跳过这一小节，直接去看，配置文件解析</p>
</blockquote>
<h4 id="1-path模块"><a href="#1-path模块" class="headerlink" title="1. path模块"></a>1. path模块</h4><p>path 是 node.js 中的一个模块，用于处理目录的对象，提高开发效</p>
<pre>

    常用方法：
    path.join(): 用于连接路径。该方法的主要用途在于，会正确使用当前系统的路径分隔符，Unix 系统是 ”/“，Windows系统是 ”\“
    path.resolve() 用于将相对路径转为绝对路径

    常使用的文件路径
    __dirname: 总是返回被执行的 js 所在文件夹的绝对路径
    __filename: 总是返回被执行的 js 的绝对路径
    process.cwd(): 总是返回运行 node 命令时所在的文件夹的绝对路径

</pre>

<h4 id="2-process"><a href="#2-process" class="headerlink" title="2.process"></a>2.process</h4><p>process对象是Node的一个全局对象，提供当前Node进程的信息。</p>
<pre>

    process 对象提供一系列属性，用于返回系统信息
    process.argv：返回当前进程的命令行参数数组。
    process.env：返回一个对象，成员为当前Shell的环境变量，比如process.env.HOME
    process.pid：当前进程的进程号

</pre>

<h4 id="3-Source-map"><a href="#3-Source-map" class="headerlink" title="3.Source map"></a>3.Source map</h4><p>简单说，<a href="http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html" target="_blank" rel="external">Source map</a>就是一个信息文件，里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。有了它，出错的时候，debug 工具将直接显示原始代码，而不是转换后的代码。这无疑给开发者带来了很大方便。<a href="https://juejin.im/post/58293502a0bb9f005767ba2f" target="_blank" rel="external">webpack 的 devtool里有 7种 SourceMap 模式</a></p>
<table>
<thead>
<tr>
<th>模式</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>eval</td>
<td>每个 module 会封装到 eval 里包裹起来执行，并且会在末尾追加注释 //@ sourceURL</td>
</tr>
<tr>
<td>source-map</td>
<td>生成一个 SourceMap 文件.</td>
</tr>
<tr>
<td>hidden-source-map</td>
<td>和 source-map 一样，但不会在 bundle 末尾追加注释.</td>
</tr>
<tr>
<td>inline-source-map</td>
<td>生成一个 DataUrl 形式的 SourceMap 文件.</td>
</tr>
<tr>
<td>eval-source-map</td>
<td>每个 module 会通过 eval() 来执行，并且生成一个 DataUrl 形式的 SourceMap .</td>
</tr>
<tr>
<td>cheap-source-map</td>
<td>生成一个没有列信息（column-mappings）的 SourceMaps 文件，不包含 loader 的 sourcemap（譬如 babel 的 sourcemap）</td>
</tr>
<tr>
<td>cheap-module-source-map</td>
<td>生成一个没有列信息（column-mappings）的 SourceMaps 文件，同时 loader 的 sourcemap 也被简化为只包含对应行的。</td>
</tr>
</tbody>
</table>
<h4 id="4-webpack-merge"><a href="#4-webpack-merge" class="headerlink" title="4. webpack-merge"></a>4. webpack-merge</h4><p>开发环境(development)和生产环境(production)的构建目标差异很大。在开发环境中，我们需要具有强大的、具有实时重新加载(live reloading)或热模块替换(hot module replacement)能力的 source map 和 localhost server。而在生产环境中，我们的目标则转向于关注更小的 bundle，更轻量的 source map，以及更优化的资源，以改善加载时间。由于要遵循逻辑分离，我们通常建议为每个环境编写彼此独立的 webpack 配置。通用的配置部分，我们抽象出一个公共文件，通过 <a href="https://doc.webpack-china.org/guides/production/" target="_blank" rel="external">webpack-merge</a> 工具的“通用”配置，我们不必在环境特定的配置中重复代码。</p>
<h4 id="5-ExtractTextWebpackPlugin"><a href="#5-ExtractTextWebpackPlugin" class="headerlink" title="5. ExtractTextWebpackPlugin"></a>5. ExtractTextWebpackPlugin</h4><p><a href="https://doc.webpack-china.org/plugins/extract-text-webpack-plugin/" target="_blank" rel="external">ExtractTextWebpackPlugin</a> 插件通常用来做样式文件的分离，被分离的文件不会被内嵌到  JS bundle 中，而会被放到一个单独的文件中，在样式文件比较大的时候，能够提前样式的加载,配置示例如下</p>
<pre>

    const ExtractTextPlugin = require("extract-text-webpack-plugin");
    module.exports = {
       module: {
          rules: [
          {
             test: /\.css$/,
             use: ExtractTextPlugin.extract({
             fallback: "style-loader",
             use: "css-loader"
          })
       }]
    },
        plugins: [
            new ExtractTextPlugin("styles.css"),
        ]
    }

</pre>

<p>它会将所有的入口 chunk(entry chunks)中引用的 *.css，移动到独立分离的 CSS 文件。因此，你的样式将不再内嵌到 JS bundle 中，而是会放到一个单独的 CSS 文件（即 styles.css）当中。 如果你的样式文件大小较大，这会做更快提前加载，因为 CSS bundle 会跟 JS bundle 并行加载。</p>
<h4 id="6-html-webpack-plugin"><a href="#6-html-webpack-plugin" class="headerlink" title="6.html-webpack-plugin"></a>6.html-webpack-plugin</h4><p>如果你有多个 webpack 入口点， 他们都会在生成的HTML文件中的 script 标签内。如果你有任何 CSS assets 在 webpack 的输出中（例如， 利用ExtractTextPlugin提取CSS）， 那么这些将被包含在HTML head中的<link>标签内。通常在开发中，我们为了避免 CDN 和浏览器的缓存通常会个输出文件 bundle.js 加上一个hash 值例如 <code>[hash].bundle.js</code>，使用 <a href="https://doc.webpack-china.org/plugins/html-webpack-plugin/" target="_blank" rel="external">html-webpack-plugin</a> 能够在创建新的 html 文件的时候将我们把带有哈希值的 bundle.js 引用到 html 文件.</p>
<h4 id="7-optimize-css-assets-webpack-plugin"><a href="#7-optimize-css-assets-webpack-plugin" class="headerlink" title="7.optimize-css-assets-webpack-plugin"></a>7.optimize-css-assets-webpack-plugin</h4><p>用来优化从脚本里提炼出来的 css ，配置示例如下</p>
<pre>

    var OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin');
    module.exports = {
      module: {
        rules: [
          {
            test: /\.css$/,
            loader: ExtractTextPlugin.extract('style-loader', 'css-loader')
          }
        ]
      },
      plugins: [
        new ExtractTextPlugin('styles.css'),
        new OptimizeCssAssetsPlugin({
          assetNameRegExp: /\.optimize\.css$/g,
          cssProcessor: require('cssnano'),
          cssProcessorOptions: { discardComments: { removeAll: true } },
          canPrint: true
        })
      ]
    };
</pre>

<h4 id="8-CopyWebpackPlugin"><a href="#8-CopyWebpackPlugin" class="headerlink" title="8.CopyWebpackPlugin"></a>8.CopyWebpackPlugin</h4><p><a href="https://doc.webpack-china.org/plugins/copy-webpack-plugin/" target="_blank" rel="external">CopyWebpackPlugin</a>从插件名称上我们不难看出他的作用，通常用来拷贝资源，对项目文件进行归类整合</p>
<h4 id="9-friendly-errors-webpack-plugin"><a href="#9-friendly-errors-webpack-plugin" class="headerlink" title="9.friendly-errors-webpack-plugin"></a>9.friendly-errors-webpack-plugin</h4><p><a href="https://www.npmjs.com/package/friendly-errors-webpack-plugin" target="_blank" rel="external">friendly-errors-webpack-plugin</a>能够更好在终端看到webapck运行的警告和错误，提高开发体验</p>
<h4 id="10-UglifyjsWebpackPlugin"><a href="#10-UglifyjsWebpackPlugin" class="headerlink" title="10.UglifyjsWebpackPlugin"></a>10.UglifyjsWebpackPlugin</h4><p><a href="https://doc.webpack-china.org/plugins/uglifyjs-webpack-plugin/" target="_blank" rel="external">UglifyjsWebpackPlugin</a>用来压缩 js 代码</p>
<h4 id="11-开发中-Server-DevServer"><a href="#11-开发中-Server-DevServer" class="headerlink" title="11.开发中 Server(DevServer)"></a>11.开发中 Server(DevServer)</h4><p>webpack 项目服务，我们通常会在开发阶段用来配置项目的热刷新，服务压缩，项目代理等，常用的几个配置参数介绍如下</p>
<pre>

    const config = require('../config')

    // config 文件里做了用户自定的服务参数配置

    devServer: {
        clientLogLevel: 'warning',  // 在开发攻击的控制台中显示信息，便于开发调试，你可以将参数配置成 "none" 来进行关闭
         historyApiFallback: { // 当使用 HTML5 History API 时，任意的 404 响应都可能需要被替代为 index.html
            rewrites: [
               { from: /.*/, to: path.posix.join(config.dev.assetsPublicPath, 'index.html') },
            ],
         },
         hot: true,   //启用项目的热刷新，即模块热替换特性
         contentBase: false,   // 告诉服务器从哪里提供内容。只有在你想要提供静态文件时才需要。这里禁用，因为配置了 CopyWebpackPlugin 的使用
         compress: true,
         host: HOST || config.dev.host,   //指定使用一个域名。默认是 localhost
         port: PORT || config.dev.port,   //指定要监听请求的端口号：
         open: config.dev.autoOpenBrowser, //open 参数配置，如果配置成 true ，项目启动后会自动打开浏览器
         overlay: config.dev.errorOverlay   //当有错误或则警告的时候在页面上显示一个全屏的遮罩提示
             ? { warnings: false, errors: true }
             : false,
         publicPath: config.dev.assetsPublicPath, //此路径下的打包文件可在浏览器中访问
         proxy: config.dev.proxyTable,           //代理API的请求
         quiet: true,       //启用 quiet 后，除了初始启动信息之外的任何内容都不会被打印到控制台,特别是使用了 FriendlyErrorsPlugin 插件的时候
         watchOptions: {   //与监视文件相关的控制选项。是否使用轮询
               poll: config.dev.poll,
         }
    },

</pre>


<h3 id="配置文件解析"><a href="#配置文件解析" class="headerlink" title="配置文件解析"></a>配置文件解析</h3><blockquote>
<p>通过了解了上面的配置，我们应该对 webpack 的常用插件和工具有了一定了解，我们来看下 vue-cli 脚手架给我们生成的配置情况</p>
</blockquote>
<h4 id="config-js"><a href="#config-js" class="headerlink" title="config.js"></a>config.js</h4><pre>

'use strict'

const path = require('path') // 引用项目的 path 模块

module.exports = {
  dev: {

    // 路径配置
    assetsSubDirectory: 'static',
    assetsPublicPath: '/',
    proxyTable: {},

    // 各种开发服务配置
    host: 'localhost', // 开发环境域名 可以被 node 全局变量process.env.HOST 重写
    port: 8080, //配置开发服务端口，可以被 node 全局变量 process.env.PORT 重写, 需要使用未被占用的端口
    autoOpenBrowser: false, //服务启动是否自动代开浏览器
    errorOverlay: true,   //是否在发生错误的时候，在页面整屏增加一个错误遮罩
    notifyOnErrors: true,  //是否通知错误 ，在我们的项目配置中和 friendly-errors-webpack-plugin 结合使用
    poll: false, // 服务监听是否轮询操作

    // 配饰是否使用 Eslint Loader 进行语法检测
    // 如果使用，在开发构建阶段，会对你的代码会进行检测
    // 检测出来的警告和错误会白展示在开发工具的控制台

    useEslint: true,  //进行语法检测

    // 配置是否将 eslint 语法检测的警告和错误展示在页面整屏的遮罩上

    showEslintErrorsInOverlay: false,  // 语法检测的警告和错误不展示在遮罩上

    /**
     * Source Maps
     */

    // https://webpack.js.org/configuration/devtool/#development
    // 在上面的介绍中，我们知道 source map 是用来将我们构建后被转化的代码对应构建前的代码，便于 debug
    // cheap-module-eval-source-map 和我们介绍的 cheap-module-source-map 很类似，但是 SourceMap 会被作为数据添加到包中
    devtool: 'cheap-module-eval-source-map',

    // 如果你的开发工具不能进行 vue-files 的 debug ，可以将以下设置设置成 false

    cacheBusting: true,

    cssSourceMap: true
  },

  build: {
    // index.html 文件模板
    index: path.resolve(__dirname, '../dist/index.html'),

    // 打包路径配置
    assetsRoot: path.resolve(__dirname, '../dist'),
    assetsSubDirectory: 'static',
    assetsPublicPath: '/',

    /**
     * Source Maps
     */

    //生产环境 source map 配置

    productionSourceMap: true,
    devtool: '#source-map',

    // 因为很多的主流服务都会 通过 gzip 压缩过你的所有静态资源，我们的配置默认不开启 gzip
    // 如果要设置成开启,请先确保已经安装好 compression-webpack-plugin 插件
    productionGzip: false,
    productionGzipExtensions: ['js', 'css'],

    // 启动 build 命令的时候，额外添加一个参数，打包后会自动生成一个分析报告文件，例如 npm run build --report ，可以通过配置 true ，false 来关闭
    bundleAnalyzerReport: process.env.npm_config_report
  }
}

</pre>

<h4 id="check-versions-js"><a href="#check-versions-js" class="headerlink" title="check-versions.js"></a>check-versions.js</h4><p>这个文件主要是用来检测当前环境中的node和npm版本和我们需要的是否一致的。</p>
<pre>

    'use strict'
    const chalk = require('chalk')  // 改变命令行中的字体颜色，大致这样用chalk.blue('Hello world')
    const semver = require('semver')  //是用来对特定的版本号做判断的

    const packageConfig = require('../package.json')  // 项目 npm 配置文件，获取依赖及版本信息，requrie返回的就是json对象
    const shell = require('shelljs') //用来执行Unix系统命令，调用系统命令更加方便

    //把cmd这个参数传递的值转化成前后没有空格的字符串，也就是版本号
    function exec (cmd) {
      return require('child_process').execSync(cmd).toString().trim()
    }


    const versionRequirements = [
      {
        name: 'node',
        currentVersion: semver.clean(process.version),  // 提取进程版本信息转化成规定格式，也就是 '  =v1.2.3  ' -> '1.2.3' 这种功能
        versionRequirement: packageConfig.engines.node // package.json 的 node 的版本信息
      }
    ]

    if (shell.which('npm')) {
      versionRequirements.push({
        name: 'npm',
        currentVersion: exec('npm --version'),   //当前的版本信息
        versionRequirement: packageConfig.engines.npm //package.json 的 node 的版本信息
      })
    }

    module.exports = function () {
      const warnings = []

      for (let i = 0; i < versionRequirements.length; i++) {
        const mod = versionRequirements[i]

        // 如果当前版本号不符合 package.json 要求的版本号，红色表示当前版本信息，绿色表示要求的版本信息，添加到 warnings 待输出
        if (!semver.satisfies(mod.currentVersion, mod.versionRequirement)) {
          warnings.push(mod.name + ': ' +
            chalk.red(mod.currentVersion) + ' should be ' +
            chalk.green(mod.versionRequirement)
          )
        }
      }

      //输出版本号不相符的提示 warnings
      if (warnings.length) {
        console.log('')
        console.log(chalk.yellow('To use this template, you must update following to modules:'))
        console.log()

        for (let i = 0; i < warnings.length; i++) {
          const warning = warnings[i]
          console.log('  ' + warning)
        }

        console.log()
        process.exit(1)
      }
    }


</pre>

<h4 id="build-js"><a href="#build-js" class="headerlink" title="build.js"></a>build.js</h4><pre>

    'use strict'

    //打包前判断当先开发环境的 node 和 npm 版本和 package.json 要求的时候一样
    require('./check-versions')()

    process.env.NODE_ENV = 'production'

    const ora = require('ora')  // 在用户打包的时候能够让用户知道正在进行，一个加载中的样式，转啊转
    const rm = require('rimraf') //这个模块是用来清除之前的打的包，因为在vue-cli中每次打包会生成不同的hash
    const path = require('path') //node 路径模块，便于我们操作文件路径
    const chalk = require('chalk') //带颜色的输出模块，能在控制台中输出不同的样色
    const webpack = require('webpack') //webpack 不解释
    const config = require('../config') // 项目中的配置文件，👆上面已经进行了配置介绍
    const webpackConfig = require('./webpack.prod.conf') // 生产环境的配置文件


    const spinner = ora('building for production...')// 实例一个打包加载中实例
    spinner.start() //开始转圈，营造一个正在打包的场景

    // 删除上一次打包的文件，删除成功，开始按照生产环境配置进行打包
    rm(path.join(config.build.assetsRoot, config.build.assetsSubDirectory), err => {
      if (err) throw err


        //开始打包，打包结束停止 spinner 转圈，有报错则在控制台输出
      webpack(webpackConfig, (err, stats) => {
        spinner.stop()
        if (err) throw err

        // node 环境里的输出配置，process.stdout.write 你可以理解成 js 里的 console
        process.stdout.write(stats.toString({
          colors: true, //让打包的时候有颜色。
          modules: false,  //去掉内置模块信息
          children: false, // 去掉子模块,如果你使用了 ts-loader，设置成 true 会在打包构建阶段展示错误信息
          chunks: false, // 增加包信息（设置为 false 能允许较少的冗长输出）
          chunkModules: false //去除包里内置模块的信息
        }) + '\n\n')


         //打包出错在控制台输出 Build failed with errors ，退出打包程序
        if (stats.hasErrors()) {
          console.log(chalk.red('  Build failed with errors.\n'))
          process.exit(1)
        }

        //打包成功则输出 Build complete 结束打包
        console.log(chalk.cyan('  Build complete.\n'))
        console.log(chalk.yellow(
          '  Tip: built files are meant to be served over an HTTP server.\n' +
          '  Opening index.html over file:// won\'t work.\n'
        ))
      })
    })
</pre>

<h4 id="webpack-base-conf-js"><a href="#webpack-base-conf-js" class="headerlink" title="webpack.base.conf.js"></a>webpack.base.conf.js</h4><pre>

    'use strict'
    const path = require('path')  // node 路径模块
    const utils = require('./utils') //node 内部常用的工具类，其中包括：格式化字符串、对象的序列化、实现对象继承等常用方法
    const config = require('../config') //👆上面我们介绍的，项目配置文件
    const vueLoaderConfig = require('./vue-loader.conf') //👆 上面我们介绍的 vue 加载器配置文件

    //返回当前配置文件位置是 build ，该方法放回 build/../dir 的相对路基
    function resolve (dir) {
      return path.join(__dirname, '..', dir)
    }

    // eslint 语法检测配置
    const createLintingRule = () => ({
      test: /\.(js|vue)$/,
      loader: 'eslint-loader',
      enforce: 'pre',
      include: [resolve('src'), resolve('test')],
      options: {
        formatter: require('eslint-friendly-formatter'),
        emitWarning: !config.dev.showEslintErrorsInOverlay
      }
    })

    // webpack 通用配置内容
    module.exports = {
      context: path.resolve(__dirname, '../'),  // 上下文，基础目录，用于从配置中解析入口起点和 loader
      entry: {
        app: './src/main.js'  //起点或是应用程序的起点入口。从这个起点开始，应用程序启动执行。如果传递一个数组，那么数组的每一项都会执行。
      },
      output: {
        path: config.build.assetsRoot,   //输出 bundle 的路径
        filename: '[name].js',          //输出 bundle 的名称
        publicPath: process.env.NODE_ENV === 'production' // 指定资源文件引用的目录，例如图片
          ? config.build.assetsPublicPath
          : config.dev.assetsPublicPath
      },
      resolve: {
        extensions: ['.js', '.vue', '.json'], //配置模块如何解析,
        alias: {                              // 创建应用的别名，
          'vue$': 'vue/dist/vue.esm.js',
          '@': resolve('src'),
        }
      },
  module: {
    rules: [
      //判断配置中是否要是用 eslint 语法检测，如果使用，就将 createLintingRule 配置对象返回
      ...(config.dev.useEslint ? [createLintingRule()] : []),

     //👇是一些比较常用的加载器，及配置，不做详细介绍了
      {
        test: /\.vue$/,
        loader: 'vue-loader',
        options: vueLoaderConfig
      },
      {
        test: /\.js$/,
        loader: 'babel-loader',
        include: [resolve('src'), resolve('test'), resolve('node_modules/webpack-dev-server/client')]
      },
      {
        test: /\.(css | scss)$/,
        loader: 'style-loader!css-loader!!sass-loader'
      },
      {
        test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,
        loader: 'url-loader',
        options: {
          limit: 10000,
          name: utils.assetsPath('img/[name].[hash:7].[ext]')
        }
      },
      {
        test: /\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/,
        loader: 'url-loader',
        options: {
          limit: 10000,
          name: utils.assetsPath('media/[name].[hash:7].[ext]')
        }
      },
      {
        test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/,
        loader: 'url-loader',
        options: {
          limit: 10000,
          name: utils.assetsPath('fonts/[name].[hash:7].[ext]')
        }
      }
    ]
  },
  node: {

    //防止因为 vue 资源本身就自带的 无用的 node 注入，浏览器兼容处理
    setImmediate: false,
    dgram: 'empty',
    fs: 'empty',
    net: 'empty',
    tls: 'empty',
    child_process: 'empty'
  }
}

</pre>


<h4 id="webpack-dev-conf-js"><a href="#webpack-dev-conf-js" class="headerlink" title="webpack.dev.conf.js"></a>webpack.dev.conf.js</h4><pre>

    'use strict'
    const utils = require('./utils')  //node 工具模块
    const webpack = require('webpack') //webpack 不解释
    const config = require('../config')//👆提到的配置文件
    const merge = require('webpack-merge') // merge 工具，用来合并生产和开发环境通用的基础 webpack 配置
    const path = require('path')            //node 的路径模块
    const baseWebpackConfig = require('./webpack.base.conf') //生产和开发环境通用的基础 webpack 配置
    const CopyWebpackPlugin = require('copy-webpack-plugin') //拷贝插件
    const HtmlWebpackPlugin = require('html-webpack-plugin')  //动态生成 html 插件
    const FriendlyErrorsPlugin = require('friendly-errors-webpack-plugin') //友好的错误输出插件
    const portfinder = require('portfinder') //能够获取一个可用的随机端口号

    const HOST = process.env.HOST   //node 全局环境变量的主机
    const PORT = process.env.PORT && Number(process.env.PORT)   //node 全局环境变量的端口

    //合并基础配置加载器的配置部分
    const devWebpackConfig = merge(baseWebpackConfig, {

      module: {
        // 为 .vue 文件意外的独立样式文件配置加载器
        rules: utils.styleLoaders({ sourceMap: config.dev.cssSourceMap, usePostCSS: true })
      },

      // cheap-module-eval-source-map 在开发环境中很快
      devtool: config.dev.devtool,

      // 开发服务配置，👆 已经细讲过，顺便回顾一下
      devServer: {
         clientLogLevel: 'warning',  // 在开发攻击的控制台中显示信息，便于开发调试，你可以将参数配置成 "none" 来进行关闭
         historyApiFallback: { // 当使用 HTML5 History API 时，任意的 404 响应都可能需要被替代为 index.html
            rewrites: [
               { from: /.*/, to: path.posix.join(config.dev.assetsPublicPath, 'index.html') },
            ],
         },
         hot: true,   //启用项目的热刷新，即模块热替换特性
         contentBase: false,   // 告诉服务器从哪里提供内容。只有在你想要提供静态文件时才需要。这里禁用，因为配置了 CopyWebpackPlugin 的使用
         compress: true,
         host: HOST || config.dev.host,   //指定使用一个域名。默认是 localhost
         port: PORT || config.dev.port,   //指定要监听请求的端口号：
         open: config.dev.autoOpenBrowser, //open 参数配置，如果配置成 true ，项目启动后会自动打开浏览器
         overlay: config.dev.errorOverlay   //当有错误或则警告的时候在页面上显示一个全屏的遮罩提示
               ? { warnings: false, errors: true }
               : false,
         publicPath: config.dev.assetsPublicPath, //此路径下的打包文件可在浏览器中访问
         proxy: config.dev.proxyTable,           //代理API的请求
         quiet: true,       //启用 quiet 后，除了初始启动信息之外的任何内容都不会被打印到控制台,特别是使用了 FriendlyErrorsPlugin 插件的时候
         watchOptions: {   //与监视文件相关的控制选项。是否使用轮询
               poll: config.dev.poll,
         }
       },

      plugins: [
        // DefinePlugin 允许创建一个在编译时可以配置的全局常量。这可能会对开发模式和发布模式的构建允许不同的行为非常有用
        new webpack.DefinePlugin({
          'process.env': require('../config/dev.env')
        }),
        new webpack.HotModuleReplacementPlugin(), //启用热替换模块(Hot Module Replacement)，也被称为 HMR
        new webpack.NamedModulesPlugin(), // 当开启 HMR 的时候使用该插件会显示模块的相对路径，建议用于开发环境
        new webpack.NoEmitOnErrorsPlugin(), 在编译出现错误时，使用 NoEmitOnErrorsPlugin 来跳过输出阶段

        //HtmlWebpackPlugin简化了HTML文件的创建，以便为你的webpack包提供服务。这对于在文件名中包含每次会随着编译而发生变化哈希的 webpack bundle 尤其有用
        new HtmlWebpackPlugin({
          filename: 'index.html',
          template: 'index.html',
          inject: true
        }),


        // 拷贝自定义的静态资源文件
        new CopyWebpackPlugin([
          {
            from: path.resolve(__dirname, '../static'),
            to: config.dev.assetsSubDirectory,
            ignore: ['.*']
          }
        ])
      ]
    })

    // 实例一个异步对象，执行 devWebpackConfig 配置编译
    module.exports = new Promise((resolve, reject) => {
      portfinder.basePort = process.env.PORT || config.dev.port  //设置基础端口
      portfinder.getPort((err, port) => {获取端口，输出构建新
        if (err) {
          reject(err)
        } else {
          // 如果进行 e2e 测试，需要发布新端口
          process.env.PORT = port

          // 更新 devServer 的端口
          devWebpackConfig.devServer.port = port

          devWebpackConfig.plugins.push(new FriendlyErrorsPlugin({
            compilationSuccessInfo: {
              messages: [`Your application is running here: http://${devWebpackConfig.devServer.host}:${port}`],
            },
            onErrors: config.dev.notifyOnErrors
            ? utils.createNotifierCallback()
            : undefined
          }))

           //执行打包配置文件
          resolve(devWebpackConfig)
        }
      })
    })

</pre>

<h4 id="webpack-prod-conf-js"><a href="#webpack-prod-conf-js" class="headerlink" title="webpack.prod.conf.js"></a>webpack.prod.conf.js</h4><pre>

    'use strict'
    const path = require('path') // node 路径模块
    const utils = require('./utils') //小工具函数
    const webpack = require('webpack') // webpack 不解释
    const config = require('../config')//👆提到的配置文件
    const merge = require('webpack-merge') // merge 工具，用来合并生产和开发环境通用的基础 webpack 配置
    const baseWebpackConfig = require('./webpack.base.conf')//产和开发环境通用的基础 webpack 配置
    const CopyWebpackPlugin = require('copy-webpack-plugin') //拷贝插件
    const HtmlWebpackPlugin = require('html-webpack-plugin')  //动态生成 html 插件
    const ExtractTextPlugin = require('extract-text-webpack-plugin')//用来做文件分离的插件
    const OptimizeCSSPlugin = require('optimize-css-assets-webpack-plugin')//优化提炼出来的css
    const UglifyJsPlugin = require('uglifyjs-webpack-plugin')// 压缩 js 文件插件

    //生产环境配置
    const env = require('../config/prod.env')

    //合并基础配置加载器的配置部分
    const webpackConfig = merge(baseWebpackConfig, {
    //为独立分离出来的样式配置加载器和source，map
      module: {
        rules: utils.styleLoaders({
          sourceMap: config.build.productionSourceMap,
          extract: true,
          usePostCSS: true
        })
      },
      //配置线上的 source map 便于排查问题
      devtool: config.build.productionSourceMap ? config.build.devtool : false,
      //配置输出，路径，文件名
      output: {
        path: config.build.assetsRoot,
        filename: utils.assetsPath('js/[name].[chunkhash].js'),
        chunkFilename: utils.assetsPath('js/[id].[chunkhash].js')
      },
      plugins: [
        // DefinePlugin 允许创建一个在编译时可以配置的全局常量。这可能会对开发模式和发布模式的构建允许不同的行为非常有用
        new webpack.DefinePlugin({
          'process.env': env
        }),

        // 使用 UglifyJsPlugin 插件对 js 进行压缩
        new UglifyJsPlugin({
          uglifyOptions: {
            compress: {
              warnings: false
            }
          },
          //配置插件的source map
          sourceMap: config.build.productionSourceMap,
          parallel: true
        }),
        // 提取 css 到单独的文件，分离文件异步加载，提高加载速度
        new ExtractTextPlugin({
          filename: utils.assetsPath('css/[name].[contenthash].css'),

          //如果把 allChunks 参数设置陈 false ，就不会把css 从代码块中分离出来
          //代码块加载的时候 css 会被 styles-loader 动态的加载
          allChunks: true,
        }),

        //使用这个插件，从不同的组件中复制脱离出来，进行 css 压缩
        new OptimizeCSSPlugin({
          cssProcessorOptions: config.build.productionSourceMap
            ? { safe: true, map: { inline: false } }
            : { safe: true }
        }),

        //自动生成 html 文件，通常 index.html 文件都会带一个哈希值来清除缓存
        new HtmlWebpackPlugin({
          filename: config.build.index,
          template: 'index.html',
          inject: true,
          minify: {
            removeComments: true,
            collapseWhitespace: true,
            removeAttributeQuotes: true
          },

          chunksSortMode: 'dependency'
        }),
        //该插件会根据模块的相对路径生成一个四位数的hash作为模块id, 渲染模块没有变化的时候，id 不会变。
        new webpack.HashedModuleIdsPlugin(),

        // 提升或者预编译所有模块到一个闭包中，提升你的代码在浏览器中的执行速度。
        new webpack.optimize.ModuleConcatenationPlugin(),

        // 分离渲染的js 到独立的文件中
        new webpack.optimize.CommonsChunkPlugin({
          name: 'vendor',
          minChunks (module) {
            //被引用到的包会从 node_modules 中提取出来
            return (
              module.resource &&
              /\.js$/.test(module.resource) &&
              module.resource.indexOf(
                path.join(__dirname, '../node_modules')
              ) === 0
            )
          }
        }),

        new webpack.optimize.CommonsChunkPlugin({
          name: 'manifest',
          minChunks: Infinity
        }),

        new webpack.optimize.CommonsChunkPlugin({
          name: 'app',
          async: 'vendor-async',
          children: true,
          minChunks: 3
        }),

        // 拷贝自定义的静态资源文件
        new CopyWebpackPlugin([
          {
            from: path.resolve(__dirname, '../static'),
            to: config.build.assetsSubDirectory,
            ignore: ['.*']
          }
        ])
      ]
    })

    //判断如果配置了生产环境压缩，是则使用插件进行压缩
    if (config.build.productionGzip) {
      const CompressionWebpackPlugin = require('compression-webpack-plugin')

      webpackConfig.plugins.push(
        new CompressionWebpackPlugin({
          asset: '[path].gz[query]',
          algorithm: 'gzip',
          test: new RegExp(
            '\\.(' +
            config.build.productionGzipExtensions.join('|') +
            ')$'
          ),
          threshold: 10240,
          minRatio: 0.8
        })
      )
    }

    //是否要生成代码打包分析报告
    if (config.build.bundleAnalyzerReport) {
      const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin
      webpackConfig.plugins.push(new BundleAnalyzerPlugin())
    }

    module.exports = webpackConfig


</pre>


<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>👆这篇文章详细的介绍了脚手架项目的 webpack 配置，但是只是 webpack 的一部分，还有很多内容值得我们去探究，如果你还感兴趣，可以阅读下面这些文章。也欢迎随时与我进行交流，微信号：646321933</p>
<p><a href="https://doc.webpack-china.org/guides/production/" target="_blank" rel="external">webpack指南 </a><br><a href="https://doc.webpack-china.org/concepts/" target="_blank" rel="external">webpack文档</a><br><a href="https://doc.webpack-china.org/configuration
[开发 ](https://doc.webpack-china.org/guides/development/#%E4%BD%BF%E7%94%A8-source-map" target="_blank" rel="external">webpack配置 </a><br><a href="https://juejin.im/post/5a31d210f265da431a43330e" target="_blank" rel="external">自己动手实现一个脚手架</a><br><a href="https://doc.webpack-china.org/plugins" target="_blank" rel="external">webpack 官方插件集合介绍文档 </a><br><a href="https://segmentfault.com/a/1190000007441374" target="_blank" rel="external">《 使用vue-cli脚手架创建新项目》</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/bbt.jpeg"
               alt="bailinlin" />
          <p class="site-author-name" itemprop="name">bailinlin</p>
          <p class="site-description motion-element" itemprop="description">前端,白霸天,博客</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">22</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bailinlin</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"baibatian"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  








  
  

  

  

  

  


</body>
</html>
