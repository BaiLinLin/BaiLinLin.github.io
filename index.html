<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="前端,白霸天,博客">
<meta property="og:type" content="website">
<meta property="og:title" content="白霸天的博客">
<meta property="og:url" content="https://bailinlin.github.com/index.html">
<meta property="og:site_name" content="白霸天的博客">
<meta property="og:description" content="前端,白霸天,博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="白霸天的博客">
<meta name="twitter:description" content="前端,白霸天,博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://bailinlin.github.com/"/>





  <title> 白霸天的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">白霸天的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2018/03/05/cookie-set/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/05/cookie-set/" itemprop="url">
                  跨域问题导致设置 cookie 不生效的问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-05T16:18:09+08:00">
                2018-03-05
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2018/03/05/cookie-set/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/03/05/cookie-set/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们看下跨域不生效的问题，首先抛出两个问题：</p>
<blockquote>
<ol>
<li>我们如何设置 cookie ？</li>
<li>又如何确定 cookie 设置是否生效了 ？</li>
</ol>
</blockquote>
<p>首先，我们实现一个简单的接口,新建一个 test.js 文件，将如下代码复制进去，通过 <code>node test.js</code> 启动服务，在本地就可以通过 <code>http://localhost:3000/rest/collect/event/h5/v1/</code> 来访问了我们创建的接口了（node 环境安装的教程网上有很多详细的教程，本文不再赘述）</p>
<pre>
var express = require('express');
var app = express();
var URL = require('url')
var path = require('path');


app.post('/rest/collect/event/h5/v1/', function(req, res) {
        res.cookie('token','11111112222222224444444444')        res.cookie('httpOnly-token','11111112222222224444444444',{ httpOnly: true })

        function User() {
                this.name;
                this.city;
                this.age;
        }

        var user = new User();

        if(params.id == '1') {

                user.name = "ligh";
                user.age = "1";
                user.city = "北京市";

        }else{
                user.name = "SPTING";
                user.age = "1";
                user.city = "杭州市";
        }

        var response = {status:1,data:user};
        res.send(JSON.stringify(response));
});

app.listen(3000);
console.log('Listening on port 3000...');
</pre>

<p>访问效果如下</p>
<p><img src="/images/cookie/3.jpeg" alt="接口访问效果如下"></p>
<p>在前端代码中访问我们的接口<br><img src="/images/cookie/4.jpeg" alt="cookie设置"><br><img src="/images/cookie/5.jpeg" alt="cookie查看"><br>在浏览器中我们可以看到请求的 Resopnse Headers 里，有两个 <code>set-cookie</code>头部，区别在于一个带有 <code>HttpOnly</code>的标识，我们打开浏览器的调试窗口<code>Application</code>我们可以看到，两个数值都被设置到浏览器里了，<code>httpOnly</code>的值在浏览器调试窗口的<code>http</code>一栏，打了个小勾，说明这个变量是只能通过 http 请求来获取到这个cookie ，前端无法通过 js 的 <code>document.cookie</code>来获取到<br><img src="/images/cookie/7.jpeg" alt="就是无法操作的cookie"><br>讲到这块内容，我们顺便讲下 cookie 设置的其他参数的作用</p>
<p><img src="/images/cookie/6.jpeg" alt="其他参数"><br>cookie 和域名相关的哟，<code>Domain</code> 变量表示 cookie 生效的域名，<code>expries</code>和<code>max-age</code>表示 cookie 的有效时间</p>
<h4 id="问题描述及解决"><a href="#问题描述及解决" class="headerlink" title="问题描述及解决"></a>问题描述及解决</h4><p>在开发阶段我自己用node 简单的写了一个接口，便于联调前端传参问题，希望通过 http 的set-cookie 存储变量， 但是却始终没有把 cookie 成功设置到浏览器里，经过排查发现是跨域导致的 cookie 设置不生效<br><img src="/images/cookie/1.jpeg" alt="cookie设置"><br><img src="/images/cookie/2.jpeg" alt="cookie查看"></p>
<p>不生效的原因是我本地项目启动在 <code>http://localhost:70</code>,但是调用的接口在 <code>http://localhost:3000</code>上，端口不一样，存在跨域的问题，所以虽然在 Response Header 里看到了<code>set-cookie</code>的操作，但是在浏览器的 <code>application</code>里看到，并没有被设置进来，解决办法，通过nginx 代理（最长用的跨域解决办法）</p>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>跨域的问题在开发过程中比较常见，我们经常会碰到，简单来说<code>只要请求资源的协议，域名，端口不一致，都会导致跨域</code>，网上的解决方法也比较多，比较成熟，本文不做扩展，附带几个链接供大家参考</p>
<p><a href="http://harttle.land/2016/12/30/cors-preflight.html" target="_blank" rel="external">跨域中的预检测请求</a><br><a href="https://www.jianshu.com/p/13d53acc124f" target="_blank" rel="external">CORS 跨域中的 Cookie</a><br><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="external">跨域资源共享 CORS 详解</a><br><a href="http://harttle.land/2015/10/10/cross-origin.html" target="_blank" rel="external">Web开发中跨域的几种解决方案</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2017/05/18/nginx-basic/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/18/nginx-basic/" itemprop="url">
                  你需要了解的 nginx 基础配置
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-18T14:23:31+08:00">
                2017-05-18
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2017/05/18/nginx-basic/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/05/18/nginx-basic/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="初探nginx"><a href="#初探nginx" class="headerlink" title="初探nginx"></a>初探nginx</h2><blockquote>
<p>今天给大家讲下nginx的基础配置,很多小伙伴在开发的过程中会使用到 nginx ,但是确对 nginx 的配置其实并不了解,今天我给大家讲下基础的配置项.nginx 的功能很多,但是说到 nginx 大家最先想到的是反向代理和负载均衡.</p>
</blockquote>
<p>“负载均衡”在开发环境体现的不太明显,主要是为了解决生产环境的客户端请求很多的时候,动态的去分散给各个服务器,缓解服务器压力,充 分利用资源.而说到 “反向代理”,你的第一反应应该是”正向代理”,简称”代理”,你可以把代理想象成客户端和服务端的中介,代理的种类很多,比较常见的是,客户端对服务端进行请求的时候,代理会对请求的内容进行下载缓存,从而提高客户端的请求速度,代理还有多重代理,加密处理等功能,”反向代理”的作用和正项代理的功能相辅相成,原理也类似,反向代理将字符串和相应的服务器和端口匹配上,从而获取用户想要获取的内容,那么这两者的区分是什么呢,”正向代理”作用于客户端,”反向代理”作用于服务器.</p>
<h2 id="生动的-nginx-反向代理解释"><a href="#生动的-nginx-反向代理解释" class="headerlink" title="生动的 nginx 反向代理解释"></a>生动的 nginx 反向代理解释</h2><p>为了让大家能够更加深刻的理解代理和反向代理的模式,我们引用下知乎上<a href="https://www.zhihu.com/question/24723688/answer/160252724" target="_blank" rel="external">车小胖</a>的回答</p>
<blockquote>
<p>有了第三方订餐外卖平台（代理），老王懒得动身前往饭店，老王打个电话或用APP，先选好某个饭店，再点好菜，外卖小哥会送上门来。由于某个品牌的饭店口碑特别好，食客络绎不绝涌入，第三方订餐电话也不绝于耳，但是限于饭店接待能力有限，无法提供及时服务，很多食客等得不耐烦了，纷纷铩羽而归，饭店老总看着煮熟的鸭子飞走了，心疼不已。痛定思痛，老总又成立了几个连锁饭店，形成一个集群，对外提供统一标准的菜品服务，电话订餐电话400-xxx-7777，当食客涌入饭店总台，总台将食客用大巴运到各个连锁店，这样食客既不需要排队，各连锁店都能高速运转起来，一举两得，老总乐开了花，并为此种运作模式起名为“反向代理”（Reverse Proxy)。</p>
</blockquote>
<h2 id="nginx-基础配置"><a href="#nginx-基础配置" class="headerlink" title="nginx 基础配置"></a>nginx 基础配置</h2><p>好了,了解了 nginx 的一些概念之后,我们要开始切入今天的主题,”ngix 的基础配置”,安装好 nginx 配置之后,你对 nginx 的配置都写在 nginx.conf 的文件里,从 nginx 的配置指令作用域来讲,我们分为 5 个作用域块,分别是:</p>
<ul>
<li>全局作用域块</li>
<li>event 作用域块</li>
<li>http 指令作用域块</li>
<li>server 指令作用域块</li>
<li>location 指令作用域块</li>
</ul>
<p><img src="/images/nginx/nd.jpeg" alt="nginx基础配置"></p>
<p>在 “全局作用域块” 作用域块中配置通用的nginx 配置,比如 nginx 的用户组信息,nginx 的并发进程数,日志存放位置等,nginx 的用户组信息配置,用来控制启动 nginx 的权限,服务并发一般情况下是越多越好,但是当超过硬件的承受范围时会适得其反,所以一般我们会配置为 auto,这样 nginx 会去检查硬件的信息,启用适当的进程数量.</p>
<p>日志存放位置你也可以配置在 http 作用域块,”http 作用域块”作用域通常是配置请求相关的内容,比如数据的传输,对同一个接口的请求次数上线,配置请求的潮湿时间,还有是否要对请求进行 gzip 压缩等.在之前讲 web性能优化的时候,我记得和大家讲过 gzip 压缩是提高 web 性能优化的一种手段,gzip 能对 http 请求的请求头和请求体进行压缩,从而达到优化.但是不是所有的请求都要去压缩,有些压缩之后的请求体积可能会更大,从而达不到压缩的效果.那怎么办呢,在 nginx 的配置中,你可以进行配置,设置当请求大于一定值的时候,才触发 gzip 压缩 gzip 的内容这里就深入讲解了,想要了解的同学可以去谷歌下,或则在下次 nginx 的高级配置的分享的时候我们再来细讲.</p>
<p>在 event 模块我们通常会配置进程的连接数量,就是每一个worker进程能并发处理（发起）的最大连接数.在 “server 指令作用域块” 我们可以进行独立项目的代理配置,</p>
<p>一个 http 指令中可以包含多个 server ,每一个 server 你可以看做是一个虚拟机,部署过网站的同学应该知道,若果你没有做代理,你的服务器只能部署一个项目的内容,默认是80端口,使用代理,能将客户端的请求根据端口作为区分,发散到不同的项目中.nginx 这一点,能让我们更好的利用服务器资源</p>
<p>在server 指令中,我们同样可以配置多个 location 指令,location 指令能将我们的字符串请求解析到对应的IP和端口,从而去获取正确的资源,location 也可以进行特殊配置,定制 网站的 404 ,500 等页面.</p>
<h2 id="nginx-的项目配置示例"><a href="#nginx-的项目配置示例" class="headerlink" title="nginx 的项目配置示例"></a>nginx 的项目配置示例</h2><p><img src="/images/nginx/l1.jpeg" alt="nginx作用域"><br><img src="/images/nginx/l2.jpeg" alt="nginx作用域"><br>我们简单的看下,我目前使用到的两个项目的 nginx 配置,在fengdai_pc 项目中我们通过 listen 来配置项目监听端口,通过 root 来配置前端项目文件的地址,我们还通过 location 来配置了几个模块代理,account 和 funds ,定制了 404 页面,在 另一个 nginx 配置项目中我们做了https 配置,配置了域名 <code>baibatianpc.com</code>,并且指定了证书的位置,这样配置后,我们能通过 访问 <a href="https://baibatianpc.com/" target="_blank" rel="external">https://baibatianpc.com/</a> 来查看我们的项目.这里对于如何搭建 https 环境就不细讲了,不同的开发系统证书的获取和配置方式也不太一样,想要深入了解的同学继续谷歌.</p>
<h2 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h2><p>好了,我们今天讲了nginx 的基础配置,我们现在来复习一下,我们今天讲的知识点有哪些</p>
<ol>
<li>nginx 常用的功能的概念,负载均衡,反向代理</li>
<li>nginx 指令配置的5个作用域空间</li>
<li>nginx 的每个配置作用域的基础配置项目</li>
<li>简单的两个项目配置示例</li>
</ol>
<p>你都掌握了吗,联系我进行交流,WeChat:646321933</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2017/01/09/webpack/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/09/webpack/" itemprop="url">
                  你需要知道的 webpack 配置
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-09T21:27:52+08:00">
                2017-01-09
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2017/01/09/webpack/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/01/09/webpack/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>好久没有写文章，最近在做项目自动化构建工具的迁移，花了一点时间去研究 <code>webpack</code> ，<code>webpack</code> 的入门其实简单，但是现有的资料比较零碎，按照我的学习路径整理了下，希望对大家能有所帮助。</p>
<blockquote>
<p>接下来我将从3个部分来给大家介绍<code>webpack</code>,分别是 webpack 的基础配置，哪些常用的加载器，我在项目自动化构建工具改造的过程中雨大了那些问题</p>
</blockquote>
<h3 id="webpack-基础配置"><a href="#webpack-基础配置" class="headerlink" title="webpack 基础配置"></a>webpack 基础配置</h3><p>首先我们需要理解四个重要的概念</p>
<ol>
<li>入口（你需要打包的文件声明），你的项目需要什么依赖没在这里进行声明，require 你需要的依赖，webpack 会直接和间接的找到依赖文件进行打包，可传字符串，数组，对象<pre>
     // 配置了3个入口文件
     entry: [
             './config/dependencies.js',
             './config/index.js',
             './config/cssImport.js'
     ]
</pre></li>
<li>出口（你打包资源后到哪个目录哪个文件），声明依赖打包后的文件输出的目录及命名方式，可传字符串，数组，对象<pre>
     //声明了依赖压缩打包之后会被添加到 build 目录的 bundle.js 文件里
     output: {
             path: path.join(__dirname, '../build'),
             filename: 'bundle.js',
     },
</pre></li>
<li>loader（模块加载器）能将各种资源的依赖模块打包成webpack 能够理解的 js 模块，从而进行你需要的操作，如 css 预编译，图片压缩，路径转换等<pre>
     loaders: [
                 {
                     test: /\.js?$/,
                     exclude: /(node_modules|bower_components)/,
                     loader: 'babel-loader', // 'babel-loader' is also a legal name to reference
                     query: {
                             presets: ['es2015']
                     }
             }]
</pre></li>
<li><p>插件（插件用于扩展 loader 的能力）你可以用插件进行定义环境变量对代码进行打包压缩。</p>
<pre>
     //声明
     const ImageminPlugin = require("imagemin-webpack-plugin").default
     const CopyWebpackPlugin = require('copy-webpack-plugin')

     //从imgSrc 目录压缩图片，压缩完拷贝到 build/img 目录下
     plugins: [
             new CopyWebpackPlugin([
                     { from: 'imgSrc' ,to:'img'}
             ]),
             new ImageminPlugin(
                     { test: /\.(jpe?g|png|gif|svg)$/i }
                     )
     ]
</pre>

</li>
</ol>
<p><a href="https://doc.webpack-china.org/concepts/" target="_blank" rel="external">概念方面如果有不清晰的可以看下 webpack 的中文文档</a></p>
<h3 id="webpack-的常用加载器"><a href="#webpack-的常用加载器" class="headerlink" title="webpack 的常用加载器"></a>webpack 的常用加载器</h3><p>loader 用于常用的源代码进行装换，常用的有js编译，css 预编译，图片压缩等，这些都是项目中比较常见的，大家平时不需要记忆，只要能大概知道有这么一个东西，需要用到的时候去查阅就行，<a href="https://doc.webpack-china.org/loaders/" target="_blank" rel="external">loader 官方收录文档</a></p>
<h3 id="在项目迁移中遇到的问题"><a href="#在项目迁移中遇到的问题" class="headerlink" title="在项目迁移中遇到的问题"></a>在项目迁移中遇到的问题</h3><p>由于各种历史原因，我们的项目目录结构凌乱，项目依赖多，结构复杂，使用着 <code>angular + gulp</code> 进行开发，自动化构建工具还处于刀耕火种的年代，发版本的时候通过前端给包，不安全，不规范。新的一年我们尝试去改变这种现状，洗完通过运维直接拉去前端代码，这样能充分的保证前端代码的一致性。</p>
<h4 id="目前的项目结构的控诉"><a href="#目前的项目结构的控诉" class="headerlink" title="目前的项目结构的控诉"></a>目前的项目结构的控诉</h4><ol>
<li>项目所有问文件处于一个平级状态</li>
<li>有3个依赖包文件夹分别是 framwork，lib，node_modules(各种历史遗留问题)</li>
<li>源图片imgSrc和压缩后的img在同一个目录</li>
<li>人工手动打包的时候要很小心的删除不必要的文件</li>
</ol>
<h4 id="现有的改进方案"><a href="#现有的改进方案" class="headerlink" title="现有的改进方案"></a>现有的改进方案</h4><ol>
<li>创建 build 文件夹，nginx 代理 到 build 目录</li>
<li>config 中配置 webpack 构建打包任务，以及各种依赖的入口文件</li>
<li>ib &amp;&amp; framwork 移到 build 文件</li>
<li>less 中对图片的引用路径需要变动，因为img 的路径变动了，tpls 也变动了，所以在视图中直接引用的不需要变化</li>
<li>gulpfile 中的 js 压缩，less 编译，图片压缩内容迁移到 webpack 任务中</li>
<li>通过 npm run dev 进行编译构建</li>
<li>图片压缩</li>
<li>依赖及模块文件变化时实时构建项目</li>
<li>弃用 gulpfile 编译构建</li>
</ol>
<p>创建 <code>build</code> 文件夹，<code>nginx</code> 代理 到 <code>build</code></p>
<blockquote>
<p>目录，配置生产环境依赖目录，运维可以直接将代理指向该目录，不需要人工手动剔除多余的目录</p>
</blockquote>
<p>config 中配置 webpack 构建打包任务，以及各种依赖的入口文件</p>
<blockquote>
<p>建立config 目录，存放 webpack 配置文件目录，及各种依赖声明目录，我们一共声明了3个依赖入口文件，分别是npm 管理的生产依赖文件，css 文件，项目逻辑js文件。css 和 生产依赖的内容比较烧，我们手动 require 一下，但是我们项目是已经经过近两年的迭代开发，逻辑代码 js 文件繁多，目录结构负责，所以我们需要写一个简单的 node 脚本，递归查询项目目录结构，动态 require 写入到我们的js入口文件中，node 脚本 如下</p>
</blockquote>
<pre>
        var files = fs.readdirSync('js')
        var jsPath = 'js'

        fs.unlink('config/index.js')

        var getFileName = function (files,dirPath) {

        files.forEach(function (filename) {
                var fullname = path.join(dirPath,filename)
                var stats = fs.statSync(fullname)

                if (stats.isDirectory()){
                        var subFiles = fs.readdirSync(fullname)
                        getFileName(subFiles,fullname)
                } else {
                        let file = './../'+dirPath+'/'+filename
                        fs.writeFile('./config/index.js', 'require (\"'+file +'\")\n', {
                                flag: 'a'
                        }, function(err){
                                 if(err) throw err
                        })
                }
        })
}

getFileName(files,jsPath)
</pre>

<p>配置我们的入口和输入</p>
<pre>
        entry: [
                './config/dependencies.js',
                './config/index.js',
                './config/cssImport.js'
        ],
        output: {
                path: path.join(__dirname, '../build'),
                filename: '[name].js',
        },
</pre>

<p>然后是对我们的gulp task 进行迁移，我们需要配置 js 语法编译，css 预处理，图片压缩的功能。js 编译只需要使用 <code>babel-loader</code> ,通过 <code>npm install babel-loader</code> 安装加载器，指定匹配的文件及需要忽略的文件，指定转化语法，设定转码规则，就配置成功了</p>
<pre>
        {
            test: /\.js?$/,
            exclude: /(node_modules|bower_components)/,
            loader: 'babel-loader', // 'babel-loader' is also a legal name to reference
            query: {
                presets: ['es2015']
            }
        }
</pre>

<p>css 预编译，我们使用了 less 做为 css 开发工具，编译的时候需要用到的 loader 比较多，通过<code>less-loader</code>,<code>css-loader</code>,<code>style-loader</code>的链式调用，将样式作用于DOM</p>
<pre>
        rules: [{
            test: /\.less$/,
            use: [{
                loader: "style-loader" // creates style nodes from JS strings
            }, {
                loader: "css-loader" // translates CSS into CommonJS
            }, {
                loader: "less-loader" // compiles Less to CSS
            }]
        }]
</pre>

<p>或则</p>
<pre>
loaders: [
            {
                test: /\.less$/,
                use: ['style-loader',
                    {
                        loader: 'css-loader',
                        options: {
                            //支持@important引入css
                            importLoaders: 1
                        }
                    },
                    {
                        loader: 'postcss-loader',
                        options: {
                            plugins: function() {
                                return [
                                //一定要写在require("autoprefixer")前面，否则require("autoprefixer")无效
                                require('postcss-import')(),
                                require("autoprefixer")({
                                "browsers": ["Android >= 4.1", "iOS >= 7.0", "ie >= 8"]})]
                            }
                        }
                    },
                    'less-loader']
                }]
</pre>

<p>图片压缩我们选择了两个插件分别是<code>imagemin-webpack-plugin</code>和<code>copy-webpack-plugin</code>，imagemin 实现图片压缩，copy 实现图片资源拷贝，具体配置如下</p>
<pre>
//插件引用
const ImageminPlugin = require("imagemin-webpack-plugin").default
const CopyWebpackPlugin = require('copy-webpack-plugin')

//插件使用
plugins: [
                new CopyWebpackPlugin([
                        { from: 'imgSrc' ,to:'img'}
                ]),
                new ImageminPlugin(
                        { test: /\.(jpe?g|png|gif|svg)$/i }
                        )
        ]
</pre>

<p>了解完细节我们看下一个整体的配置</p>
<pre>
/**
 * Created by bailinlin on 2018/1/4.
 */
const fs = require ("fs")
const path = require ("path")

const ImageminPlugin = require("imagemin-webpack-plugin").default
const CopyWebpackPlugin = require('copy-webpack-plugin')


var files = fs.readdirSync('js')
var jsPath = 'js'

fs.unlink('config/index.js')

var getFileName = function (files,dirPath) {

        files.forEach(function (filename) {
                var fullname = path.join(dirPath,filename)
                var stats = fs.statSync(fullname)

                if (stats.isDirectory()){
                        var subFiles = fs.readdirSync(fullname)
                        getFileName(subFiles,fullname)
                } else {
                        let file = './../'+dirPath+'/'+filename
                        fs.writeFile('./config/index.js', 'require (\"'+file +'\")\n', {
                                flag: 'a'
                        }, function(err){
                                 if(err) throw err
                        })
                }
        })
}

getFileName(files,jsPath)

module.exports = {
        entry: [
                './config/dependencies.js',
                './config/index.js',
                './config/cssImport.js'
        ],
        output: {
                path: path.join(__dirname, '../build'),
                filename: 'bundle.js',
        },
        module: {
                loaders: [
                    {
                        test: /\.js?$/,
                    exclude: /(node_modules|bower_components)/,
            loader: 'babel-loader', // 'babel-loader' is also a legal name to reference
            query: {
                presets: ['es2015']
            }
                },{
                test: /\.less$/,
                use: ['style-loader',
                {
                loader: 'css-loader',
                options: {
                 //支持@important引入css
                    importLoaders: 1
                }
                },{
                loader: 'postcss-loader',
                options: {
                plugins: function() {
                    return [
                    //一定要写在require("autoprefixer")前面，否则require("autoprefixer")无效
                    require('postcss-import')(),
                    require("autoprefixer")({
                    "browsers": ["Android >= 4.1", "iOS >= 7.0", "ie >= 8"]})]
                     }
                     }
                    },
                    'less-loader']
                },{
                    test: /\.(jpe?g|png|gif|svg)$/i,
                    use: [
                    {
                        loader: 'url-loader',
                        options: {
                            limit: 8192
                        }
                    }]
                }]
        },
        plugins: [
                new CopyWebpackPlugin([
                        { from: 'imgSrc' ,to:'img'}
                ]),
                new ImageminPlugin(
                        { test: /\.(jpe?g|png|gif|svg)$/i }
                        )
        ]
}

</pre>

<h4 id="实现热编译"><a href="#实现热编译" class="headerlink" title="实现热编译"></a>实现热编译</h4><p>实现完配置之后我们要考虑另一个问题了，我们希望修改完之后能实时编译预览，不用每次都手动的跑一边命令，我们可以选择 webpack 提供的 node 服务，<code>webpack-dev-server</code>,在配置文件里新增一个 webpack.server.js 的文件，在文件中 require 需要的依赖，<code>webpack-dev-server</code> 可以指定服务启动的目录，及服务监听的端口，我们的配置如下</p>
<pre>
/**
 * Created by bailinlin on 2018/1/4.
 */
var path = require("path")
var webpack = require("webpack")
var webpackDevServer = require("webpack-dev-server")
var webpackCfg = require("./webpack.config.js")

var compiler = webpack(webpackCfg)

//init server
var app = new webpackDevServer(compiler, {
        contentBase        : path.join(__dirname, '../build'),
        noInfo             : true,
        hot                : true,
        historyApiFallback : true,
        stats              : { colors : true },
        //注意此处publicPath必填
        publicPath: webpackCfg.output.publicPath
})

app.listen(9090, "localhost", function (err) {
        if (err) {
                console.log(err)
        }
})

console.log("listen at http://localhost:9090")
</pre>

<h4 id="启动我们的服务"><a href="#启动我们的服务" class="headerlink" title="启动我们的服务"></a>启动我们的服务</h4><p>配置完成之后，我们需要启动我们的服务，你可以再你的控制台中直接输入 <code>node config/webpack.server.js</code> 来启动服务，<code>webpack --config config/webpack.config.js</code> 来进行编译构建，也可以在 package.json 文件中配置 script 如</p>
<p><pre><br>“scripts”: {<br>    “start”:”node config/webpack.server.js”,<br>    “build”: “webpack –config config/webpack.config.js”<br>  },<br></pre><br>这样你就可以通过 <code>npm start</code> 和 <code>npm run build</code>来控制你的服务启动和项目构建</p>
<p>参考文章列表</p>
<blockquote>
<p>如果你还想更深入理解，你可以继续阅读这些扩展文章<br><a href="https://doc.webpack-china.org/concepts/" target="_blank" rel="external">理解概念</a><br><a href="https://doc.webpack-china.org/configuration/#-" target="_blank" rel="external">配置讲解</a><br><a href="https://doc.webpack-china.org/loaders/" target="_blank" rel="external">常会用到的loaders</a><br><a href="http://blog.csdn.net/lancewu0907/article/details/76513231" target="_blank" rel="external">webpack打包原理</a><br><a href="https://www.zhihu.com/question/46661735" target="_blank" rel="external">webpack全局变量</a><br><a href="https://github.com/webpack-contrib/css-loader/issues/74" target="_blank" rel="external">less 图片解析问题</a><br><a href="https://juejin.im/entry/5767a975df0eea0062ffe193" target="_blank" rel="external">其他优秀的配置文章</a><br><a href="https://github.com/kingvid-chan/webpack2-lessons/tree/master/lesson2" target="_blank" rel="external">《使用webpack-dev-server实现热更新》</a><br><a href="https://github.com/Klathmon/imagemin-webpack-plugin" target="_blank" rel="external">imagemin-webpack-plugin</a><br><a href="https://github.com/webpack-contrib/copy-webpack-plugin" target="_blank" rel="external">copy-webpack-plugin</a></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2016/11/30/init-blog/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/30/init-blog/" itemprop="url">
                  使用 hexo 搭建你的 github.io 博客网站
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-30T20:13:38+08:00">
                2016-11-30
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/11/30/init-blog/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/30/init-blog/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>作为前端er,我们每天都要保持学习,前阵子有一片文章很火<a href="https://zhuanlan.zhihu.com/p/22782487" target="_blank" rel="external">在 2016 年学 JavaScript 是一种什么样的体验？</a>,前端技术日新月异,我们不仅要保持学习,还需要掌握一个好的,适合自己的学习方式.在这个信息这个发达的时代,你不缺输入的机会,却少的反而是我们的输出机会.大多数的前端没有去记录自己的所学,所用,即使有记录,也都是在一些第三方的博客网站, 这就会有这么一个情况.持续性不够,发布过的文章没有去回顾,这个博客网站发一篇,那个博客网站发一篇,而且很没归属感.</p>
<p>然而,github 作为我们的程序员圈子的同性交友社区,面试必看的内容,我们为什么不在 github 上搭一个自己的博客呢,在 github 上你可以直接建立一个仓库,然后在 issue 里写博客,我个人比较建议的是,搭一个属于你自己的 github pages,在 github pages 上记录你的博客. 首先是外观上比较好看,而且你可以依照你的心情改变你的博客主题,其次,你可以通过你的 github 用户名点 github.io 的方式来直接访问你的博客网站,感觉有了一个属于自己的网站一样,不要钱,还在一定程度上满足了你的虚荣心.</p>
<h2 id="快速搭建"><a href="#快速搭建" class="headerlink" title="快速搭建"></a>快速搭建</h2><p>如果你是有一定开发经验的前端,你的电脑一定已经安装了 git 和 node ,那你在搭建博客之前你只要先全局安装 hexo 的命令行工具,命令如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g hexo-cli</div></pre></td></tr></table></figure>
<p>然后你在你的电脑里新建一个空的文件夹命名就按照 userName.github.io 的方式来命名 例如我的项目我命名为 bailinlin.github.io, 其次,你需要进入你新建的这个文件夹,执行命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo init</div></pre></td></tr></table></figure>
<p>等待一定时间,你会看到你新建的文件夹里出现了好多初始化文件,现在这个时候一个基本的简单博客搭建成功了,你运行以下命令</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo s -p 3000</div></pre></td></tr></table></figure>
<p> 就能在 localhost:3000 中看到一个博客网站了,现在你要做的就是为你的博客网站做一些个性化的定制,打开_config.yml 文件.修改文件内的参数,</p>
<pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">title: 白霸天的博客              //博客网站的title</div><div class="line">subtitle:                      //子标题</div><div class="line">description: 前端,白霸天,博客   //网站描述</div><div class="line">author: bailinlin             //网站作者</div><div class="line">language: zh-Hans            //网站语言,用于本地化</div><div class="line">...                          // 等其它配置</div></pre></td></tr></table></figure>
</code></pre><h2 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h2><h3 id="关联远程仓库"><a href="#关联远程仓库" class="headerlink" title="关联远程仓库"></a>关联远程仓库</h3><p>博客搭建好之后,你需要做的是把博客发布到 github 上,首先你需要在 github 上新建一个仓库,命名和你新建的文件夹一样, username.githhub.io 值得注意的是,这里的 username 必须和你的github 用户名一样,大小写也要一样.然后你需要进入你的本地文件夹,关联你的远程仓库.</p>
<p>首先<br>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git init</div></pre></td></tr></table></figure></p>
<p>然后<br>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git remote add origin git@github.com:username/username.github.io.git</div></pre></td></tr></table></figure></p>
<p>然后我们只要把代码推到远程仓库就行了,不过这里我们要有个约定,我们在 master 上发布博客,在 dev 分支上修改我们的博客内容和项目配置,也就是说我们发布博客后,master 分支上就是我们的博客的静态文件,dev 分支上的代码就是我们世纪维护的博客内容,如图<br>master 分支:<br><img src="/images/blog/master.png" alt="master分支"><br>dev 分支:<br><img src="/images/blog/master.png" alt="master分支"></p>
<h3 id="安装-hexo-的一键部署命令工具"><a href="#安装-hexo-的一键部署命令工具" class="headerlink" title="安装 hexo 的一键部署命令工具"></a>安装 hexo 的一键部署命令工具</h3><p> 通过npm 安装<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></p>
<p> 修改部署配置,在 _config.yml 中添加如下配置</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  <span class="built_in">type</span>: git</div><div class="line">  branch: master</div><div class="line">  repo: git@github.com:bailinlin/bailinlin.github.io.git  //此处记得改成你的 github 仓库的地址</div></pre></td></tr></table></figure>
<h3 id="你的-first-commit"><a href="#你的-first-commit" class="headerlink" title="你的 first commit"></a>你的 first commit</h3><p>按照约定我们先切分支,通过命令把项目切换到 dev 分支<br>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b dev</div></pre></td></tr></table></figure></p>
<p>然后 add 你的项目代码<br>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git add .</div></pre></td></tr></table></figure></p>
<p>你的 first commit<br>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git commit -m <span class="string">":tada: init blog"</span></div></pre></td></tr></table></figure></p>
<p>然后 push 你的代码到远程<br>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$  git push --set-upstream origin dev</div></pre></td></tr></table></figure></p>
<h3 id="你的第一次博客发布"><a href="#你的第一次博客发布" class="headerlink" title="你的第一次博客发布"></a>你的第一次博客发布</h3><p>发布其实很简单的,我们之前也说是一个命令行发布的,所以你只要<br>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure></p>
<p>然后你就可以看到一个属于你的 github.io 的网站了</p>
<h2 id="改变你的博客网站主题"><a href="#改变你的博客网站主题" class="headerlink" title="改变你的博客网站主题"></a>改变你的博客网站主题</h2><p>个人比较推荐的是 next ,大量的留白,让你的博客看起来简洁大方,或则你喜欢其它的主题也行,你需要在你的博客文件夹里clone 下你需要的主题</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</div></pre></td></tr></table></figure>
<p> 然后在 _config.yml 文件夹里修改你的主题配置</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ theme: next</div></pre></td></tr></table></figure>
<p> 然后 hexo s 就能看到你修改的主题生效了,为了防止 clone 下来的主题文件和自己的博客文件冲突,我删除了clone 下来的 .git 文件.你再按照你的 first commit 的操作提交你的修改就行了,然后别忘记了 deploy</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2016/11/01/learn-wxapp/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/01/learn-wxapp/" itemprop="url">
                  learn-wxapp
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-01T20:38:15+08:00">
                2016-11-01
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/11/01/learn-wxapp/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/01/learn-wxapp/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>微信小程序出来已有段时间，虽还在内测阶段。利用空闲时间，我把蜂贷微信项目部分迁移到小程序上。</p>
<p>##1.目录结构</p>
<p>   小程序的主体由三个文件组成，这三个文件要放在项目的根目录下，分别是</p>
<ol>
<li>app.js 配置小程序的逻辑</li>
<li>app.json 公共设置</li>
<li><p>app.wxss 公共样式</p>
<p>小程序可以自定义 page，但是 page 需要在 app.json 中做出声明，不然IDE会报错，找不到页面。小程序的页面由四个文件组成，分别是</p>
</li>
<li><p>.js文件 页面逻辑</p>
</li>
<li>.wxml 视图层文件，页面结构</li>
<li>.wxss 样式文件，页面样式表</li>
<li>.json 文件，配置文件，页面配置</li>
</ol>
<h2 id="2-小程序配置"><a href="#2-小程序配置" class="headerlink" title="2.小程序配置"></a>2.小程序配置</h2><p>app.json 决定页面文件的路径、窗口表现、设置网络超时时间、设置多少 tab 。</p>
<p>在 pages 对象里定义页面路径，pages 接受由字符串组成的数组，pages数组的第一个元素就是小程序的首页。</p>
<ol>
<li>window 用于设置小程序的状态栏、导航条、标题、窗口背景色。</li>
<li>tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。</li>
<li>networkTimeout 用来设置各种网络请求超时时间</li>
<li>debug 是布尔类型，用来配置是否在开发者工具中开启 debug 模式</li>
</ol>
<h2 id="3-小程序视图"><a href="#3-小程序视图" class="headerlink" title="3.小程序视图"></a>3.小程序视图</h2><p>在小程序中，你不能继续用 html 中的标签来构造你的页面，MANA 框架有特定的容器组件，view，scroll-view  以及 swiper。</p>
<ol>
<li>view 是视图容器，类似于 html 中的 div ，但是不同的是，用 view 包裹的内容，在超出设备窗口的时候，它实现的效果如 css 样式设置的 overflow：hidden</li>
<li>如果你需要实现类似通讯录或则聊天列表的滚动效果，你需要使用 scroll-view 滚动容器组件，它实现的效果如 css 样式设置的 overflow:scroll 。</li>
<li>swiper 是滑块视图组件，如果你要实现类似轮播图的效果的话，他是你的不二之选，你能通过属性配置来控制是否显示圆点，是否自动播放，切换时间，以及切换间隔时间等。<br>小程序的MANA也实现了数据的绑定，写法类似于 Angular 和 Vue，通过双括号的形式 如： 即可，值得注意的是，如果你写在容器（为了便于描述和理解，下文会以标签来描述）于之间的话，你直接把变量写在双括号里即可，如：<view></view> ，但是如果你给标签的属性绑定变量，你需要将双括号放在双引号内，如：<view wx:if="””&gt;</view">,类似于Angular 和 Vue，你也能在双括号内进行简单的运算，如：<view hidden="”{flag?true:false}”"></view>。</view></li>
</ol>
<p>细心的同学可能发现了在介绍数据绑定的时候我们用了wx:if  的属性，这是 MANA 提供的条件渲染，通过判断 wx:if 传布尔值（非布尔类型进行隐士转化）来控制是否渲染标签中的内容。在 MANA 中还有一个属性能控制内容的显隐，不同的是，wx:if 只有在为 true 的时候才回去渲染标签中的内容，而 hidden 始终会渲染内容，只是根据条件来控制内容的显示与否。</p>
<p>此外MANA 也为我们提供了较为实用的列表渲染，wx:for 接受一个数组,在页面中能根据数组中的值来渲染页面列表</p>
<p>除了使用列表渲染来复用一块视图外，你还可以通过模版来进行复用，你能在 template 中定义一块代码片段，然后在不同的页面中引用，如：</p>
<pre><code>&lt;template name=&quot;odd&quot;&gt;
  &lt;view&gt; odd &lt;/view&gt;
&lt;/template&gt;
&lt;template name=&quot;even&quot;&gt;
  &lt;view&gt; even &lt;/view&gt;
&lt;/template&gt;

&lt;block wx:for=&quot;{{[1, 2, 3, 4, 5]}}&quot;&gt;
    &lt;template is=&quot;{{item % 2 == 0 ? 'even' : 'odd'}}&quot;/&gt;
&lt;/block&gt;
</code></pre><p>除了 template 外，MANA 还提供了另外两种方式来进行应用和复用，import 和 include ，import 有作用域的概念，他只会引用目标文件中定义的模版。include可以将目标文件除了<template>的整个代码引入，相当于是拷贝到include位置上。</template></p>
<p>除MANA 同样也定义了常用的事件分类，如</p>
<ol>
<li>touchstart 手指触摸动作开始</li>
<li>touchmove 手指触摸后移动</li>
<li>touchcancel 手指触摸动作被打断，如来电提醒，弹窗</li>
<li>touchend 手指触摸动作结束</li>
<li>tap 手指触摸后马上离开</li>
<li>longtap 手指触摸后，超过350ms再离开<h2 id="4-组件样式"><a href="#4-组件样式" class="headerlink" title="4.组件样式"></a>4.组件样式</h2></li>
</ol>
<p>定义在 app.wxss 中的样式为全局样式，作用于每一个页面。在 page 的 wxss 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 app.wxss 中相同的选择器。如果你写过 css ，那你就能轻松驾驭 wxss,wxss 在选择器上做了限制，目前支持的选择器有：</p>
<ol>
<li>.class 如：.intro    选择所有拥有 class=”intro” 的组件</li>
<li><code>#id</code> 如：<code>#firstname</code>    选择拥有 id=”firstname” 的组件</li>
<li>element  如：    view    选择所有 view 组件</li>
<li>element, 如： element    view checkbox    选择所有文档的 view 组件和所有的 checkbox 组件</li>
<li>::after     如：view::after    在 view 组件后边插入内容</li>
<li>::before     如：view::before    在 view 组件前边插入内容</li>
</ol>
<p>开发过移动端的前端er 都知道，苹果手机有物理像素和逻辑像素的区别，比如设备的像素是350px，设计稿的像素是750px；一般在开发过程中，我们会使用自动化构建工具去做像素转化，或则是使用预处理器定义像素转化函数进行处理，在小程序的开发中，大可不必这么麻烦，小程序提供了一个 rpx 的单位，你可以直接写上你在设计稿中测量的数值即可，小程序开发工具在编译过程中会自动帮你做转换。</p>
<p>在下次小程序分享《小程序开发踩坑（二）》的时候，会教大家如何与后端进行数据交互，欢迎感兴趣的小伙伴订阅博客。</p>
<p><img src="/img/bVEXHS" alt="蜂贷微信端"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2016/03/30/learn-gulp/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/30/learn-gulp/" itemprop="url">
                  learn-gulp
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-03-30T20:37:03+08:00">
                2016-03-30
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/03/30/learn-gulp/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/30/learn-gulp/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="为什么要前端自动化"><a href="#为什么要前端自动化" class="headerlink" title="为什么要前端自动化"></a>为什么要前端自动化</h3><blockquote>
<p>什么是前端自动化构建就不说了，应为我不是写书的。在前端开发实践中，大公司都会有自己的基础前端架构，能容包括了开发环境、代码管理，代码质量，性能检测，命令行工具，开发规范，开发流程，前端架构及性能优化。相对而言，小公司或则是创业型的公司，前端架构这块做得就相对没有这么好，甚至于很不规范，而规范的目的在于提升工作效率。</p>
</blockquote>
<p>而规范需要一定的过程，我们就先从代码质量，代码管理上入手。</p>
<ol>
<li>对代码（html，css，js）进行语法检查</li>
<li>对图片，代码进行压缩</li>
<li>对sass。less 的css预处理器进行编译</li>
<li>期望代码有改动后，能自动刷新页面</li>
<li>…</li>
</ol>
<p>这些操作，我们可以通过人工来完成，但是效率真的低到没朋友，难道语法检查你要自己一行一行的<code>review</code>，或则是拜托你的同事帮你一行一行的 <code>review</code> 么。如果你让我做这个，我肯定和你绝交…但是 <code>review</code> 的目的是帮助我们写出高质量的代码。这是必不可少的，所以我们期望能有一个自动帮我们实现代码检测压缩的工具。只要一个命令，你就能轻松的实现代码压缩，图片压缩，<code>css</code>预处理器编译等原来需要你去人工完成的任务，是不是爽到爆炸。</p>
<p>在项目自动化构建工具中，大家用得比较多的，分别是<code>grunt</code>，<code>gulp</code>。与这些自动化工具配套的包管理工具呢，通常还有<code>npm</code>。<code>node</code>包含了<code>npm</code>的包，所以只要你的系统里安装的 <code>node</code>，你就可以在你的控制台里通过 npm install 来安装你的项目依赖。还有的就是最近流行起来的 <code>webpack</code> 模块管理工具,大家对<code>webpack</code> 的反应也很好，所以我们打算在项目开发的时候把 gulp 和 webpack 一起用起来，并把研究后的搭建流程写成教程。这次分享的是gulp的搭建，下次等我的后台项目开始用 webpack 的时候，再来分享一篇。</p>
<h3 id="从零开始搭建-gulp-前端自动化"><a href="#从零开始搭建-gulp-前端自动化" class="headerlink" title="从零开始搭建 gulp 前端自动化"></a>从零开始搭建 gulp 前端自动化</h3><ol>
<li>安装node.js</li>
<li>npm init 生成package文件，或则你可以自己手动生成</li>
<li>在控制台中输入<code>npm install --save-dev gulp</code>命令，在项目中安装gulp</li>
<li>配置gulp任务</li>
<li>在控制台中输入 <code>gulp</code>或则<code>gulp default</code>测试你的gulp任务</li>
<li>配置你真正需要的 gulp 任务，（压缩，代码质量检查，浏览器自动刷新）</li>
</ol>
<pre><code>var gulp = require(&apos;gulp&apos;);
gulp.task(&apos;default&apos;,function(){
    console.log(&quot;hello&quot;)
});



#####浏览器自动刷新

1. 在你的谷歌浏览器里安装插件。关键字`livereload`
2. 通过命令`mpn install gulp-livereload --save-dev`来安装依赖
3. 在gulp文件中引入`livereload = require(&apos;gulp-livereload&apos;),`
4. 在gulp的`watch`任务中通过 `livereload.listen([options])`启动刷新服务
5. 定义的任务在最后加入一个工作流`.pipe(livereload())`,
6. 在启动后进入到这个任务后，开启谷歌插件，就能自动刷新浏览器了

#gulpfile.js 文件

    var gulp = require(&apos;gulp&apos;),
    uglify = require(&apos;gulp-uglify&apos;),
    livereload = require(&apos;gulp-livereload&apos;),

gulp.task(&apos;test&apos;,function() {
    return gulp.src(&apos;js/test.js&apos;)
        .pipe(uglify())
        .pipe(gulp.dest(&apos;build&apos;))
        .pipe(livereload())
});

gulp.task(&apos;watch&apos;,function(){
    livereload.listen();
    gulp.watch(&apos;js/test.js&apos;, [&apos;test&apos;]);
});

当你修改你的test.js 文件之后，ctrl + s 保存，你就可以看到时时刷新。
</code></pre><p> 7.代码压缩</p>
<pre><code>1.通过命令`mpn install gulp-uglify --save-dev`来安装依赖(js 压缩)
2.通过命令`mpn install gulp-concat --save-dev`来安装依赖(合并压缩后的文件到一个文件)

    #gulpfile.js 文件

    uglify = require(&apos;gulp-uglify&apos;),

    gulp.task(&apos;compress&apos;,function(){
    return gulp.src(&apos;js/servers/*.js&apos;)
        .pipe(uglify())
        .pipe(concat(&apos;all.js&apos;))
        .pipe(gulp.dest(&apos;dist/js&apos;))
        .pipe(livereload())
});
</code></pre><p> 8.同理css压缩，生成雪碧图等task，代码质量检查，都是同样的先安装依赖，再引用，编写task</p>
<p><strong>如果你想深入学习</strong></p>
<p><a href="https://segmentfault.com/a/1190000004638228" target="_blank" rel="external">我理想中的前端工作流</a><br><a href="http://www.gulpjs.com.cn/" target="_blank" rel="external">gulp 中文网</a><br><a href="https://scotch.io/tutorials/a-quick-guide-to-using-livereload-with-gulp" target="_blank" rel="external">livereload</a><br><a href="https://www.npmjs.com/package/gulp-livereload" target="_blank" rel="external">gulp-livereload</a>ulp-livereload)</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2015/11/15/ng1-style-guide1/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/15/ng1-style-guide1/" itemprop="url">
                  ng1-style-guide1
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-11-15T20:20:00+08:00">
                2015-11-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2015/11/15/ng1-style-guide1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/11/15/ng1-style-guide1/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一个好的编程风格有助于团队的协同开发，所以在做 angular 开发时，我们也有一些约定，本文章主要是针对于使用 angular 和 coffeescript 编程的团队。（这是一个粗糙的翻译版本，原文的链接在文章下，感兴趣的同学可以去看）</p>
<blockquote>
<p><a href="https://github.com/johnpapa/angular-styleguide" target="_blank" rel="external">Angular 编程风格指导原文地址</a></p>
</blockquote>
<p>##1. 单一职责</p>
<p><strong>原则 1：一个文件只能定义一个组件</strong></p>
<p>下面的例子定义了app模块和他的依赖，把控制器和服务都定义到一个文件了</p>
<pre><code>-- 不推荐 --
SomeController = ()-&gt;
someFactory = ()-&gt;
angular
    .module(&apos;app&apos;, [&apos;ngRoute&apos;])
    .controller(&apos;SomeController&apos; , SomeController)
    .factory(&apos;someFactory&apos; , someFactory)
</code></pre><p>同样的组建，现在我们把它分解到他们自己的文件中</p>
<pre><code>-- 推荐方式 --
-- app.module.js --

angular
    .module(&apos;app&apos;, [&apos;ngRoute&apos;])


-- 推荐方式 --
-- someController.js --
SomeController = ()-&gt;
angular
    .module(&apos;app&apos;)
    .controller(&apos;SomeController&apos; , SomeController)


-- 推荐方式 --
-- someFactory.js --
someFactory = ()-&gt;
angular
    .module(&apos;app&apos;)
    .factory(&apos;someFactory&apos; , someFactory)
</code></pre><p>##2. 模块</p>
<p><strong>原则 2：定义模块的时候不要用变量来定义，用设置的语法来定义</strong></p>
<blockquote>
<p>因为我们使用的单一职责的原则，每一个组建一个文件，在定义组建的时候你已经用<code>angular.module</code>来介绍这个组建是哪个模块的了。</p>
</blockquote>
<pre><code>-- 不推荐 --
app = angular.module(&apos;app&apos;, [
    &apos;ngAnimate&apos;
    &apos;ngRoute&apos;
    &apos;app.shared&apos;
    &apos;app.dashboard&apos;
])
</code></pre><p>下面是不用变量的语法</p>
<pre><code>-- 推荐方式 --
angular
    .module(&apos;app&apos;, [
    &apos;ngAnimate&apos;
    &apos;ngRoute&apos;
    &apos;app.shared&apos;
    &apos;app.dashboard&apos;
])
</code></pre><p><strong>拓展</strong>：当使用模块的时候，不要用变量，要用链式定义的语法</p>
<blockquote>
<p>这样做能够使代码的可读性更高，同时也能避免变量的泄露和碰撞（重名）</p>
</blockquote>
<pre><code>-- 不推荐--
app = angular.module(&apos;app&apos;)
app.controller(&apos;SomeController&apos; , SomeController)
SomeController = ()-&gt;

-- 推荐方式 --
SomeController = ()-&gt;

angular
  .module(&apos;app&apos;)
  .controller(&apos;SomeController&apos; , SomeController)
</code></pre><p><strong>设置 vs 获取</strong>所有的实例只要设置一次</p>
<blockquote>
<p>一个模块只要被创建一次，之后的模块获取只要通过这个切入点来获取就可以了</p>
</blockquote>
<ul>
<li>用 <code>angular.module(&#39;app&#39;, [])</code> 来设置模块</li>
<li>用<code>angular.module(&#39;app&#39;)</code>来获取模块</li>
</ul>
<p><strong>命名函数 vs 匿名函数</strong>：使用命名函数来代替向回掉函数传递匿名函数</p>
<blockquote>
<p>这样能够是代码的可读性更高，更加容易debug，减少回调函数的嵌套</p>
</blockquote>
<pre><code>-- 不推荐 --
angular
  .module(&apos;app&apos;)
  .controller(&apos;Dashboard&apos;, ()-&gt;)
  .factory(&apos;logger&apos;, ()-&gt; )

-- 推荐方式 --
-- dashboard.js --
Dashboard = ()-&gt;
  # logic goes here --&gt;
  return

angular
  .module(&apos;app&apos;)
  .controller(&apos;Dashboard&apos;, Dashboard)

-- 推荐方式 --
-- logger.js --
logger = ()-&gt;
  # logic goes here --&gt;
  return

angular
  .module(&apos;app&apos;)
  .factory(&apos;logger&apos;, logger)
</code></pre><p><strong>IIFE（立即调用函数表达式）：</strong>把angular 组建包裹在能够马上调用的函数表达式中</p>
<blockquote>
<p>IIFE 把变量从全局作用域里解放出来，这样做能防止把变量和函数定义在全局作用句中从而造成变量的碰撞（）变量重名造成的莫名其妙的bug）</p>
</blockquote>
<pre><code>(-&gt;
  logger = ()-&gt;
    # logic goes here --&gt;
    return

  angular
    .module(&apos;app&apos;)
    .factory(&apos;logger&apos;, logger);

)()
</code></pre><p><strong>主意</strong>：为了使代码更加简洁，下面的编程先省略 IIFE 语法</p>
<p>##3. 控制器</p>
<p><strong>controller as view 语法：</strong>用 <code>controllerAs</code>语法来代替经典的把controller 绑定到  $scope 作用域的语法</p>
<ul>
<li>控制器是一个构造类，需要通过<code>newed</code>来创建一个新的实例，但是<code>controllerAS</code>语法更像 javascript 的构造函数</li>
<li>这样的用法能够促进我们在视图中绑定对应对象的变量（ 用<code>customer.name</code>来取代<code>name</code>）等等，这样能够是我们的代码更易读，避免我们没有指定对象的时候的一些参考问题。</li>
<li><p>能够让我们避免在视图中的嵌套控制器中使用<code>$parent</code>来调用父级控制器</p>
<pre><code>-- 不推荐 --
&lt;div ng-controller=&quot;Customer&quot;&gt;
  {{ name }}
&lt;/div&gt;
-- 推荐方式 --
&lt;div ng-controller=&quot;Customer as customer&quot;&gt;
  {{ customer.name }}
&lt;/div&gt;
</code></pre></li>
</ul>
<p><strong>controllerAs Controller Syntax</strong>：用<code>controllerAs</code>来代替<code>传统的将控制器绑定到$scope</code>的语法</p>
<ul>
<li><code>controllerAs</code>通过 <code>this</code>来从控制器的内部把返回的内容绑定到$scope 上<br><code>controllerAs</code>在语法上比 <code>$scope</code>要友好，使用<code>controllerAs</code> 你依旧可以把把数据绑定到视图，依旧可以访问绑定在<code>$scope</code>上的方法</li>
<li><p>能够避免可能把方法定义到服务上更好的时候，想要将控制器中的方法绑定到<code>$scope</code>上，在服务中要考虑$scope 的用法，在控制器中只有必要的时候才能绑定到<code>$scope</code>上，举个例子，当要通过<code>$emit</code>,<code>$broadcast</code>,<code>$on</code>来传递和接收事件的时候，要在服务中定义，再在控制器中调用<br><strong>主意</strong>：介于 coffeescript 会自动返回最后一行，我们最好在函数的最后一行加上一个return 声明（即使这个函数没有任何东西返回），大多数上可以没有返回声明，但是在我自己的开发过程中，没有返回声明的时候，会报错，所以建议还是加上这个返回声明</p>
<pre><code>-- 不推荐 --
(-&gt;
  Customer = ($scope)-&gt;
    $scope.name = {}
    $scope.sendMessage = ()-&gt;
  angular
    .module(&apos;app&apos;)
    .controller(&apos;Customer&apos;, Customer)
)()
-- 推荐方法 --
(-&gt;
  Customer = ()-&gt;
    @name = {}
    @sendMessage = ()-&gt;
    return

  angular
    .module(&apos;app&apos;)
    .controller(&apos;Customer&apos;, Customer)
)()
</code></pre></li>
</ul>
<p><strong>controllerAS with vm</strong>当使用<code>controllerAs</code>语法时，用一个变量来代替 this ，找一个统一的变量名来代替视图模型例如 <code>vm</code></p>
<p><code>this</code>关键字是联系上下文的，当在控制器中使用函数的时候可能会改变上下文，为了避免这样的情况，最好用一个变量来捕获<code>this</code></p>
<pre><code>-- 不推荐 --
(-&gt;
  Customer = ()-&gt;
    @name = {}
    @sendMessage = ()-&gt;
      # here @/this is not the same
      @stuff = &quot;stuff&quot;

    return
  angular
    .module(&apos;app&apos;)
    .controller(&apos;Customer&apos;, Customer)
)()


-- 推荐方式 --
(-&gt;
  Customer = ()-&gt;
    vm = @
    vm.name = {}
    vm.sendMessage = ()-&gt;

    return
  angular
    .module(&apos;app&apos;)
    .controller(&apos;Customer&apos;, Customer)
)()
</code></pre><p>【tip】</p>
<pre><code>### OR use the fat arrow in functions =&gt; ###
(-&gt;
  Customer = ()-&gt;
    @name = {}
    @sendMessage = ()=&gt;
      @stuff

    return
  angular
    .module(&apos;app&apos;)
    .controller(&apos;Customer&apos;, Customer)
)()
</code></pre><p>【note】：你可以把下面这段代码放到你的代码的最前一行，来避免一些组建的语法检查</p>
<pre><code>### jshint validthis: true ###
vm = @
</code></pre><p><strong>把变量放在控制器的最前面</strong></p>
<p>把数据绑定的变量成员（按照字母顺序）放在控制器的最前面，而不是遍布在整个控制器中。</p>
<blockquote>
<p>把数据绑定的变量成员放在控制器的最前面,使程序更加易读，帮你立即分辨控制器中这个变量成员可以绑定在视图中</p>
</blockquote>
<pre><code>-- 不推荐 --
function SessionsController() {
    var vm = this;

    vm.gotoSession = function() {
      /* ... */
    };
    vm.refresh = function() {
      /* ... */
    };
    vm.search = function() {
      /* ... */
    };
    vm.sessions = [];
    vm.title = &apos;Sessions&apos;;
}

-- 推荐方式 --
function SessionsController() {
    var vm = this;

    vm.gotoSession = gotoSession;
    vm.refresh = refresh;
    vm.search = search;
    vm.sessions = [];
    vm.title = &apos;Sessions&apos;;

    ////////////

    function gotoSession() {
      /* */
    }

    function refresh() {
      /* */
    }

    function search() {
      /* */
    }
}
</code></pre><p>【note】 如果函数是一行的就把函数也放在控制器的前面，这样做对代码的阅读性不会有影响</p>
<pre><code>-- 不推荐--
function SessionsController(data) {
    var vm = this;

    vm.gotoSession = gotoSession;
    vm.refresh = function() {
        blabla
    };
    vm.search = search;
    vm.sessions = [];
    vm.title = &apos;Sessions&apos;;
}



-- 推荐方法--
function SessionsController(sessionDataService) {
    var vm = this;

    vm.gotoSession = gotoSession;
    vm.refresh = sessionDataService.refresh; // 1 liner is OK
    vm.search = search;
    vm.sessions = [];
    vm.title = &apos;Sessions&apos;;
}
</code></pre><h3 id="函数声明，隐藏实现细节"><a href="#函数声明，隐藏实现细节" class="headerlink" title="函数声明，隐藏实现细节"></a>函数声明，隐藏实现细节</h3><p>函数声明，隐藏实现的细节。把用于数据绑定的变量成员的声明，放在控制器的前面，实现放在文件的后面。</p>
<ul>
<li>把数据绑定的成员放在前面易于代码的阅读，能让你一眼就分辨出哪个变量用于视图的哪块区域的绑定</li>
<li>把函数的实现放在文件的后面，把函数实现这部分比较复杂的部分放在后面。能让你直接看到函数声明这部分重要的信息</li>
<li>因为函数的声明被提升了，所以在函数定义前，你是不需要关心这个函数的</li>
<li>你不需要担心函数声明的位子移动的问题，你不用担心”因为a函数是依赖于b函数的，a函数移动到b函数前面会让你的代码出错”这样子的问题</li>
<li><p>顺序在函数表达式中很重要</p>
<pre><code>--不建议使用函数表达式--
function AvengersController(avengersService, logger) {
    var vm = this;
    vm.avengers = [];
    vm.title = &apos;Avengers&apos;;

    var activate = function() {
        return getAvengers().then(function() {
            logger.info(&apos;Activated Avengers View&apos;);
        });
    }

    var getAvengers = function() {
        return avengersService.getAvengers().then(function(data) {
            vm.avengers = data;
            return vm.avengers;
        });
    }

    vm.getAvengers = getAvengers;

    activate();
}
</code></pre></li>
</ul>
<p>主意上面的例子中把重要的函数声明分散在控制器中，但在下面的例子中重要的函数声明都被提升到了顶部。举个栗子，函数绑定变量如<code>vm.avengers</code>和<code>vm.title</code>，把函数实现的细节放在后面，这样更加有利于代码的阅读</p>
<pre><code>--  推荐方法 --
function AvengersController(avengersService, logger) {
    var vm = this;
    vm.avengers = [];
    vm.getAvengers = getAvengers;
    vm.title = &apos;Avengers&apos;;

    activate();

    function activate() {
        return getAvengers().then(function() {
            logger.info(&apos;Activated Avengers View&apos;);
        });
    }

    function getAvengers() {
        return avengersService.getAvengers().then(function(data) {
            vm.avengers = data;
            return vm.avengers;
        });
    }
}
</code></pre><p>###把控制器的逻辑定义放到服务中</p>
<ul>
<li>逻辑可能会在多个控制器中复用，通过封装在服务中来通过函数暴露给控制器</li>
<li>把逻辑封装在服务中，能更容易在单元测试中分离成独立作用域，在控制器中调用函数也更容易模拟</li>
<li>从控制器中移除依赖，把实现细节隐藏起来</li>
<li><p>让控制器变得简单，苗条，且专注</p>
<pre><code>-- 不推荐 --
function OrderController($http, $q, config, userInfo) {
    var vm = this;
    vm.checkCredit = checkCredit;
    vm.isCreditOk;
    vm.total = 0;

    function checkCredit() {
        var settings = {};
        // Get the credit service base URL from config
        // Set credit service required headers
        // Prepare URL query string or data object with request data
        // Add user-identifying info so service gets the right credit limit for this user.
        // Use JSONP for this browser if it doesn&apos;t support CORS
        return $http.get(settings)
            .then(function(data) {
             // Unpack JSON data in the response object
               // to find maxRemainingAmount
               vm.isCreditOk = vm.total &lt;= maxRemainingAmount
            })
            .catch(function(error) {
               // Interpret error
               // Cope w/ timeout? retry? try alternate service?
               // Re-reject with appropriate error for a user to see
            });
    };
}
-- 推荐方法 --
function OrderController(creditService) {
    var vm = this;
    vm.checkCredit = checkCredit;
    vm.isCreditOk;
    vm.total = 0;

    function checkCredit() {
       return creditService.isOrderTotalOk(vm.total)
          .then(function(isOk) { vm.isCreditOk = isOk; })
          .catch(showError);
    };
}
</code></pre></li>
</ul>
<h3 id="使控制器变得专注"><a href="#使控制器变得专注" class="headerlink" title="使控制器变得专注"></a>使控制器变得专注</h3><p>为一个视图定义一个控制器，不要讲一个控制器为多个视图复用，要把复用的逻辑封装到服务中，保证一个控制器只专注于他的视图</p>
<p>给多个视图复用的控制器是很脆的，一个好的 E2E测试覆盖率是用来确定一个应用的稳定性的</p>
<h3 id="路由分配"><a href="#路由分配" class="headerlink" title="路由分配"></a>路由分配</h3><p>当一个控制器必须和某个视图绑定但也有可能和其他视图或者控制器复用，把控制器的定义和路由条状一起定义</p>
<p>【note】如果一个视图不是通过路由而是通过其他方式加载的，请用<code>ng-controller=&quot;Avengers as vm&quot;</code>语法</p>
<p>在路由中分配控制器，允许不同的路由去调用不同的控制器和视图，当控制器是在视图中通过<code>ng-controller</code> 进行声明，那么这个视图就要和这个控制器一直关联</p>
<pre><code>-- 不推荐 --

// route-config.js
angular
    .module(&apos;app&apos;)
    .config(config);

function config($routeProvider) {
    $routeProvider
        .when(&apos;/avengers&apos;, {
          templateUrl: &apos;avengers.html&apos;
        });
}

&lt;!-- avengers.html --&gt;
&lt;div ng-controller=&quot;AvengersController as vm&quot;&gt;
&lt;/div&gt;



-- 推荐方式 --

// route-config.js
angular
    .module(&apos;app&apos;)
    .config(config);

function config($routeProvider) {
    $routeProvider
        .when(&apos;/avengers&apos;, {
            templateUrl: &apos;avengers.html&apos;,
            controller: &apos;Avengers&apos;,
            controllerAs: &apos;vm&apos;
        });
}
&lt;!-- avengers.html --&gt;
&lt;div&gt;
&lt;/div&gt;
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2015/11/10/ng1-style-guide2/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/10/ng1-style-guide2/" itemprop="url">
                  ng1-style-guide2
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-11-10T20:32:58+08:00">
                2015-11-10
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2015/11/10/ng1-style-guide2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/11/10/ng1-style-guide2/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一个好的编程风格有助于团队的协同开发，所以在做 angular 开发时，我们也有一些约定，本文章主要是针对于使用 angular 和 coffeescript 编程的团队。（这是一个粗糙的翻译版本，原文的链接在文章下，感兴趣的同学可以去看）</p>
<p><a href="https://github.com/Plateful/plateful-mobile/wiki/AngularJS-CoffeeScript-Style-Guide#factories" target="_blank" rel="external">Angular 编程引导</a></p>
<h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><h4 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h4><blockquote>
<p>服务是通过<code>new</code>关键字进行实例化的，用<code>this</code>来定义调用公用的方法和变量，和工厂服务很相似，为了统一，可以使用工厂服务</p>
</blockquote>
<p>【note】：所有的 angular 服务都是单例模式，这就意味着服务的每次注入都只有一个实例</p>
<pre><code>// service
angular
    .module(&apos;app&apos;)
    .service(&apos;logger&apos;, logger);

function logger() {
  this.logError = function(msg) {
    /* */
  };
}

// factory
angular
    .module(&apos;app&apos;)
    .factory(&apos;logger&apos;, logger);

function logger() {
    return {
        logError: function(msg) {
          /* */
        }
   };
}
</code></pre><h3 id="工厂服务"><a href="#工厂服务" class="headerlink" title="工厂服务"></a>工厂服务</h3><h4 id="单一职责"><a href="#单一职责" class="headerlink" title="单一职责"></a>单一职责</h4><blockquote>
<p>工厂服务也应该是<code>单一职责</code>，当一个服务要实现的功能超过一个目的，就要重新定义一个工厂服务</p>
</blockquote>
<h4 id="单例-1"><a href="#单例-1" class="headerlink" title="单例"></a>单例</h4><blockquote>
<p>工厂服务是单例服务，返回的对象包括了服务的成员对象</p>
</blockquote>
<p>【note】所有的 Angular 服务都是单例</p>
<h4 id="可调用的成员靠前"><a href="#可调用的成员靠前" class="headerlink" title="可调用的成员靠前"></a>可调用的成员靠前</h4><blockquote>
<p>将服务器的可调用的成员（暴露的接口）提升到服务器前面，（从《学习 javascript 设计模式》中派生出来）</p>
</blockquote>
<ul>
<li>把可调用的变量成员放在服务的最前面，能提供你的代码可读性，能让你一眼就看出，这个服务哪些成员变量是可调用和可被测试的</li>
<li>在文件变长的时候，这样做就显得很有必要了，你不用滚动到文件的下面去查看，这个服务到底暴露了哪些接口</li>
<li>当你的函数超过一行代码的时候，会降低你的代码可读性，阅读时也会造成多余的滚动操作，所以你要把可调用接口的定义，和服务的return ，提升到文件的顶部定义，把实现的细节放在文件下面，这样来增加代码的可读性</li>
</ul>
<pre><code>      ### 不推荐方式 ###
(-&gt;
  dataService = ()-&gt;

    someValue = &apos;&apos;

    save = ()-&gt;
      # ... #

    validate = ()-&gt;
      # ... #

    return
      save: save,
      someValue: someValue,
      validate: validate

  angular
    .module(&apos;app&apos;)
    .service(&apos;dataService&apos;, dataService)
)()

### 推荐方式 ###
(-&gt;
  dataService = ()-&gt;

    someValue = &apos;&apos;

    ##########

    return
      save: ()-&gt;
       # . #

      validate: ()-&gt;
       # . #
  angular
    .module(&apos;app&apos;)
    .service(&apos;dataService&apos;, dataService)
)()
</code></pre><p>这种方法绑定的的数据是宿主对象的映射，通过模块模式暴露的单一的原始数据是不能独自进行更新的</p>
<pre><code>### 不推荐方式 ###
angular
  .module(&apos;app.widgets&apos;)

  # order directive that is specific to the order module
  .directive(&apos;orderCalendarRange&apos;, orderCalendarRange)

  # sales directive that can be used anywhere across the sales app
  .directive(&apos;salesCustomerInfo&apos;, salesCustomerInfo)

  # spinner directive that can be used anywhere across apps
  .directive(&apos;sharedSpinner&apos;, sharedSpinner)

  ### implementation details ###



### 推荐方式 ###

 ###
 # @desc order directive that is specific to the order module at a company named Acme
 # @file calendarRange.directive.js
 # @example &lt;div acme-order-calendar-range&gt;&lt;/div&gt;
 ###
angular
  .module(&apos;sales.order&apos;)
  .directive(&apos;acmeOrderCalendarRange&apos;, orderCalendarRange)

 ###
 # @desc spinner directive that can be used anywhere across the sales app at a company named Acme
 # @file customerInfo.directive.js
 # @example &lt;div acme-sales-customer-info&gt;&lt;/div&gt;
 ###
angular
  .module(&apos;sales.widgets&apos;)
  .directive(&apos;acmeSalesCustomerInfo&apos;, salesCustomerInfo)

 ###
 # @desc spinner directive that can be used anywhere across apps at a company named Acme
 # @file spinner.directive.js
 # @example &lt;div acme-shared-spinner&gt;&lt;/div&gt;
 ###
angular
  .module(&apos;shared.widgets&apos;)
  .directive(&apos;acmeSharedSpinner&apos;, sharedSpinner)

  ### implementation details ###
</code></pre><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><blockquote>
<p>一个指令一个文件，把所有的指令混到一个文件中容易，但是，后面你要把这些指令从这个文件中分离出来就没那么容易了。所以那些需要在 App 和 模块中被共享的指令，一定要分离出来到一个文件中，这样也有利于代码的维护</p>
</blockquote>
<pre><code>### 不推荐方式###
angular
  .module(&apos;app.widgets&apos;)

  # order directive that is specific to the order module
  .directive(&apos;orderCalendarRange&apos;, orderCalendarRange)

  # sales directive that can be used anywhere across the sales app
  .directive(&apos;salesCustomerInfo&apos;, salesCustomerInfo)

  # spinner directive that can be used anywhere across apps
  .directive(&apos;sharedSpinner&apos;, sharedSpinner)

  ### implementation details ###


### 推荐方式 ###

 ###
 # @desc order directive that is specific to the order module at a company named Acme
 # @file calendarRange.directive.js
 # @example &lt;div acme-order-calendar-range&gt;&lt;/div&gt;
 ###
angular
  .module(&apos;sales.order&apos;)
  .directive(&apos;acmeOrderCalendarRange&apos;, orderCalendarRange)

 ###
 # @desc spinner directive that can be used anywhere across the sales app at a company named Acme
 # @file customerInfo.directive.js
 # @example &lt;div acme-sales-customer-info&gt;&lt;/div&gt;
 ###
angular
  .module(&apos;sales.widgets&apos;)
  .directive(&apos;acmeSalesCustomerInfo&apos;, salesCustomerInfo)

 ###
 # @desc spinner directive that can be used anywhere across apps at a company named Acme
 # @file spinner.directive.js
 # @example &lt;div acme-shared-spinner&gt;&lt;/div&gt;
 ###
angular
  .module(&apos;shared.widgets&apos;)
  .directive(&apos;acmeSharedSpinner&apos;, sharedSpinner)

  ### implementation details ###
</code></pre><h4 id="限制DOM的操作"><a href="#限制DOM的操作" class="headerlink" title="限制DOM的操作"></a>限制DOM的操作</h4><blockquote>
<p>限制DOM的操作，用指令来直接操作DOM，如果有可以替代的方式，如使用css来设置样式，使用 animation 服务，angular 的模版，ngShow 或者 ngHide ，那么就用这些来代替指令。举个例子，如果指令就是定义一个简单的显示和隐藏，那么久用 nghide 和 ngShow 来代替，但是如果指令除了显示隐藏还需要处理更加复杂的事情，那就把显示隐藏和其他需要实现的操作，一起封装到这个指令里，这样能减少 angular 的监听，来提高应用的性能。</p>
</blockquote>
<ul>
<li>对 DOM 的操作不太容易进行测试和调试，我们有更好的办法前提是对DOM的操作比较简单的话（css，animations，templating）</li>
</ul>
<h4 id="限制元素和属性"><a href="#限制元素和属性" class="headerlink" title="限制元素和属性"></a>限制元素和属性</h4><blockquote>
<p>限制元素和属性：当创建一个指令，这个指令的如果表现的像一个元素，那么 restrict 设置为 E ，也可以选择设置成 A，，如果这个指令能有他自己的控制器， restrict 设置为 E 是最理想的，不过通常的话，一些引导是将 restrict 设置为 EA，但当指令被封装在独立作用域时，倾向于元素指令表现<br>，当增强于现有的 DOM 元素，倾向于属性表现</p>
</blockquote>
<ul>
<li>这样做有意义</li>
<li><p>如果指令倾向于表现得像元素或者属性，这就允许我们定义的指令使用 class 属性</p>
<pre><code>&lt;!--不推荐方式--&gt;
&lt;div class=&quot;my-calendar-range&quot;&gt;&lt;/div&gt;
### avoid ###
(-&gt;
  myCalendarRange = ()-&gt;
      link = (scope, element, attrs)-&gt;
        # ... #

      directive =
        link: link,
        templateUrl: &apos;/template/is/located/here.html&apos;,
        restrict: &apos;C&apos;

      return directive

  angular
      .module(&apos;app.widgets&apos;)
      .directive(&apos;myCalendarRange&apos;, myCalendarRange)
)()
&lt;!-- recommended --&gt;
&lt;my-calendar-range&gt;&lt;/my-calendar-range&gt;
&lt;div my-calendar-range&gt;&lt;/div&gt;

### 推荐方式 ###
(-&gt;

  myCalendarRange = ()-&gt;

      link = (scope, element, attrs)-&gt;
        # ... #

      directive =
          link: link,
          templateUrl: &apos;/template/is/located/here.html&apos;,
          restrict: &apos;EA&apos;

      return directive

  angular
      .module(&apos;app.widgets&apos;)
      .directive(&apos;myCalendarRange&apos;, myCalendarRange)
)()
</code></pre></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/bbt.jpeg"
               alt="bailinlin" />
          <p class="site-author-name" itemprop="name">bailinlin</p>
          <p class="site-description motion-element" itemprop="description">前端,白霸天,博客</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">8</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bailinlin</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"baibatian"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  








  
  

  

  

  

  


</body>
</html>
