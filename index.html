<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="前端,白霸天,博客">
<meta property="og:type" content="website">
<meta property="og:title" content="白霸天的博客">
<meta property="og:url" content="https://bailinlin.github.com/index.html">
<meta property="og:site_name" content="白霸天的博客">
<meta property="og:description" content="前端,白霸天,博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="白霸天的博客">
<meta name="twitter:description" content="前端,白霸天,博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://bailinlin.github.com/"/>





  <title> 白霸天的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">白霸天的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2018/05/15/maidian/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/05/15/maidian/" itemprop="url">
                  埋点的实现原理了解一下么
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-15T16:08:20+08:00">
                2018-05-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2018/05/15/maidian/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/05/15/maidian/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>埋点，是网站分析的一种常用的数据采集方法。我们主要用来采集用户行为数据（例如页面访问路径，点击了什么元素）进行数据分析，从而让运营同学更加合理的安排运营计划。现在市面上有很多第三方埋点服务商，百度统计，友盟，growingIO 等大家应该都不太陌生，大多情况下大家都只是使用，最近我研究了下 web 埋点，你要不要了解下。</p>
<h3 id="现有埋点三大类型"><a href="#现有埋点三大类型" class="headerlink" title="现有埋点三大类型"></a>现有埋点三大类型</h3><blockquote>
<p>用户行为分析是一个大系统，一个典型的数据平台。由用户数据采集，用户行为建模分析，可视化报表展示几个模块构成。现有的埋点采集方案可以大致被分为三种，手动埋点，可视化埋点，无埋点</p>
</blockquote>
<ol>
<li>手动埋点<br> 手动代码埋点比较常见，需要调用埋点的业务方在需要采集数据的地方调用埋点的方法。优点是流量可控，业务方可以根据需要在任意地点任意场景进行数据采集，采集信息也完全由业务方来控制。这样的有点也带来了一些弊端，需要业务方来写死方法，如果采集方案变了，业务方也需要重新修改代码，重新发布。</li>
<li>可视化埋点<br> 可是化埋点是近今年的埋点趋势，很多大厂自己的数据埋点部门也都开始做这块。优点是业务方工作量少，缺点则是技术上推广和实现起来有点难（业务方前端代码规范是个大前提）。阿里的活动页很多都是运营通过可视化的界面拖拽配置实现，这些活动控件元素都带有唯一标识。通过埋点配置后台，将元素与要采集事件关联起来，可以自动生成埋点代码嵌入到页面中。</li>
<li>无埋点<br> 无埋点则是前端自动采集全部事件，上报埋点数据，由后端来过滤和计算出有用的数据，优点是前端只要加载埋点脚本。缺点是流量和采集的数据过于庞大，服务器性能压力山大，主流的 GrowingIO 就是这种实现方案。</li>
</ol>
<p>我们暂时放弃可视化埋点的实现，在 <code>手动埋点</code> 和 <code>无埋点</code> 上进行了尝试，为了便于描述，下文我会称采集脚本为 SDK。</p>
<h3 id="思考几个问题"><a href="#思考几个问题" class="headerlink" title="思考几个问题"></a>思考几个问题</h3><blockquote>
<p>埋点开发需要考虑很多内容，贯穿着不轻易动手写代码的原则，我们在开发前先思考下面这几个问题</p>
</blockquote>
<ol>
<li>我们要采集什么内容，进行哪些采集接口的约定</li>
<li>业务方通过什么方式来调用我们的采集脚本</li>
<li>手动埋点：SDK 需要封装一个方法给业务方进行调用，传参方式业务方可控</li>
<li>无埋点：考虑到数据量对于服务器的压力，我们需要对无埋点进行开关配置，可以配置进行哪些元素进行无埋点采集</li>
<li>用户标识：游客用户和登录用户的采集数据怎么进行区分关联</li>
<li>设备Id：用户通过浏览器来访问 web 页面，设备Id需要存储在浏览器上，同一个用户访问不同的业务方网站，设备Id要保持一样，怎么实现</li>
<li>单页面应用：现在流行的单页面应用和普通 web 页面的数据采集是否有差异</li>
<li>混合应用：app 与 h5 的混合应用我们要怎么进行通讯</li>
</ol>
<h4 id="我们要采集什么内容，进行哪些采集接口的约定"><a href="#我们要采集什么内容，进行哪些采集接口的约定" class="headerlink" title="我们要采集什么内容，进行哪些采集接口的约定"></a>我们要采集什么内容，进行哪些采集接口的约定</h4><p>第一期我们先实现对 PV（即页面浏览量或点击量） 、UV（一天内同个访客多次访问） 、点击量、用户的访问路径的基础指标的采集。精细化分析的流量转化需要和业务相关，需要和数据分析方做约定，我们预留扩展。所以我们的采集接口需要进行以下的约定</p>
<pre>

    {
        "header":{ // HTTP 头部
            "X-Device-Id":" 550e8400-e29b-41d4-a716-446655440000", //设备ID，用来区分用户设备
            "X-Source-Url":"https://www.baidu.com/", //源地址，关联用户的整个操作流程，用于用户行为路径分析，例如登录，到首页，进入商品详情，退出这一整个完整的路径
            "X-Current-Url":"", //当前地址，用户行为发生的页面
            "X-User-Id":"",//用户ID，统计登录用户行为
        },
        "body":[{ // HTTP Body体
            "PageSessionID":"", //页面标识ID，用来区分页面事件，例如加载和离开我们会发两个事件，这个标识可以让我们知道这个事件是发生在一个页面上
            "Event":"loaded", //事件类型，区分用户行为事件
            "PageTitle":  "埋点测试页",  //页面标题，直观看到用户访问页面
            "CurrentTime":  “1517798922201”,  //事件发生的时间
            "ExtraInfo":  {
             }    //扩展字段，对具体业务分析的传参
        }]
    }

</pre>

<p>以上就是我们现在约定好了的通用的事件采集的接口，所传的参数基本上会根据采集事件的不同而发生变化。但是在用户的整一个访问行为中，用户的设备是不会变化的，如果你想采集设备信息可以重新约定一个接口，在整个采集开始之前发送设备信息，这样可以避免在事件采集接口上重复采集固定数据。</p>
<pre>

    {
        "header":{ // HTTP 头部
              "X-Device-Id"  ："550e8400-e29b-41d4-a716-446655440000"  ,      //  设备id
        },
        "body":{ // HTTP Body体
                  "DeviceType":  "web" ,   //设备类型
                 "ScreenWide"  :  768 , //  屏幕宽
                 "ScreenHigh":  1366 , //  屏幕高
                 "Language":    "zh-cn"  //语言
        }
    }

</pre>

<h4 id="业务方通过什么方式来调用我们的采集脚本"><a href="#业务方通过什么方式来调用我们的采集脚本" class="headerlink" title="业务方通过什么方式来调用我们的采集脚本"></a>业务方通过什么方式来调用我们的采集脚本</h4><p>埋点应该让调用的业务方，尽可能少有工作量，最好是什么都不用做，😁，但是实现起来有点难额。我们采用的方案是让业务方在代码里通过 script 脚本来引用我们的 SDK ，业务方只要配置一些需要的参数进行埋点定制（👆我们讲到过的无埋点的流量控制），然后什么都不做就可以进行基础数据的采集。</p>
<pre>

    (function() {
                var collect = document.createElement('script');
                collect.type = 'text/javascript';
                collect.async = true;
                collect.src =  'http://collect.trc.com/index.js';
                var s = document.getElementsByTagName('script')[0];
                s.parentNode.insertBefore(collect, s);
        })();


    //用户自定义要进行无埋点采集的元素，如果不进行无埋点采集，可以不配置
     var _XT = [];
      _XT.push(['Target','div']);

</pre>

<h4 id="手动埋点：SDK"><a href="#手动埋点：SDK" class="headerlink" title="手动埋点：SDK"></a>手动埋点：SDK</h4><p>如果业务方需要采集更多业务定制的数据，可以调用我们暴露出的方法进行采集</p>
<pre>

    //自定义事件
      sdk.dispatch('customEvent',{extraInfo:'自定义事件的额外信息'})

</pre>

<h4 id="游客与用户关联"><a href="#游客与用户关联" class="headerlink" title="游客与用户关联"></a>游客与用户关联</h4><p>我们使用 userId 来做用户标识，同一个设备的用户，从游客用户切换到登录用户，如果我们要把他们关联起来，需要有一个设备Id 做关联</p>
<h4 id="web-设备Id"><a href="#web-设备Id" class="headerlink" title="web 设备Id"></a>web 设备Id</h4><p>用户通过浏览器来访问 web 页面，设备Id需要存储在浏览器上，同一个用户访问不同的业务方网站，设备Id要保持一样。web 变量存储，我们第一时间想到的就是 cookie，sessionStorage，localStorage，但是这3种存储方式都和访问资源的域名相关。我们总不能每次访问一个网站就新建一个设备指纹吧，所以我们需要通过一个方法来跨域共享设备指纹</p>
<p>我们想到的方案是，通过嵌套 iframe 加载一个静态页面，在 iframe 上加载的域名上存储设备id，通过跨域共享变量获取设备id，共享变量的原理是采用了iframe 的 contentWindow通讯，通过 postMessage 获取事件状态，调用封装好的回调函数进行数据处理具体的实现方式</p>
<pre>

    //web 应用，通过嵌入 iframe 进行跨域 cookie 通讯，设置设备id,
        collect.setIframe = function () {
            var that = this
            var iframe = document.createElement('iframe')
            iframe.id = "frame",
            iframe.src = 'http://collectiframe.trc.com' // 配置域名代理，目的是让开发测试生产环境代码一致
            iframe.style.display='none' //iframe 设置的目的是用来生成固定的设备id，不展示
            document.body.appendChild(iframe)

            iframe.onload = function () {
                    iframe.contentWindow.postMessage('loaded','*');
            }

            //监听message事件，iframe 加载完成，获取设备id ，进行相关的数据采集
            helper.on(window,"message",function(event){
                that.deviceId = event.data.deviceId

                if(event.data && event.data.type == 'loaded'){
                    that.sendDevice(that.getDevice(), that.deviceUrl);
                    setTimeout(function () {
                        that.send(that.beforeload)
                        that.send(that.loaded)
                    },1000)
                }
            })
        }

</pre>

<p>iframe 与 SDK 通讯</p>
<pre>

    function receiveMessageFromIndex ( event ) {
        getDeviceInfo() // 获取设备信息
        var data =  {
                deviceId: _deviceId,
                type:event.data
        }

        event.source.postMessage(data, '*'); // 将设备信息发送给 SDK
    }

    //监听message事件
    if(window.addEventListener){
            window.addEventListener("message", receiveMessageFromIndex, false);
    }else{
            window.attachEvent("onmessage", receiveMessageFromIndex, false)

</pre>

<p>如果你想知道可以看我的另一篇博客 <a href="https://bailinlin.github.io/2018/03/05/cookie-share/" target="_blank" rel="external">web 浏览器指纹跨域共享</a></p>
<h4 id="单页面应用：现在流行的单页面应用和普通-web-页面的数据采集是否有差异"><a href="#单页面应用：现在流行的单页面应用和普通-web-页面的数据采集是否有差异" class="headerlink" title="单页面应用：现在流行的单页面应用和普通 web 页面的数据采集是否有差异"></a>单页面应用：现在流行的单页面应用和普通 web 页面的数据采集是否有差异</h4><blockquote>
<p>我们知道单页面应用都是无刷新的页面加载，所以我们在页面<code>跳转</code>的处理和我们的普通的页面会有所不同。单页面应用的路由插件运用了 window 自带的无刷新修改用户浏览记录的方法，pushState 和 replaceState。</p>
</blockquote>
<p>window 的 history 对象 提供了两个方法，能够无刷新的修改用户的浏览记录，pushSate，和 replaceState，区别的 pushState 在用户访问页面后面添加一个访问记录， replaceState 则是直接替换了当前访问记录，所以我们只要改写 history 的方法，在方法执行前执行我们的采集方法就能实现对单页面应用的页面跳转事件的采集了</p>
<pre>

     // 改写思路：拷贝 window 默认的 replaceState 函数，重写 history.replaceState 在方法里插入我们的采集行为，在重写的 replaceState 方法最后调用，window 默认的 replaceState 方法

        collect = {}
        collect.onPushStateCallback : function(){}  // 自定义的采集方法

        (function(history){
            var replaceState = history.replaceState;   // 存储原生 replaceState
            history.replaceState = function(state, param) {     // 改写 replaceState
               var url = arguments[2];
               if (typeof collect.onPushStateCallback == "function") {
                     collect.onPushStateCallback({state: state, param: param, url: url});   //自定义的采集行为方法
               }
               return replaceState.apply(history, arguments);    // 调用原生的 replaceState
            };
         })(window.history);

</pre>


<p>这块介绍起来也比较的复杂，如果你想了解更多，可以看我的另一篇博客<a href="https://bailinlin.github.io/2018/04/28/history/" target="_blank" rel="external">你需要知道的单页面路由实现原理</a></p>
<h4 id="混合应用：app-与-h5-的混合应用我们要怎么进行通讯"><a href="#混合应用：app-与-h5-的混合应用我们要怎么进行通讯" class="headerlink" title="混合应用：app 与 h5 的混合应用我们要怎么进行通讯"></a>混合应用：app 与 h5 的混合应用我们要怎么进行通讯</h4><blockquote>
<p>现在大部分的应用都不是纯原生的应用， app 与 h5 的混合的应用是现在的一种主流。</p>
</blockquote>
<p>纯 web 数据采集我们考虑到前端存储数据容易丢失，我们在每一次事件触发的时候都用采集接口传输采集到的数据。考虑到现在很多用户的手机会有流量管家的软件监控，如果在 App 中 h5 还是采集到数据就传输给服务端，很有可能会让流量管家检测到，给用户报警，从而使得用户不再信任你的 App , 所以我们在用户操作的时候将数据传给 app 端，存储到 app。用户切换应用到后台的时候，通过 app 端的 SDK 打包传输到服务器，我们给 app 提供的方法封装了一个适配器</p>
<pre>

    // app 与 h5 混合应用，直接将数信息发给 app
    collect.saveEvent = function (jsonString) {

        collect.dcpDeviceType && setTimeout(function () {
            if(collect.dcpDeviceType=='android'){
                android.saveEvent(jsonString)
            } else {
                window.webkit && window.webkit.messageHandlers ? window.webkit.messageHandlers.nativeBridge.postMessage(jsonString) : window.postBridgeMessage(jsonString)
            }

        },1000)
        }

</pre>

<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><blockquote>
<p>通过上面几个问题的思考，我们对埋点的实现大致已经有了一些想法，我们使用思维导图来还原下我们即将要做的事情，图片记得放大看哦，太小了可能看不清。</p>
</blockquote>
<ol>
<li>我们需要暴露给业务方调用的方法<br><img src="/images/sdk/method.jpeg" alt="nginx作用域"></li>
<li>我们需要处理的事件类型<br><img src="/images/sdk/event.jpeg" alt="nginx作用域"></li>
<li>SDK 的基本实现思路<br><img src="/images/sdk/logic.jpeg" alt="nginx作用域"></li>
</ol>
<h3 id="我们来看下几个核心代码的实现"><a href="#我们来看下几个核心代码的实现" class="headerlink" title="我们来看下几个核心代码的实现"></a>我们来看下几个核心代码的实现</h3><h4 id="工具方法"><a href="#工具方法" class="headerlink" title="工具方法"></a>工具方法</h4><p>我们定义了几个工具方法，提高开发的幸福指数 😝</p>
<pre>

        var helper = {};

        // 生成一个唯一的标识，pageSessionId （用这个变量来关联开始加载、加载完成、离开页面的事件，计算出页面加菜时间，停留时间）
        helper.uuid = function(){}

        // 元素绑定事件监听，兼容浏览器到IE8
        helper.on = function(){}

        //元素移除事件监听的适配器函数，兼容浏览器到IE8
        helper.remove = function(){}

        //将json转为字符串,事件传输的参数类型转化
        helper.changeJSON2Query = function(){}

        //将相对路径解析成文档全路径
        helper.normalize = function(){}
</pre>

<h4 id="采集逻辑"><a href="#采集逻辑" class="headerlink" title="采集逻辑"></a>采集逻辑</h4><pre>

        var collect = {
            deviceUrl:'http://collect.trc.com/rest/collect/device/h5/v1',
            eventUrl:'http://collect.trc.com/rest/collect/event/h5/v1',
            isuploadUrl:'http://collect.trc.com/rest/collect/isupload/app/v1',
            parmas:{ ExtraInfo:{} },
            device:{}
        };

        //获取埋点配置
        collect.setParames = function(){}

        //更新访问路径及页面信息
        collect.updatePageInfo = function(){}

        //获取事件参数
        collect.getParames = function(){}

        //获取设备信息
        collect.getDevice = function(){}

        //事件采集
        collect.send = function(){}

        //设备采集
        collect.sendDevice = function(){}

        //判断才否采集，埋点采集的开关
        collect.isupload = function(){

            1. 判断是否采集，不采集就注销事件监听（项目中区分游客身份和用户身份的采集情况，这个方法会被判断两次）
            2. 采集则判断是否已经采集过
                a.已经采集过不做任何操作
                b.没有采集过添加事件监听
            3. 判断是 混合应用还是纯 web 应用
                a.如果是web 应用，调用 collect.setIframe 设置 iframe
                b.如果是混合应用 将开始加载和加载完成事件传输给 app
        }

        //点击事件处理函数
        collect.clickHandler = function(){}

        //离开页面的事件处理函数
        collect.beforeUnloadHandler = function(){}

        //页面回退事件处理函数
        collect.onPopStateHandler = function(){}

        //系统事件初始化，注册离开事件，浏览器后退事件
        collect.event = function(){}

        //获取记录开始加载数据信息
        collect.getBeforeload = function(){}

        //存储加载完成，获取设备类型，记录加载完成信息
        collect.onload = function(){

            1. 判断cookie是否有存设备类型信息，有表示混合应用
            2. 采集加载完成时间等信息
            3. 调用 collect.isupload 判断是否进行采集
        }

        //web 应用，通过嵌入 iframe 进行跨域 cookie 通讯，设置设备id
        collect.setIframe = function(){}

        //app 与 h5 混合应用，直接将数信息发给 app,判断设备类型做原生方法适配器
        collect.saveEvent = function(){}

        //采集自定义事件类型
        collect.dispatch = function(){}

        //将参数 userId 存入sessionStorage
        collect.storeUserId = function(){}

        //采集H5信息,如果是混合应用，将采集到的信息发送给 app 端
        collect.saveEventInfo = function(){}

        //页面初始化调用方法
        collect.init = function(){

            1. 获取开始加载的采集信息
            2. 获取 SDK 配置信息，设备信息
            3. 改写 history 两个方法，单页面应用页面跳转前调用我们自己的方法
            4. 页面加载完成，调用 collect.onload 方法

        }


        collect.init(); // 初始化

        //暴露给业务方调用的方法
        return {
            dispatch:collect.dispatch,
            storeUserId:collect.storeUserId,
        }
</pre>


<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><blockquote>
<p>代码的篇幅比较长，就不放在博客里了，感兴趣的同学可以在 <a href="https://github.com/bailinlin/web-sdk" target="_blank" rel="external">github</a> 上看完整的项目。如果你有什么不懂的或者想和我交流的，欢迎在文章下面留言联系我</p>
</blockquote>
<p><a href="https://bailinlin.github.io/2018/03/05/cookie-share/" target="_blank" rel="external">web 浏览器指纹跨域共享</a><br><a href="https://bailinlin.github.io/2018/04/28/history/" target="_blank" rel="external">你需要知道的单页面路由实现原理</a></p>
<p><a href="https://www.zhihu.com/question/36411025" target="_blank" rel="external">数据埋点是什么？设置埋点的意义是什么？</a><br><a href="https://sensorsdata.cn/blog/shu-ju-jie-ru-yu-mai-dian/" target="_blank" rel="external">数据采集与埋点</a><br><a href="https://tech.meituan.com/mt-mobile-analytics-practice.html" target="_blank" rel="external">美团点评前端无痕埋点实践</a><br><a href="https://www.zhihu.com/question/20448467" target="_blank" rel="external">如何清楚易懂的解释“UV和PV＂的定义</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2018/05/07/vue-cli-webpack/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/05/07/vue-cli-webpack/" itemprop="url">
                  vue-cli#4.7项目结构分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-07T14:11:04+08:00">
                2018-05-07
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2018/05/07/vue-cli-webpack/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/05/07/vue-cli-webpack/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>使用过 vue 进行项目开发的同学，一定知道或者使用过 vue-cli 脚手架，他能够很好的搭建项目结构和工程，让我们能够把足够的精力放在业务开发上。也正是因为这样，很多时候我们会因为项目工期短等原因来不及或则不会刻意去了解项目工程配置，我们今天不去介绍脚手架的使用，我们去了解下脚手架为我们创建好的打包工程是怎么做的。</p>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p><code></code></p>
<pre><code>├── build --------------------------------- webpack相关配置文件
│   ├── build.js --------------------------webpack打包配置文件
│   ├── check-versions.js ------------------------------ 检查npm,nodejs版本
│   ├── logo.png ---------------------------------- 项目 logo
│   ├── utils.js --------------------------------------- 配置资源路径，配置css加载器
│   ├── vue-loader.conf.js ----------------------------- 配置css加载器等
│   ├── webpack.base.conf.js --------------------------- webpack基本配置
│   ├── webpack.dev.conf.js ---------------------------- 用于开发的webpack设置
│   ├── webpack.prod.conf.js --------------------------- 用于打包的webpack设置
├── config ---------------------------------- 配置文件
       ├── index.js ------------------------------ 开发和生产环境配置文件
├── node_modules ---------------------------- 存放依赖的目录
├── src ------------------------------------- 源码
│   ├── assets ------------------------------ 静态文件
│   ├── components -------------------------- 组件
│   ├── main.js ----------------------------- 主js
│   ├── App.vue ----------------------------- 项目入口组件
│   ├── router ------------------------------ 路由
├── package.json ---------------------------- node配置文件
├── .babelrc--------------------------------- babel配置文件
├── .editorconfig---------------------------- 编辑器配置
├── .gitignore------------------------------- 配置git可忽略的文件
</code></pre><p></p>
<h3 id="webpack配置划重点"><a href="#webpack配置划重点" class="headerlink" title="webpack配置划重点"></a>webpack配置划重点</h3><blockquote>
<p>在看项目配置文件之前，我们先了解下 webpack 几个常用的工具和插件，如果你已经十分熟悉，你可以跳过这一小节，直接去看，配置文件解析</p>
</blockquote>
<h4 id="1-path模块"><a href="#1-path模块" class="headerlink" title="1. path模块"></a>1. path模块</h4><p>path 是 node.js 中的一个模块，用于处理目录的对象，提高开发效</p>
<pre>

    常用方法：
    path.join(): 用于连接路径。该方法的主要用途在于，会正确使用当前系统的路径分隔符，Unix 系统是 ”/“，Windows系统是 ”\“
    path.resolve() 用于将相对路径转为绝对路径

    常使用的文件路径
    __dirname: 总是返回被执行的 js 所在文件夹的绝对路径
    __filename: 总是返回被执行的 js 的绝对路径
    process.cwd(): 总是返回运行 node 命令时所在的文件夹的绝对路径

</pre>

<h4 id="2-process"><a href="#2-process" class="headerlink" title="2.process"></a>2.process</h4><p>process对象是Node的一个全局对象，提供当前Node进程的信息。</p>
<pre>

    process 对象提供一系列属性，用于返回系统信息
    process.argv：返回当前进程的命令行参数数组。
    process.env：返回一个对象，成员为当前Shell的环境变量，比如process.env.HOME
    process.pid：当前进程的进程号

</pre>

<h4 id="3-Source-map"><a href="#3-Source-map" class="headerlink" title="3.Source map"></a>3.Source map</h4><p>简单说，<a href="http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html" target="_blank" rel="external">Source map</a>就是一个信息文件，里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。有了它，出错的时候，debug 工具将直接显示原始代码，而不是转换后的代码。这无疑给开发者带来了很大方便。<a href="https://juejin.im/post/58293502a0bb9f005767ba2f" target="_blank" rel="external">webpack 的 devtool里有 7种 SourceMap 模式</a></p>
<table>
<thead>
<tr>
<th>模式</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>eval</td>
<td>每个 module 会封装到 eval 里包裹起来执行，并且会在末尾追加注释 //@ sourceURL</td>
</tr>
<tr>
<td>source-map</td>
<td>生成一个 SourceMap 文件.</td>
</tr>
<tr>
<td>hidden-source-map</td>
<td>和 source-map 一样，但不会在 bundle 末尾追加注释.</td>
</tr>
<tr>
<td>inline-source-map</td>
<td>生成一个 DataUrl 形式的 SourceMap 文件.</td>
</tr>
<tr>
<td>eval-source-map</td>
<td>每个 module 会通过 eval() 来执行，并且生成一个 DataUrl 形式的 SourceMap .</td>
</tr>
<tr>
<td>cheap-source-map</td>
<td>生成一个没有列信息（column-mappings）的 SourceMaps 文件，不包含 loader 的 sourcemap（譬如 babel 的 sourcemap）</td>
</tr>
<tr>
<td>cheap-module-source-map</td>
<td>生成一个没有列信息（column-mappings）的 SourceMaps 文件，同时 loader 的 sourcemap 也被简化为只包含对应行的。</td>
</tr>
</tbody>
</table>
<h4 id="4-webpack-merge"><a href="#4-webpack-merge" class="headerlink" title="4. webpack-merge"></a>4. webpack-merge</h4><p>开发环境(development)和生产环境(production)的构建目标差异很大。在开发环境中，我们需要具有强大的、具有实时重新加载(live reloading)或热模块替换(hot module replacement)能力的 source map 和 localhost server。而在生产环境中，我们的目标则转向于关注更小的 bundle，更轻量的 source map，以及更优化的资源，以改善加载时间。由于要遵循逻辑分离，我们通常建议为每个环境编写彼此独立的 webpack 配置。通用的配置部分，我们抽象出一个公共文件，通过 <a href="https://doc.webpack-china.org/guides/production/" target="_blank" rel="external">webpack-merge</a> 工具的“通用”配置，我们不必在环境特定的配置中重复代码。</p>
<h4 id="5-ExtractTextWebpackPlugin"><a href="#5-ExtractTextWebpackPlugin" class="headerlink" title="5. ExtractTextWebpackPlugin"></a>5. ExtractTextWebpackPlugin</h4><p><a href="https://doc.webpack-china.org/plugins/extract-text-webpack-plugin/" target="_blank" rel="external">ExtractTextWebpackPlugin</a> 插件通常用来做样式文件的分离，被分离的文件不会被内嵌到  JS bundle 中，而会被放到一个单独的文件中，在样式文件比较大的时候，能够提前样式的加载,配置示例如下</p>
<pre>

    const ExtractTextPlugin = require("extract-text-webpack-plugin");
    module.exports = {
       module: {
          rules: [
          {
             test: /\.css$/,
             use: ExtractTextPlugin.extract({
             fallback: "style-loader",
             use: "css-loader"
          })
       }]
    },
        plugins: [
            new ExtractTextPlugin("styles.css"),
        ]
    }

</pre>

<p>它会将所有的入口 chunk(entry chunks)中引用的 *.css，移动到独立分离的 CSS 文件。因此，你的样式将不再内嵌到 JS bundle 中，而是会放到一个单独的 CSS 文件（即 styles.css）当中。 如果你的样式文件大小较大，这会做更快提前加载，因为 CSS bundle 会跟 JS bundle 并行加载。</p>
<h4 id="6-html-webpack-plugin"><a href="#6-html-webpack-plugin" class="headerlink" title="6.html-webpack-plugin"></a>6.html-webpack-plugin</h4><p>如果你有多个 webpack 入口点， 他们都会在生成的HTML文件中的 script 标签内。如果你有任何 CSS assets 在 webpack 的输出中（例如， 利用ExtractTextPlugin提取CSS）， 那么这些将被包含在HTML head中的<link>标签内。通常在开发中，我们为了避免 CDN 和浏览器的缓存通常会个输出文件 bundle.js 加上一个hash 值例如 <code>[hash].bundle.js</code>，使用 <a href="https://doc.webpack-china.org/plugins/html-webpack-plugin/" target="_blank" rel="external">html-webpack-plugin</a> 能够在创建新的 html 文件的时候将我们把带有哈希值的 bundle.js 引用到 html 文件.</p>
<h4 id="7-optimize-css-assets-webpack-plugin"><a href="#7-optimize-css-assets-webpack-plugin" class="headerlink" title="7.optimize-css-assets-webpack-plugin"></a>7.optimize-css-assets-webpack-plugin</h4><p>用来优化从脚本里提炼出来的 css ，配置示例如下</p>
<pre>

    var OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin');
    module.exports = {
      module: {
        rules: [
          {
            test: /\.css$/,
            loader: ExtractTextPlugin.extract('style-loader', 'css-loader')
          }
        ]
      },
      plugins: [
        new ExtractTextPlugin('styles.css'),
        new OptimizeCssAssetsPlugin({
          assetNameRegExp: /\.optimize\.css$/g,
          cssProcessor: require('cssnano'),
          cssProcessorOptions: { discardComments: { removeAll: true } },
          canPrint: true
        })
      ]
    };
</pre>

<h4 id="8-CopyWebpackPlugin"><a href="#8-CopyWebpackPlugin" class="headerlink" title="8.CopyWebpackPlugin"></a>8.CopyWebpackPlugin</h4><p><a href="https://doc.webpack-china.org/plugins/copy-webpack-plugin/" target="_blank" rel="external">CopyWebpackPlugin</a>从插件名称上我们不难看出他的作用，通常用来拷贝资源，对项目文件进行归类整合</p>
<h4 id="9-friendly-errors-webpack-plugin"><a href="#9-friendly-errors-webpack-plugin" class="headerlink" title="9.friendly-errors-webpack-plugin"></a>9.friendly-errors-webpack-plugin</h4><p><a href="https://www.npmjs.com/package/friendly-errors-webpack-plugin" target="_blank" rel="external">friendly-errors-webpack-plugin</a>能够更好在终端看到webapck运行的警告和错误，提高开发体验</p>
<h4 id="10-UglifyjsWebpackPlugin"><a href="#10-UglifyjsWebpackPlugin" class="headerlink" title="10.UglifyjsWebpackPlugin"></a>10.UglifyjsWebpackPlugin</h4><p><a href="https://doc.webpack-china.org/plugins/uglifyjs-webpack-plugin/" target="_blank" rel="external">UglifyjsWebpackPlugin</a>用来压缩 js 代码</p>
<h4 id="11-开发中-Server-DevServer"><a href="#11-开发中-Server-DevServer" class="headerlink" title="11.开发中 Server(DevServer)"></a>11.开发中 Server(DevServer)</h4><p>webpack 项目服务，我们通常会在开发阶段用来配置项目的热刷新，服务压缩，项目代理等，常用的几个配置参数介绍如下</p>
<pre>

    const config = require('../config')

    // config 文件里做了用户自定的服务参数配置

    devServer: {
        clientLogLevel: 'warning',  // 在开发攻击的控制台中显示信息，便于开发调试，你可以将参数配置成 "none" 来进行关闭
         historyApiFallback: { // 当使用 HTML5 History API 时，任意的 404 响应都可能需要被替代为 index.html
            rewrites: [
               { from: /.*/, to: path.posix.join(config.dev.assetsPublicPath, 'index.html') },
            ],
         },
         hot: true,   //启用项目的热刷新，即模块热替换特性
         contentBase: false,   // 告诉服务器从哪里提供内容。只有在你想要提供静态文件时才需要。这里禁用，因为配置了 CopyWebpackPlugin 的使用
         compress: true,
         host: HOST || config.dev.host,   //指定使用一个域名。默认是 localhost
         port: PORT || config.dev.port,   //指定要监听请求的端口号：
         open: config.dev.autoOpenBrowser, //open 参数配置，如果配置成 true ，项目启动后会自动打开浏览器
         overlay: config.dev.errorOverlay   //当有错误或则警告的时候在页面上显示一个全屏的遮罩提示
             ? { warnings: false, errors: true }
             : false,
         publicPath: config.dev.assetsPublicPath, //此路径下的打包文件可在浏览器中访问
         proxy: config.dev.proxyTable,           //代理API的请求
         quiet: true,       //启用 quiet 后，除了初始启动信息之外的任何内容都不会被打印到控制台,特别是使用了 FriendlyErrorsPlugin 插件的时候
         watchOptions: {   //与监视文件相关的控制选项。是否使用轮询
               poll: config.dev.poll,
         }
    },

</pre>


<h3 id="配置文件解析"><a href="#配置文件解析" class="headerlink" title="配置文件解析"></a>配置文件解析</h3><blockquote>
<p>通过了解了上面的配置，我们应该对 webpack 的常用插件和工具有了一定了解，我们来看下 vue-cli 脚手架给我们生成的配置情况</p>
</blockquote>
<h4 id="config-js"><a href="#config-js" class="headerlink" title="config.js"></a>config.js</h4><pre>

'use strict'

const path = require('path') // 引用项目的 path 模块

module.exports = {
  dev: {

    // 路径配置
    assetsSubDirectory: 'static',
    assetsPublicPath: '/',
    proxyTable: {},

    // 各种开发服务配置
    host: 'localhost', // 开发环境域名 可以被 node 全局变量process.env.HOST 重写
    port: 8080, //配置开发服务端口，可以被 node 全局变量 process.env.PORT 重写, 需要使用未被占用的端口
    autoOpenBrowser: false, //服务启动是否自动代开浏览器
    errorOverlay: true,   //是否在发生错误的时候，在页面整屏增加一个错误遮罩
    notifyOnErrors: true,  //是否通知错误 ，在我们的项目配置中和 friendly-errors-webpack-plugin 结合使用
    poll: false, // 服务监听是否轮询操作

    // 配饰是否使用 Eslint Loader 进行语法检测
    // 如果使用，在开发构建阶段，会对你的代码会进行检测
    // 检测出来的警告和错误会白展示在开发工具的控制台

    useEslint: true,  //进行语法检测

    // 配置是否将 eslint 语法检测的警告和错误展示在页面整屏的遮罩上

    showEslintErrorsInOverlay: false,  // 语法检测的警告和错误不展示在遮罩上

    /**
     * Source Maps
     */

    // https://webpack.js.org/configuration/devtool/#development
    // 在上面的介绍中，我们知道 source map 是用来将我们构建后被转化的代码对应构建前的代码，便于 debug
    // cheap-module-eval-source-map 和我们介绍的 cheap-module-source-map 很类似，但是 SourceMap 会被作为数据添加到包中
    devtool: 'cheap-module-eval-source-map',

    // 如果你的开发工具不能进行 vue-files 的 debug ，可以将以下设置设置成 false

    cacheBusting: true,

    cssSourceMap: true
  },

  build: {
    // index.html 文件模板
    index: path.resolve(__dirname, '../dist/index.html'),

    // 打包路径配置
    assetsRoot: path.resolve(__dirname, '../dist'),
    assetsSubDirectory: 'static',
    assetsPublicPath: '/',

    /**
     * Source Maps
     */

    //生产环境 source map 配置

    productionSourceMap: true,
    devtool: '#source-map',

    // 因为很多的主流服务都会 通过 gzip 压缩过你的所有静态资源，我们的配置默认不开启 gzip
    // 如果要设置成开启,请先确保已经安装好 compression-webpack-plugin 插件
    productionGzip: false,
    productionGzipExtensions: ['js', 'css'],

    // 启动 build 命令的时候，额外添加一个参数，打包后会自动生成一个分析报告文件，例如 npm run build --report ，可以通过配置 true ，false 来关闭
    bundleAnalyzerReport: process.env.npm_config_report
  }
}

</pre>

<h4 id="check-versions-js"><a href="#check-versions-js" class="headerlink" title="check-versions.js"></a>check-versions.js</h4><p>这个文件主要是用来检测当前环境中的node和npm版本和我们需要的是否一致的。</p>
<pre>

    'use strict'
    const chalk = require('chalk')  // 改变命令行中的字体颜色，大致这样用chalk.blue('Hello world')
    const semver = require('semver')  //是用来对特定的版本号做判断的

    const packageConfig = require('../package.json')  // 项目 npm 配置文件，获取依赖及版本信息，requrie返回的就是json对象
    const shell = require('shelljs') //用来执行Unix系统命令，调用系统命令更加方便

    //把cmd这个参数传递的值转化成前后没有空格的字符串，也就是版本号
    function exec (cmd) {
      return require('child_process').execSync(cmd).toString().trim()
    }


    const versionRequirements = [
      {
        name: 'node',
        currentVersion: semver.clean(process.version),  // 提取进程版本信息转化成规定格式，也就是 '  =v1.2.3  ' -> '1.2.3' 这种功能
        versionRequirement: packageConfig.engines.node // package.json 的 node 的版本信息
      }
    ]

    if (shell.which('npm')) {
      versionRequirements.push({
        name: 'npm',
        currentVersion: exec('npm --version'),   //当前的版本信息
        versionRequirement: packageConfig.engines.npm //package.json 的 node 的版本信息
      })
    }

    module.exports = function () {
      const warnings = []

      for (let i = 0; i < versionRequirements.length; i++) {
        const mod = versionRequirements[i]

        // 如果当前版本号不符合 package.json 要求的版本号，红色表示当前版本信息，绿色表示要求的版本信息，添加到 warnings 待输出
        if (!semver.satisfies(mod.currentVersion, mod.versionRequirement)) {
          warnings.push(mod.name + ': ' +
            chalk.red(mod.currentVersion) + ' should be ' +
            chalk.green(mod.versionRequirement)
          )
        }
      }

      //输出版本号不相符的提示 warnings
      if (warnings.length) {
        console.log('')
        console.log(chalk.yellow('To use this template, you must update following to modules:'))
        console.log()

        for (let i = 0; i < warnings.length; i++) {
          const warning = warnings[i]
          console.log('  ' + warning)
        }

        console.log()
        process.exit(1)
      }
    }


</pre>

<h4 id="build-js"><a href="#build-js" class="headerlink" title="build.js"></a>build.js</h4><pre>

    'use strict'

    //打包前判断当先开发环境的 node 和 npm 版本和 package.json 要求的时候一样
    require('./check-versions')()

    process.env.NODE_ENV = 'production'

    const ora = require('ora')  // 在用户打包的时候能够让用户知道正在进行，一个加载中的样式，转啊转
    const rm = require('rimraf') //这个模块是用来清除之前的打的包，因为在vue-cli中每次打包会生成不同的hash
    const path = require('path') //node 路径模块，便于我们操作文件路径
    const chalk = require('chalk') //带颜色的输出模块，能在控制台中输出不同的样色
    const webpack = require('webpack') //webpack 不解释
    const config = require('../config') // 项目中的配置文件，👆上面已经进行了配置介绍
    const webpackConfig = require('./webpack.prod.conf') // 生产环境的配置文件


    const spinner = ora('building for production...')// 实例一个打包加载中实例
    spinner.start() //开始转圈，营造一个正在打包的场景

    // 删除上一次打包的文件，删除成功，开始按照生产环境配置进行打包
    rm(path.join(config.build.assetsRoot, config.build.assetsSubDirectory), err => {
      if (err) throw err


        //开始打包，打包结束停止 spinner 转圈，有报错则在控制台输出
      webpack(webpackConfig, (err, stats) => {
        spinner.stop()
        if (err) throw err

        // node 环境里的输出配置，process.stdout.write 你可以理解成 js 里的 console
        process.stdout.write(stats.toString({
          colors: true, //让打包的时候有颜色。
          modules: false,  //去掉内置模块信息
          children: false, // 去掉子模块,如果你使用了 ts-loader，设置成 true 会在打包构建阶段展示错误信息
          chunks: false, // 增加包信息（设置为 false 能允许较少的冗长输出）
          chunkModules: false //去除包里内置模块的信息
        }) + '\n\n')


         //打包出错在控制台输出 Build failed with errors ，退出打包程序
        if (stats.hasErrors()) {
          console.log(chalk.red('  Build failed with errors.\n'))
          process.exit(1)
        }

        //打包成功则输出 Build complete 结束打包
        console.log(chalk.cyan('  Build complete.\n'))
        console.log(chalk.yellow(
          '  Tip: built files are meant to be served over an HTTP server.\n' +
          '  Opening index.html over file:// won\'t work.\n'
        ))
      })
    })
</pre>

<h4 id="webpack-base-conf-js"><a href="#webpack-base-conf-js" class="headerlink" title="webpack.base.conf.js"></a>webpack.base.conf.js</h4><pre>

    'use strict'
    const path = require('path')  // node 路径模块
    const utils = require('./utils') //node 内部常用的工具类，其中包括：格式化字符串、对象的序列化、实现对象继承等常用方法
    const config = require('../config') //👆上面我们介绍的，项目配置文件
    const vueLoaderConfig = require('./vue-loader.conf') //👆 上面我们介绍的 vue 加载器配置文件

    //返回当前配置文件位置是 build ，该方法放回 build/../dir 的相对路基
    function resolve (dir) {
      return path.join(__dirname, '..', dir)
    }

    // eslint 语法检测配置
    const createLintingRule = () => ({
      test: /\.(js|vue)$/,
      loader: 'eslint-loader',
      enforce: 'pre',
      include: [resolve('src'), resolve('test')],
      options: {
        formatter: require('eslint-friendly-formatter'),
        emitWarning: !config.dev.showEslintErrorsInOverlay
      }
    })

    // webpack 通用配置内容
    module.exports = {
      context: path.resolve(__dirname, '../'),  // 上下文，基础目录，用于从配置中解析入口起点和 loader
      entry: {
        app: './src/main.js'  //起点或是应用程序的起点入口。从这个起点开始，应用程序启动执行。如果传递一个数组，那么数组的每一项都会执行。
      },
      output: {
        path: config.build.assetsRoot,   //输出 bundle 的路径
        filename: '[name].js',          //输出 bundle 的名称
        publicPath: process.env.NODE_ENV === 'production' // 指定资源文件引用的目录，例如图片
          ? config.build.assetsPublicPath
          : config.dev.assetsPublicPath
      },
      resolve: {
        extensions: ['.js', '.vue', '.json'], //配置模块如何解析,
        alias: {                              // 创建应用的别名，
          'vue$': 'vue/dist/vue.esm.js',
          '@': resolve('src'),
        }
      },
  module: {
    rules: [
      //判断配置中是否要是用 eslint 语法检测，如果使用，就将 createLintingRule 配置对象返回
      ...(config.dev.useEslint ? [createLintingRule()] : []),

     //👇是一些比较常用的加载器，及配置，不做详细介绍了
      {
        test: /\.vue$/,
        loader: 'vue-loader',
        options: vueLoaderConfig
      },
      {
        test: /\.js$/,
        loader: 'babel-loader',
        include: [resolve('src'), resolve('test'), resolve('node_modules/webpack-dev-server/client')]
      },
      {
        test: /\.(css | scss)$/,
        loader: 'style-loader!css-loader!!sass-loader'
      },
      {
        test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,
        loader: 'url-loader',
        options: {
          limit: 10000,
          name: utils.assetsPath('img/[name].[hash:7].[ext]')
        }
      },
      {
        test: /\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/,
        loader: 'url-loader',
        options: {
          limit: 10000,
          name: utils.assetsPath('media/[name].[hash:7].[ext]')
        }
      },
      {
        test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/,
        loader: 'url-loader',
        options: {
          limit: 10000,
          name: utils.assetsPath('fonts/[name].[hash:7].[ext]')
        }
      }
    ]
  },
  node: {

    //防止因为 vue 资源本身就自带的 无用的 node 注入，浏览器兼容处理
    setImmediate: false,
    dgram: 'empty',
    fs: 'empty',
    net: 'empty',
    tls: 'empty',
    child_process: 'empty'
  }
}

</pre>


<h4 id="webpack-dev-conf-js"><a href="#webpack-dev-conf-js" class="headerlink" title="webpack.dev.conf.js"></a>webpack.dev.conf.js</h4><pre>

    'use strict'
    const utils = require('./utils')  //node 工具模块
    const webpack = require('webpack') //webpack 不解释
    const config = require('../config')//👆提到的配置文件
    const merge = require('webpack-merge') // merge 工具，用来合并生产和开发环境通用的基础 webpack 配置
    const path = require('path')            //node 的路径模块
    const baseWebpackConfig = require('./webpack.base.conf') //生产和开发环境通用的基础 webpack 配置
    const CopyWebpackPlugin = require('copy-webpack-plugin') //拷贝插件
    const HtmlWebpackPlugin = require('html-webpack-plugin')  //动态生成 html 插件
    const FriendlyErrorsPlugin = require('friendly-errors-webpack-plugin') //友好的错误输出插件
    const portfinder = require('portfinder') //能够获取一个可用的随机端口号

    const HOST = process.env.HOST   //node 全局环境变量的主机
    const PORT = process.env.PORT && Number(process.env.PORT)   //node 全局环境变量的端口

    //合并基础配置加载器的配置部分
    const devWebpackConfig = merge(baseWebpackConfig, {

      module: {
        // 为 .vue 文件意外的独立样式文件配置加载器
        rules: utils.styleLoaders({ sourceMap: config.dev.cssSourceMap, usePostCSS: true })
      },

      // cheap-module-eval-source-map 在开发环境中很快
      devtool: config.dev.devtool,

      // 开发服务配置，👆 已经细讲过，顺便回顾一下
      devServer: {
         clientLogLevel: 'warning',  // 在开发攻击的控制台中显示信息，便于开发调试，你可以将参数配置成 "none" 来进行关闭
         historyApiFallback: { // 当使用 HTML5 History API 时，任意的 404 响应都可能需要被替代为 index.html
            rewrites: [
               { from: /.*/, to: path.posix.join(config.dev.assetsPublicPath, 'index.html') },
            ],
         },
         hot: true,   //启用项目的热刷新，即模块热替换特性
         contentBase: false,   // 告诉服务器从哪里提供内容。只有在你想要提供静态文件时才需要。这里禁用，因为配置了 CopyWebpackPlugin 的使用
         compress: true,
         host: HOST || config.dev.host,   //指定使用一个域名。默认是 localhost
         port: PORT || config.dev.port,   //指定要监听请求的端口号：
         open: config.dev.autoOpenBrowser, //open 参数配置，如果配置成 true ，项目启动后会自动打开浏览器
         overlay: config.dev.errorOverlay   //当有错误或则警告的时候在页面上显示一个全屏的遮罩提示
               ? { warnings: false, errors: true }
               : false,
         publicPath: config.dev.assetsPublicPath, //此路径下的打包文件可在浏览器中访问
         proxy: config.dev.proxyTable,           //代理API的请求
         quiet: true,       //启用 quiet 后，除了初始启动信息之外的任何内容都不会被打印到控制台,特别是使用了 FriendlyErrorsPlugin 插件的时候
         watchOptions: {   //与监视文件相关的控制选项。是否使用轮询
               poll: config.dev.poll,
         }
       },

      plugins: [
        // DefinePlugin 允许创建一个在编译时可以配置的全局常量。这可能会对开发模式和发布模式的构建允许不同的行为非常有用
        new webpack.DefinePlugin({
          'process.env': require('../config/dev.env')
        }),
        new webpack.HotModuleReplacementPlugin(), //启用热替换模块(Hot Module Replacement)，也被称为 HMR
        new webpack.NamedModulesPlugin(), // 当开启 HMR 的时候使用该插件会显示模块的相对路径，建议用于开发环境
        new webpack.NoEmitOnErrorsPlugin(), 在编译出现错误时，使用 NoEmitOnErrorsPlugin 来跳过输出阶段

        //HtmlWebpackPlugin简化了HTML文件的创建，以便为你的webpack包提供服务。这对于在文件名中包含每次会随着编译而发生变化哈希的 webpack bundle 尤其有用
        new HtmlWebpackPlugin({
          filename: 'index.html',
          template: 'index.html',
          inject: true
        }),


        // 拷贝自定义的静态资源文件
        new CopyWebpackPlugin([
          {
            from: path.resolve(__dirname, '../static'),
            to: config.dev.assetsSubDirectory,
            ignore: ['.*']
          }
        ])
      ]
    })

    // 实例一个异步对象，执行 devWebpackConfig 配置编译
    module.exports = new Promise((resolve, reject) => {
      portfinder.basePort = process.env.PORT || config.dev.port  //设置基础端口
      portfinder.getPort((err, port) => {获取端口，输出构建新
        if (err) {
          reject(err)
        } else {
          // 如果进行 e2e 测试，需要发布新端口
          process.env.PORT = port

          // 更新 devServer 的端口
          devWebpackConfig.devServer.port = port

          devWebpackConfig.plugins.push(new FriendlyErrorsPlugin({
            compilationSuccessInfo: {
              messages: [`Your application is running here: http://${devWebpackConfig.devServer.host}:${port}`],
            },
            onErrors: config.dev.notifyOnErrors
            ? utils.createNotifierCallback()
            : undefined
          }))

           //执行打包配置文件
          resolve(devWebpackConfig)
        }
      })
    })

</pre>

<h4 id="webpack-prod-conf-js"><a href="#webpack-prod-conf-js" class="headerlink" title="webpack.prod.conf.js"></a>webpack.prod.conf.js</h4><pre>

    'use strict'
    const path = require('path') // node 路径模块
    const utils = require('./utils') //小工具函数
    const webpack = require('webpack') // webpack 不解释
    const config = require('../config')//👆提到的配置文件
    const merge = require('webpack-merge') // merge 工具，用来合并生产和开发环境通用的基础 webpack 配置
    const baseWebpackConfig = require('./webpack.base.conf')//产和开发环境通用的基础 webpack 配置
    const CopyWebpackPlugin = require('copy-webpack-plugin') //拷贝插件
    const HtmlWebpackPlugin = require('html-webpack-plugin')  //动态生成 html 插件
    const ExtractTextPlugin = require('extract-text-webpack-plugin')//用来做文件分离的插件
    const OptimizeCSSPlugin = require('optimize-css-assets-webpack-plugin')//优化提炼出来的css
    const UglifyJsPlugin = require('uglifyjs-webpack-plugin')// 压缩 js 文件插件

    //生产环境配置
    const env = require('../config/prod.env')

    //合并基础配置加载器的配置部分
    const webpackConfig = merge(baseWebpackConfig, {
    //为独立分离出来的样式配置加载器和source，map
      module: {
        rules: utils.styleLoaders({
          sourceMap: config.build.productionSourceMap,
          extract: true,
          usePostCSS: true
        })
      },
      //配置线上的 source map 便于排查问题
      devtool: config.build.productionSourceMap ? config.build.devtool : false,
      //配置输出，路径，文件名
      output: {
        path: config.build.assetsRoot,
        filename: utils.assetsPath('js/[name].[chunkhash].js'),
        chunkFilename: utils.assetsPath('js/[id].[chunkhash].js')
      },
      plugins: [
        // DefinePlugin 允许创建一个在编译时可以配置的全局常量。这可能会对开发模式和发布模式的构建允许不同的行为非常有用
        new webpack.DefinePlugin({
          'process.env': env
        }),

        // 使用 UglifyJsPlugin 插件对 js 进行压缩
        new UglifyJsPlugin({
          uglifyOptions: {
            compress: {
              warnings: false
            }
          },
          //配置插件的source map
          sourceMap: config.build.productionSourceMap,
          parallel: true
        }),
        // 提取 css 到单独的文件，分离文件异步加载，提高加载速度
        new ExtractTextPlugin({
          filename: utils.assetsPath('css/[name].[contenthash].css'),

          //如果把 allChunks 参数设置陈 false ，就不会把css 从代码块中分离出来
          //代码块加载的时候 css 会被 styles-loader 动态的加载
          allChunks: true,
        }),

        //使用这个插件，从不同的组件中复制脱离出来，进行 css 压缩
        new OptimizeCSSPlugin({
          cssProcessorOptions: config.build.productionSourceMap
            ? { safe: true, map: { inline: false } }
            : { safe: true }
        }),

        //自动生成 html 文件，通常 index.html 文件都会带一个哈希值来清除缓存
        new HtmlWebpackPlugin({
          filename: config.build.index,
          template: 'index.html',
          inject: true,
          minify: {
            removeComments: true,
            collapseWhitespace: true,
            removeAttributeQuotes: true
          },

          chunksSortMode: 'dependency'
        }),
        //该插件会根据模块的相对路径生成一个四位数的hash作为模块id, 渲染模块没有变化的时候，id 不会变。
        new webpack.HashedModuleIdsPlugin(),

        // 提升或者预编译所有模块到一个闭包中，提升你的代码在浏览器中的执行速度。
        new webpack.optimize.ModuleConcatenationPlugin(),

        // 分离渲染的js 到独立的文件中
        new webpack.optimize.CommonsChunkPlugin({
          name: 'vendor',
          minChunks (module) {
            //被引用到的包会从 node_modules 中提取出来
            return (
              module.resource &&
              /\.js$/.test(module.resource) &&
              module.resource.indexOf(
                path.join(__dirname, '../node_modules')
              ) === 0
            )
          }
        }),

        new webpack.optimize.CommonsChunkPlugin({
          name: 'manifest',
          minChunks: Infinity
        }),

        new webpack.optimize.CommonsChunkPlugin({
          name: 'app',
          async: 'vendor-async',
          children: true,
          minChunks: 3
        }),

        // 拷贝自定义的静态资源文件
        new CopyWebpackPlugin([
          {
            from: path.resolve(__dirname, '../static'),
            to: config.build.assetsSubDirectory,
            ignore: ['.*']
          }
        ])
      ]
    })

    //判断如果配置了生产环境压缩，是则使用插件进行压缩
    if (config.build.productionGzip) {
      const CompressionWebpackPlugin = require('compression-webpack-plugin')

      webpackConfig.plugins.push(
        new CompressionWebpackPlugin({
          asset: '[path].gz[query]',
          algorithm: 'gzip',
          test: new RegExp(
            '\\.(' +
            config.build.productionGzipExtensions.join('|') +
            ')$'
          ),
          threshold: 10240,
          minRatio: 0.8
        })
      )
    }

    //是否要生成代码打包分析报告
    if (config.build.bundleAnalyzerReport) {
      const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin
      webpackConfig.plugins.push(new BundleAnalyzerPlugin())
    }

    module.exports = webpackConfig


</pre>


<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>👆这篇文章详细的介绍了脚手架项目的 webpack 配置，但是只是 webpack 的一部分，还有很多内容值得我们去探究，如果你还感兴趣，可以阅读下面这些文章。也欢迎随时与我进行交流，微信号：646321933</p>
<p><a href="https://doc.webpack-china.org/guides/production/" target="_blank" rel="external">webpack指南 </a><br><a href="https://doc.webpack-china.org/concepts/" target="_blank" rel="external">webpack文档</a><br><a href="https://doc.webpack-china.org/configuration
[开发 ](https://doc.webpack-china.org/guides/development/#%E4%BD%BF%E7%94%A8-source-map" target="_blank" rel="external">webpack配置 </a><br><a href="https://juejin.im/post/5a31d210f265da431a43330e" target="_blank" rel="external">自己动手实现一个脚手架</a><br><a href="https://doc.webpack-china.org/plugins" target="_blank" rel="external">webpack 官方插件集合介绍文档 </a><br><a href="https://segmentfault.com/a/1190000007441374" target="_blank" rel="external">《 使用vue-cli脚手架创建新项目》</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2018/04/28/history/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/28/history/" itemprop="url">
                  你需要知道的单页面路由实现原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-28T09:43:21+08:00">
                2018-04-28
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2018/04/28/history/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/04/28/history/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近开发的埋点项目，需要记录用户行为轨迹即用户页面访问顺序。需要在页面跳转的时候，记录用户访问的信息（比如 url ，请求头部等），非单页面应用可以给 window 对象加上一个 beforeunload 事件，在页面离开时触发采集开关，但是现在很多业务是单页面应用，用户切换地址的时候，是无刷新的局部更新，没有办法触发 beforeunload。所以单页面应用的路由插件一定运用了 window 自带的无刷新修改用户浏览记录的方法，pushState 和 replaceState。</p>
<h3 id="pushState-和-replaceState-了解一下"><a href="#pushState-和-replaceState-了解一下" class="headerlink" title="pushState 和 replaceState 了解一下"></a>pushState 和 replaceState 了解一下</h3><blockquote>
<p>history 提供了两个方法，能够无刷新的修改用户的浏览记录，pushSate，和 replaceState，区别的 pushState 在用户访问页面后面添加一个访问记录， replaceState 则是直接替换了当前访问记录</p>
</blockquote>
<p>history 对象的详细信息已经有很多很好很详细的介绍文献，这里不再做总结，我们引用阮老师的教程介绍，<a href="http://javascript.ruanyifeng.com/bom/history.html" target="_blank" rel="external">history对象 – JavaScript 标准参考教程（alpha）</a></p>
<h4 id="history-pushState"><a href="#history-pushState" class="headerlink" title="history.pushState"></a>history.pushState</h4><p>history.pushState方法接受三个参数，依次为：</p>
<blockquote>
<p>state：一个与指定网址相关的状态对象，popstate事件触发时，该对象会传入回调函数。如果不需要这个对象，此处可以填null。<br>title：新页面的标题，但是所有浏览器目前都忽略这个值，因此这里可以填null。<br>url：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址。<br>假定当前网址是example.com/1.html，我们使用pushState方法在浏览记录（history对象）中添加一个新记录。</p>
</blockquote>
<pre>
    var stateObj = { foo: 'bar' };
    history.pushState(stateObj, 'page 2', '2.html');
</pre>

<p>添加上面这个新记录后，浏览器地址栏立刻显示 example.com/2.html，但并不会跳转到 2.html，甚至也不会检查2.html 是否存在，它只是成为浏览历史中的最新记录。这时，你在地址栏输入一个新的地址(比如访问 google.com )，然后点击了倒退按钮，页面的 URL 将显示 2.html；你再点击一次倒退按钮，URL 将显示 1.html。</p>
<p>总之，pushState 方法不会触发页面刷新，只是导致 history 对象发生变化，地址栏会有反应。</p>
<p>如果 pushState 的 url参数，设置了一个新的锚点值（即hash），并不会触发 hashchange 事件。如果设置了一个跨域网址，则会报错。</p>
<pre>
    // 报错
    history.pushState(null, null, 'https://twitter.com/hello');

    上面代码中，pushState想要插入一个跨域的网址，导致报错。这样设计的目的是，防止恶意代码让用户以为他们是在另一个网站上。
</pre>

<h4 id="history-replaceState"><a href="#history-replaceState" class="headerlink" title="history.replaceState"></a>history.replaceState</h4><p>history.replaceState 方法的参数与 pushState 方法一模一样，区别是它修改浏览历史中当前纪录,假定当前网页是 example.com/example.html。</p>
<pre>
    history.pushState({page: 1}, 'title 1', '?page=1');
    history.pushState({page: 2}, 'title 2', '?page=2');
    history.replaceState({page: 3}, 'title 3', '?page=3');

    history.back()
    // url显示为http://example.com/example.html?page=1

    history.back()
    // url显示为http://example.com/example.html

    history.go(2)
    // url显示为http://example.com/example.html?page=3

</pre>

<h3 id="单页面应用用户访问轨迹埋点"><a href="#单页面应用用户访问轨迹埋点" class="headerlink" title="单页面应用用户访问轨迹埋点"></a>单页面应用用户访问轨迹埋点</h3><p>开发过单页面应用的同学，一定比较清楚，单页面应用的路由切换是无感知的，不会重新进行 http 请求去获取页面，而是通过改变页面渲染视图来实现。所以他的实现原理一定也是通过原生的 pushState 或则 replaceState 来实现的。所以在页面跳转的时候一定会调用 pushState 或则 replaceState ，要记录用户的跳转信息，我们只要拦截 pushState 和 replaceState，在执行默行为<strong>前</strong>先执行我们的方法就能够采集到用户的跳转信息了</p>
<pre>

    // 改写思路：拷贝 window 默认的 replaceState 函数，重写 history.replaceState 在方法里插入我们的采集行为，在重写的 replaceState 方法最后调用，window 默认的 replaceState 方法

    collect = {}

    collect.onPushStateCallback : function(){}  // 自定义的采集方法

    (function(history){

        var replaceState = history.replaceState;   // 存储原生 replaceState

        history.replaceState = function(state, param) {     // 改写 replaceState
           var url = arguments[2];

           if (typeof collect.onPushStateCallback == "function") {
                 collect.onPushStateCallback({state: state, param: param, url: url});   //自定义的采集行为方法
           }

           return replaceState.apply(history, arguments);    // 调用原生的 replaceState
        };
     })(window.history);


</pre>

<h3 id="vue-router-的路由实现"><a href="#vue-router-的路由实现" class="headerlink" title="vue-router 的路由实现"></a>vue-router 的路由实现</h3><p>既然知道了这个原理，我们来看下 vue-router 的实现，我们打开 <a href="https://github.com/vuejs/vue-router" target="_blank" rel="external">vue-router 项目地址</a>,把项目克隆下来，或则直接在 github 上预览，在 Vue 开发的项目里，我们通过 router.push(‘home’) 来实现页面的跳转，所以我们检索下，push 方法的实现</p>
<p><img src="/images/history/search.jpeg" alt="push方法检索"></p>
<p>我们检索到了 20 个 js 文件，😂，一般到这个时候，我们会放弃源码阅读，那么我们今天的文章就到这结束，谢谢大家！</p>
<p>开个玩笑，源码阅读不能这么粗糙，我们找到 src 目录，点开 <code>index.js</code> 文件，看到 history对象的定义和 mode 参数有关</p>
<pre>
 if (!inBrowser) {
      mode = 'abstract'
    }
    this.mode = mode

    switch (mode) {
      case 'history':
        this.history = new HTML5History(this, options.base)
        break
      case 'hash':
        this.history = new HashHistory(this, options.base, this.fallback)
        break
      case 'abstract':
        this.history = new AbstractHistory(this, options.base)
        break
      default:
        if (process.env.NODE_ENV !== 'production') {
          assert(false, `invalid mode: ${mode}`)
        }
    }
</pre>

<p>看到 history 对象的实例与配置的 mode 有关，vue-router 通过3中方式实现了路由切换。与我们今天讲的内容相匹配的是 <code>HTML5History</code> 的实现方案，其他的将不再文章中做扩展，若果你感兴趣想要了解，可以看文章后面的扩展阅读</p>
<p>我们来看 vue-router 中的 HTML5History 源码：</p>
<pre>
    push (location: RawLocation, onComplete?: Function, onAbort?: Function) {
      const { current: fromRoute } = this
      this.transitionTo(location, route => {
        pushState(cleanPath(this.base + route.fullPath))
        handleScroll(this.router, route, fromRoute, false)
        onComplete && onComplete(route)
      }, onAbort)
    }

    replace (location: RawLocation, onComplete?: Function, onAbort?: Function) {
      const { current: fromRoute } = this
      this.transitionTo(location, route => {
        replaceState(cleanPath(this.base + route.fullPath))
        handleScroll(this.router, route, fromRoute, false)
        onComplete && onComplete(route)
      }, onAbort)
    }

    // src/util/push-state.js
    export function pushState (url?: string, replace?: boolean) {
      saveScrollPosition()
      // try...catch the pushState call to get around Safari
      // DOM Exception 18 where it limits to 100 pushState calls
      const history = window.history
      try {
        if (replace) {
          history.replaceState({ key: _key }, '', url)
        } else {
          _key = genKey()
          history.pushState({ key: _key }, '', url)
        }
      } catch (e) {
        window.location[replace ? 'replace' : 'assign'](url)
      }
    }

    export function replaceState (url?: string) {
      pushState(url, true)
    }
</pre>

<p>在使用 Vue 开发的过程中，我们一定用到过 push 和 replace 来改变路由，和视图。</p>
<p>router 实例调用的 push 实际是 history 的方法，通过 mode 来确定匹配 history 的实现方案，从代码中我们看到，push 调用了 src/util/push-state.js 中被改写过的 pushState 的方法，改写过的方法会根据传入的参数 <code>replace?: boolean</code>来进行判断调用 pushState 还是 replaceState ，同时做了错误捕获，如果，history 无刷新修改访问路径失败，则调用  <code>window.location.replace(url)</code> ,有刷新的切换用户访问地址 ，同理 <code>pushState</code> 也是这样。这里的 transitionTo 方法主要的作用是做视图的跟新及路由跳转监测，如果 url 没有变化（访问地址切换失败的情况），在 transitionTo 方法内部还会调用一个 ensureURL 方法，来修改 url。 transitionTo 方法中应用的父方法比较多，这里不做长篇赘述，具体代码分析可以关注后我以后的文章</p>
<h3 id="模拟单页面路由"><a href="#模拟单页面路由" class="headerlink" title="模拟单页面路由"></a>模拟单页面路由</h3><p>通过上面的学习，我们知道了，单页面应用路由的实现原理，我们也尝试去实现一个。在做管理系统的时候，我们通常会在页面的左侧放置一个固定的导航 sidebar，页面的右侧放与之匹配的内容 main 。点击导航时，我们只希望内容进行更新，如果刷新了整个页面，到时导航和通用的头部底部也进行重绘重排的话，十分浪费资源，体验也会不好。这个时候，我们就能用到我们今天学习到的内容，通过使用 HTML5 的 pushState 方法和 replaceState 方法来实现，</p>
<p>思路：首先绑定 click 事件。当用户点击一个链接时，通过 preventDefault 函数防止默认的行为（页面跳转），同时读取链接的地址（如果有 jQuery，可以写成$(this).attr(‘href’)），把这个地址通过pushState塞入浏览器历史记录中，再利用 AJAX 技术拉取（如果有 jQuery，可以使用$.get方法）这个地址中真正的内容，同时替换当前网页的内容。</p>
<p>为了处理用户前进、后退，我们监听 popstate 事件。当用户点击前进或后退按钮时，浏览器地址自动被转换成相应的地址，同时popstate事件发生。在事件处理函数中，我们根据当前的地址抓取相应的内容，然后利用 AJAX 拉取这个地址的真正内容，呈现，即可。</p>
<p>最后，整个过程是不会改变页面标题的，可以通过直接对 document.title 赋值来更改页面标题。</p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>好了,我们今天通过多个方面来讲了 pushState 方法和 replaceState 的应用，你应该对这个两个方法能有一个比较深刻的印象，如果想要了解更多，你可以参考以下链接</p>
<p><a href="http://javascript.ruanyifeng.com/bom/history.html" target="_blank" rel="external">history对象 – JavaScript 标准参考教程（alpha）</a><br><a href="https://zhuanlan.zhihu.com/p/27588422" target="_blank" rel="external">从vue-router看前端路由的两种实现</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2018/04/02/javascript-notes/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/02/javascript-notes/" itemprop="url">
                  你需要知道的 javascript 的细节
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-02T17:27:29+08:00">
                2018-04-02
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2018/04/02/javascript-notes/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/04/02/javascript-notes/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>现在的前端框架层出不穷，3个月就要重新入门一次前端的现状，让我们来不及学好基础就开始上手框架。常常就因为这样，我们会很快到达基础<code>技术瓶颈</code>，基础是所有技术的核心，在跳槽季重新温故了一遍 javascript 基础，有收获，整理出来分享给大家。</p>
</blockquote>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="变量可以当对象使用"><a href="#变量可以当对象使用" class="headerlink" title="变量可以当对象使用"></a>变量可以当对象使用</h4><p><code>javascript</code> 中所有的变量都可以当做对象使用，除了<code>undefined</code> 和 <code>null</code> ，我们测试下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">false.toString() // &quot;false&quot;</div><div class="line"></div><div class="line">[1,2,3].toString() //&quot;1,2,3&quot;</div><div class="line"></div><div class="line">1..toString() //&quot;1&quot;</div><div class="line"></div><div class="line">(&#123;a:&apos;33&apos;&#125;).toString() //&quot;[object Object]&quot;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">undefined.toString() //Uncaught TypeError</div><div class="line"></div><div class="line">null.toString()   //Uncaught TypeError</div></pre></td></tr></table></figure>
<p>数值和对象虽然能调用 <code>toString</code> 方法，但是在写法上需要注意下</p>
<p><code>number</code> 调用时不能直接数值后面直接调用<code>toString</code> 方法，因为 <code>js</code> 会将点运算符解析为数值的小数点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.toString() //Uncaught SyntaxError</div><div class="line"></div><div class="line">1..toString() //&quot;1&quot;</div></pre></td></tr></table></figure>
<p>对象直接调用<code>toString</code> 方法时，需要用小括号包裹起来，不然<code>js</code> 会将对象的花括号识别成块，从而报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;a:&apos;33&apos;&#125;.toString()  // Uncaught SyntaxError</div><div class="line"></div><div class="line">(&#123;a:&apos;33&apos;&#125;).toString() // &quot;[object Object]&quot;</div></pre></td></tr></table></figure>
<h4 id="对象删除属性"><a href="#对象删除属性" class="headerlink" title="对象删除属性"></a>对象删除属性</h4><blockquote>
<p>删除对象的属性唯一的方法是使用 <code>delete</code> 操作符，设置元素属性为 <code>undefined</code> 或则 <code>null</code> 并不能真正删除，只是移除了属性和值的关联</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var test = &#123;</div><div class="line">	name:&apos;bbt&apos;,</div><div class="line">	age:&apos;18&apos;,</div><div class="line">	love:&apos;dog&apos;</div><div class="line">&#125;</div><div class="line"></div><div class="line">test.name = undefined</div><div class="line">test.age = null</div><div class="line">delete test.love</div><div class="line"></div><div class="line">for (var i in test)&#123;</div><div class="line">  console.log(i+&apos;:&apos;+test[i])</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">name:undefined</div><div class="line">age:null</div><div class="line">undefined</div></pre></td></tr></table></figure>
<p>只有 <code>love</code> 被正则删除，<code>name</code> 和 <code>age</code> 还是能被遍历到</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><blockquote>
<p>在 <code>javascript</code> 中，通过关键字 <code>new</code> 调用的函数就被认为是构造函数，我们可以通过构造函数创建对象实例</p>
</blockquote>
<p>但是在使用过程中你一定发现了，每实例化一个对象，都会在实例对象上创造构造函数的方法和属性。倘若创建的实例比较多，重复创建同一个方法去开辟内存空间就会显得十分浪费，我们可以通过把被经常复用的方法放在原型链上。</p>
<h4 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h4><blockquote>
<p><code>javascript</code> 和一些我们所了解的面向对象编程的语言不太一样，在 <code>es6</code> 语法以前，我们是通过原型链来实现方法和属性的继承</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">function Child()&#123;</div><div class="line">  this.name = &apos;bbt&apos;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Child.prototype = &#123;</div><div class="line">	title:&apos;baba&apos;,</div><div class="line">    method: function() &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function Grandson()&#123;&#125;</div><div class="line"></div><div class="line">//设置 Grandson 的 prototype 为 Child 的实例</div><div class="line">Grandson.prototype = new Child()</div><div class="line"></div><div class="line">//为 Grandson 的原型添加添加属性 age</div><div class="line">Grandson.prototype.age = 40</div><div class="line"></div><div class="line">// 修正 Grandson.prototype.constructor 为 Grandson 本身</div><div class="line">Grandson.prototype.constructor = Grandson;</div><div class="line"></div><div class="line">var xiaomin = new Grandson()</div><div class="line"></div><div class="line">//原型链如下</div><div class="line">xiaomin // Grandson的实例</div><div class="line">    Grandson.prototype // Child的实例</div><div class="line">         Grandson.prototype //&#123;title:&apos;baba&apos;,...&#125;</div><div class="line">            Object.prototype</div><div class="line">                &#123;toString: ... /* etc. */&#125;;</div></pre></td></tr></table></figure>
<p>对象的属性查找，<code>javascript</code> 会在原型链上向上查找属性，直到查到 原型链顶部，所以，属性在原型链的越上端，查找的时间会越长，查找性能和复用属性方面需要开发者自己衡量下。</p>
<h4 id="获取自身对象属性"><a href="#获取自身对象属性" class="headerlink" title="获取自身对象属性"></a>获取自身对象属性</h4><p><code>hasOwnProperty</code> 方法能够判断一个对象是否包含自定义属性，而不是在原型链上的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var test = &#123;hello:&apos;123&apos;&#125;</div><div class="line"></div><div class="line">Object.prototype.name = &apos;bbt&apos;</div><div class="line"></div><div class="line">test.name  //&apos;bbt&apos;</div><div class="line">test.hasOwnProperty(&apos;hello&apos;) //true</div><div class="line">test.hasOwnProperty(&apos;name&apos;) //false</div></pre></td></tr></table></figure>
<p><code>for in</code> 循环可以遍历对象原型链上的所有属性，如此我们将 <code>hasOwnProperty</code>结合循环<code>for in</code> 能够获取到对象自定义属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var test = &#123;hello:&apos;222&apos;&#125;</div><div class="line">Object.prototype.name = &apos;bbt&apos;</div><div class="line"></div><div class="line">for(var i in test)&#123;</div><div class="line">  console.log(i) // 输出两个属性，hello ，name</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">for(var i in test)&#123;</div><div class="line">  if(test.hasOwnProperty(i))&#123;</div><div class="line">    console.log(i)//只输出 hello</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了上面的方法，<code>getOwnPropertyNames</code> 和 <code>Object.keys</code> 方法，能够返回对象自身的所有属性名，也是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有属性名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var test = &#123;hello:&apos;222&apos;&#125;</div><div class="line">Object.prototype.name = &apos;bbt&apos;</div><div class="line"></div><div class="line">Object.keys(test) //[&quot;hello&quot;]</div><div class="line">Object.getOwnPropertyNames(test) //[&quot;hello&quot;]</div></pre></td></tr></table></figure>
<p>那 <code>getOwnPropertyNames</code> 和 <code>Object.keys</code> 的用法有什么区别呢</p>
<p><code>Object.keys</code>方法只返回可枚举的属性，<code>Object.getOwnPropertyNames</code>  方法还返回不可枚举的属性名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var a = [&apos;Hello&apos;, &apos;World&apos;];</div><div class="line"></div><div class="line">Object.keys(a) // [&quot;0&quot;, &quot;1&quot;]</div><div class="line"></div><div class="line">Object.getOwnPropertyNames(a) // [&quot;0&quot;, &quot;1&quot;, &quot;length&quot;]  // length 是不可枚举属性</div></pre></td></tr></table></figure>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="函数声明的变量提升"><a href="#函数声明的变量提升" class="headerlink" title="函数声明的变量提升"></a>函数声明的变量提升</h4><p>我们通常会使用函数声明或函数赋值表达式来定义一个函数，函数声明和变量声明一样都存在提升的情况，函数可以在声明前调用，但是不可以在赋值前调用</p>
<p>函数声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">foo(); // 正常运行，因为foo在代码运行前已经被创建</div><div class="line">function foo() &#123;&#125;</div></pre></td></tr></table></figure>
<p>函数表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">foo; // &apos;undefined&apos;</div><div class="line">foo(); // 出错：TypeError</div><div class="line">var foo = function() &#123;&#125;;</div></pre></td></tr></table></figure>
<p>变量提升是在代码解析的时候进行的，foo() 方法调用的时候，已经在解析阶段将 foo 定义过了。赋值语句只在代码运行时才进行，所以在赋值前调用会报错</p>
<p>一种比较少用的函数赋值操作，将命名函数赋值给一个变量，此时的函数名只对函数内部可见</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var test = function foo()&#123;</div><div class="line">  console.log(foo) //正常输出</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log(foo) //Uncaught ReferenceError</div></pre></td></tr></table></figure>
<h4 id="this-的工作原理"><a href="#this-的工作原理" class="headerlink" title="this 的工作原理"></a>this 的工作原理</h4><blockquote>
<p>在 <code>javascript</code> 中 ，<code>this</code> 是一个比较难理解的点，不同的调用环境会导致 <code>this</code> 的不同指向，但是唯一不变的是 <code>this</code> 总是指向一个对象</p>
</blockquote>
<p>简单的说，<code>this</code> 就是属性和方法当前所在的对象（函数执行坐在的作用域），平时使用的 <code>this</code>  的情况可以大致分为5种</p>
<table>
<thead>
<tr>
<th>调用方式</th>
<th>指向</th>
</tr>
</thead>
<tbody>
<tr>
<td>1. 全局范围调用</td>
<td>指向 window 全局对象</td>
</tr>
<tr>
<td>2. 函数调用</td>
<td>指向 window 全局变量</td>
</tr>
<tr>
<td>3. 对象的方法调用</td>
<td>指向方法调用的对象</td>
</tr>
<tr>
<td>4. 构造函数调用</td>
<td>指向构造函数创建的实例</td>
</tr>
<tr>
<td>5. 通过，call ，apply ，bind 显示的指定 this指向</td>
<td>和传参有关</td>
</tr>
</tbody>
</table>
<p>Function.call</p>
<blockquote>
<p>语法：function.call(thisArg, arg1, arg2, …)，<code>thisArg</code>表示希望函数被调用的作用域，<code>arg1, arg2, …</code>表示希望被传入函数额参数 , 如果参数为空、<code>null</code>和<code>undefined</code>，则默认传入全局对象。</p>
</blockquote>
<p>代码示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var name = &apos;xiaomin&apos;</div><div class="line">var test = &#123;name : &apos;bbt&apos;&#125;</div><div class="line"></div><div class="line">function hello( _name )&#123;</div><div class="line">  _name ?console.log(this.name,_name): console.log(this.name)</div><div class="line">&#125;</div><div class="line"></div><div class="line">hello() //xiaomin</div><div class="line">hello.call(test) //bbt</div><div class="line">hello.call(test,&apos;xiaohong&apos;) //bbt xiaohong</div><div class="line">hello.call() //xiaomin</div><div class="line">hello.call(null) //xiaomin</div><div class="line">hello.call(undefined) //xiaomin</div></pre></td></tr></table></figure>
<p>Function.apply</p>
<blockquote>
<p>语法和<code>call</code> 方法类似，不同的是，传入调用函数的参数变成以数组的形式传入，即 func.apply(thisArg, [argsArray])</p>
</blockquote>
<p>改造上面的示例就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hello.apply(test,[&apos;xiaomin&apos;])</div></pre></td></tr></table></figure>
<p>Function.bind</p>
<blockquote>
<p><code>bind</code>方法用于将函数体内的<code>this</code>绑定到某个对象，然后返回一个新函数。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var d = new Date();</div><div class="line">d.getTime()</div><div class="line"></div><div class="line">var print = d.getTime; //赋值后 getTime 已经不指向 d 实例</div><div class="line">print() // Uncaught TypeError</div></pre></td></tr></table></figure>
<p>解决方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var print = d.getTime.bind(d)</div></pre></td></tr></table></figure>
<p>容易出错的地方</p>
<p>容易出错的地方，函数调用，<code>this</code> 总是指向 <code>window</code> 全局变量，所以在对象的方法里如果有函数的调用的话（闭包的情况），<code>this</code> 是会指向 全局对象的，不会指向调用的对象，具体示例如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var name = &apos;xiaomin&apos;</div><div class="line">var test = &#123;</div><div class="line">  name : &apos;bbt&apos;</div><div class="line">&#125;</div><div class="line">test.method = function()&#123;</div><div class="line">  function hello()&#123;</div><div class="line">      console.log(this.name)</div><div class="line">    &#125;</div><div class="line">    hello()</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 调用</div><div class="line">test.method() // 输出 xiaomin</div></pre></td></tr></table></figure>
<p>如果需要将 <code>this</code> 指向调用的对象，可以将对象的 <code>this</code> 指向存储起来，通常我们使用 <code>that</code> 变量来做这个存储。改进之后的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var name = &apos;xiaomin&apos;</div><div class="line">var test = &#123;</div><div class="line">  name : &apos;bbt&apos;</div><div class="line">&#125;</div><div class="line">test.method = function()&#123;</div><div class="line">  var that = this</div><div class="line">  function hello()&#123;</div><div class="line">      console.log(that.name)</div><div class="line">    &#125;</div><div class="line">    hello()</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 调用</div><div class="line">test.method() // 输出 bbt</div></pre></td></tr></table></figure>
<p>####闭包和引用</p>
<blockquote>
<p>闭包我们可以理解成是在函数内部定义的函数</p>
</blockquote>
<p>在 <code>javascript</code> 中，内部作用域可以访问到外部作用域的变量，但是外部作用域不能访问内部作用域，需要访问的时候，我们需要通过创建闭包，来操作内部变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function test(_count)&#123;</div><div class="line">  var count = _count</div><div class="line"></div><div class="line">  return &#123;</div><div class="line">    inc:function()&#123;</div><div class="line">      count++</div><div class="line">    &#125;,</div><div class="line">    get:function()&#123;</div><div class="line">      return count</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var a = test(4)</div><div class="line">a.get()//4</div><div class="line">a.inc()</div><div class="line">a.get()//5</div></pre></td></tr></table></figure>
<p>闭包中常会出错的面试题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for(var i = 0; i &lt; 10; i++) &#123;</div><div class="line">    setTimeout(function() &#123;</div><div class="line">        console.log(i);</div><div class="line">    &#125;, 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很多同学会觉得，上面的代码会正常输出0到9，但是实际是输出十次10。遇到这个题目，除了闭包的概念要理解清楚，你还需要知道，<code>setTimeout</code> 内的代码会被异步执行，代码会先执行所有的同步代码，即上面的这段代码会先将 <code>for</code> 循环执行，此时 <code>i</code> 的值为 10，console.log(i) 一直引用着全局变量的 i  所以会输出十次 10</p>
<p> 改进代码，我们在 <code>for</code> 循环里创建一个闭包，把循环自增的 <code>i</code> 作为参数传入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for(var i = 0; i &lt; 10; i++) &#123;</div><div class="line">    (function(e) &#123;</div><div class="line">        setTimeout(function() &#123;</div><div class="line">            console.log(e);</div><div class="line">        &#125;, 1000);</div><div class="line">    &#125;)(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="setTimeout-amp-amp-setInterval"><a href="#setTimeout-amp-amp-setInterval" class="headerlink" title="setTimeout &amp;&amp; setInterval"></a>setTimeout &amp;&amp; setInterval</h4><blockquote>
<p><code>javascript</code> 是异步的单线程运行语言，其他代码运行的时候可能会阻塞 <code>setTimeout</code> &amp;&amp; <code>setInterval</code> 的运行</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">console.log(1)</div><div class="line">setTimeout(function()&#123;</div><div class="line">  console.log(2)</div><div class="line">&#125;, 0);</div><div class="line">console.log(3)</div><div class="line"></div><div class="line">输出结果： 1，3，2  //setTimeout 被阻塞</div></pre></td></tr></table></figure>
<p>处理阻塞的方法是将<code>setTimeout</code> 和 <code>setInterval</code>放在回调函数里执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function test()&#123;</div><div class="line">  	setTimeout(function()&#123;</div><div class="line">  		console.log(2)</div><div class="line">	&#125;, 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>setTimeout</code> 和 <code>setInterval</code> 被调用时会返回一个 ID 用来清除定时器</p>
<p>手工清除某个定时器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var id = setTimeout(foo, 1000);</div><div class="line">clearTimeout(id);</div></pre></td></tr></table></figure>
<p>清楚所有的定时器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var lastId = setTimeout(function()&#123;</div><div class="line">  console.log(&apos;11&apos;)</div><div class="line">&#125;, 0);</div><div class="line"></div><div class="line">for(var i=0;i&lt;lastId;i++;)&#123;</div><div class="line">  clearTimeout(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>获取最后一个定时器的id，遍历清除定时器，可以清除所有的定时器。</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>####包装对象</p>
<blockquote>
<p>数值、字符串、布尔值——在一定条件下，也会自动转为对象，也就是原始类型的“包装对象”。</p>
</blockquote>
<p>我们可以通过构造函数，将原始类型转化为对应的对象即包装对象，从而是原始类型能够方便的调用某些方法</p>
<p>数值，字符串，布尔值的类型转换函数分别是 <code>Number，String，Boolean</code>，在调用的时候在函数前面加上New 就变成了构造函数，能够蒋对应的原始类型转化为“包装对象”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var v1 = new Number(123);</div><div class="line">var v2 = new String(&apos;abc&apos;);</div><div class="line">var v3 = new Boolean(true);</div><div class="line"></div><div class="line">typeof v1 // &quot;object&quot;</div><div class="line">typeof v2 // &quot;object&quot;</div><div class="line">typeof v3 // &quot;object&quot;</div><div class="line"></div><div class="line">v1 === 123 // false</div><div class="line">v2 === &apos;abc&apos; // false</div><div class="line">v3 === true // false</div></pre></td></tr></table></figure>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>类型转换分为强制类型转换和自动转换，<code>javascript</code> 是动态类型语言，在到吗解析运行时，需要的数据类型和传入的数据类型不一致的时候，<code>javascript</code> 会进行自动类型转化。当然，你也可以通过类型转换方法进行强制类型装换。</p>
<p>日常开发中，我们最常用的数据类型自动转换不过就下面三种情况</p>
<p>不同数据类型之间相互运算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&apos;2&apos;+4 // &apos;24&apos;</div></pre></td></tr></table></figure>
<p>对非布尔值进行布尔运算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if(&apos;22&apos;)&#123;</div><div class="line">  console.log(&apos;hello&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对非数据类型使用一元运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+&apos;12&apos;  //12</div></pre></td></tr></table></figure>
<p>我们也通过<code>Number ，String，Boolean</code> 来进行强制数据类型转换。强制类型转化的规则有点复杂，我们来了解一下。</p>
<p>Number 转换  <a href="http://javascript.ruanyifeng.com/grammar/conversion.html" target="_blank" rel="external">引用阮老师的详细解释</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">第一步，调用对象自身的valueOf方法。如果返回原始类型的值，则直接对该值使用Number函数，不再进行后续步骤。</div><div class="line"></div><div class="line">第二步，如果 valueOf 方法返回的还是对象，则改为调用对象自身的 toString 方法。如果 toString 方法返回原始类型的值，则对该值使用 Number 函数，不再进行后续步骤。</div><div class="line"></div><div class="line">第三步，如果 toString 方法返回的是对象，就报错。</div></pre></td></tr></table></figure>
<p><code>String</code> 转换方法同样也是通过调用原对象的 <code>toString</code> 方法和 <code>valueOf</code> 方法，但是不同的是 <code>String</code> 函数会先调用 <code>toString</code> 方法进行转换</p>
<p><code>Boolean</code> 的转换规则会相对简单一些，除了几个特殊的值，都会被转化为 <code>true</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">undefined</div><div class="line">null</div><div class="line">+0或-0</div><div class="line">NaN</div><div class="line">&apos;&apos;（空字符串）</div></pre></td></tr></table></figure>
<p>但是要注意</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Boolean(&apos;false&apos;) //true</div></pre></td></tr></table></figure>
<h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><blockquote>
<p><code>typeof</code> 操作符返回数据类型，但是由于 <code>javascript</code> 设计的历史原因，<code>typeof</code> 现已经不能满足我们现在对于类型判断的要求了</p>
</blockquote>
<table>
<thead>
<tr>
<th>Value</th>
<th>Class</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>“foo”</td>
<td>String</td>
<td>string</td>
</tr>
<tr>
<td>new String(“foo”)</td>
<td>String</td>
<td>object</td>
</tr>
<tr>
<td>1.2</td>
<td>Number</td>
<td>number</td>
</tr>
<tr>
<td>new Number(1.2)</td>
<td>Number</td>
<td>object</td>
</tr>
<tr>
<td>true</td>
<td>Boolean</td>
<td>boolean</td>
</tr>
<tr>
<td>new Boolean(true)</td>
<td>Boolean</td>
<td>object</td>
</tr>
<tr>
<td>new Date()</td>
<td>Date</td>
<td>object</td>
</tr>
<tr>
<td>new Error()</td>
<td>Error</td>
<td>object</td>
</tr>
<tr>
<td>[1,2,3]</td>
<td>Array</td>
<td>object</td>
</tr>
<tr>
<td>new Array(1, 2, 3)</td>
<td>Array</td>
<td>object</td>
</tr>
<tr>
<td>new Function(“”)</td>
<td>Function</td>
<td>functio</td>
</tr>
<tr>
<td>/abc/g</td>
<td>RegExp</td>
<td>object (function in Nitro/V8)</td>
</tr>
<tr>
<td>new RegExp(“meow”)</td>
<td>RegExp</td>
<td>object (function in Nitro/V8)</td>
</tr>
<tr>
<td>{}</td>
<td>Object</td>
<td>object</td>
</tr>
<tr>
<td>new Object()</td>
<td>Object</td>
<td>object</td>
</tr>
<tr>
<td>null</td>
<td>null</td>
<td>object</td>
</tr>
</tbody>
</table>
<p>我们可以看到，<code>typeof</code> 不能区分对象的数组和日期，还会把 <code>null</code> 判断成对象，那我们一般是什么时候用 <code>typeof</code> 呢。我们可以用来判断一个已经定义的变量是否被赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a</div><div class="line">if(typeof a == &apos;undefined&apos;)&#123;</div><div class="line">  console.log(&apos;a 已经被定义&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><blockquote>
<p><code>instanceof</code> 操作符通常用来判断，一个对象是否在另一个对象的原型链上，需要注意的是 <code>instanceof</code> 的左值是对象，右值是构造函数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// defining constructors</div><div class="line">function C() &#123;&#125;</div><div class="line">function D() &#123;&#125;</div><div class="line"></div><div class="line">var o = new C();</div><div class="line"></div><div class="line">// true, because: Object.getPrototypeOf(o) === C.prototype</div><div class="line">o instanceof C;</div><div class="line"></div><div class="line">// false, because D.prototype is nowhere in o&apos;s prototype chain</div><div class="line">o instanceof D;</div></pre></td></tr></table></figure>
<h4 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a>Object.prototype.toString</h4><blockquote>
<p>那么我们有没有可以用来区分变量数据类型的方法呢，有，<code>Object.prototype.toString</code></p>
</blockquote>
<p>一些原始数据类型也有 <code>toString</code> 方法，但是通常他们的 <code>toString</code> 方法都是改造过的，不能进行 数据类型判断，所以我们需要用 <code>Object</code> 原型链上的 <code>toString</code> 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a = 1234</div><div class="line">a.toString() // &apos;1234&apos;</div><div class="line"></div><div class="line">Object.prototype.toString.call(a) // &quot;[object Number]&quot;</div></pre></td></tr></table></figure>
<p> 不同类型返回的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">1. 数值 [object Number]</div><div class="line">2. 字符串 [object String]</div><div class="line">3.布尔值 [object Boolean]</div><div class="line">4.undefined [object undefined]</div><div class="line">5.null  [object Null]</div><div class="line">6.数组 [object Array]</div><div class="line">7.arguments [object Arguments]</div><div class="line">8.函数 [object function]</div><div class="line">9.Error [object Error]</div><div class="line">10.Date [object Date]</div><div class="line">11.RegExp [object RegExp]</div><div class="line">12.其他对象 [object object]</div></pre></td></tr></table></figure>
<p>那么我们就能够通过 <code>Object.prototype.toString</code> 方法，封装一个可以判断变量数据类型的函数了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function type(obj) &#123;</div><div class="line">    return Object.prototype.toString.call(obj).slice(8, -1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">type(function()&#123;&#125;) //&quot;Function&quot;</div></pre></td></tr></table></figure>
<blockquote>
<p>这次我们从对象、函数、类型三方面入手了解了<code>javascript</code> 中容易被忽视或则说比较难理解的地方，我会继续将我在学习中积累的内容分享给大家，如果大家觉得文章有需要改进或则有其他想要了解的内容的，欢迎私信，评论或则微信我，我的微信是：646321933</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2018/03/28/sanya/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/28/sanya/" itemprop="url">
                  三亚之旅
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-28T16:31:57+08:00">
                2018-03-28
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2018/03/28/sanya/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/03/28/sanya/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>大家总说，身体和心灵需要有一个在路上。读书不一定所有的人都能喜欢，但是旅行绝对是每一个年龄阶段的人都不会拒绝的的一种亦或是放松亦或是长见识的方式，如果说优缺点的话，那应该就是心疼钱了。我很喜欢旅游，我觉得每年一次旅行是必要的。</p>
</blockquote>
<p>旅行一般我都是临时起意的，看到哪里的机票便宜了，就买了准备走，所以我还是比较倾向于不需要办签证的地方，比如济州岛，或则国内。这次我们去了三亚。</p>
<p>因为是自由行，去之前做了一些粗略的攻略，确定几个自己想要游玩的景点。但是这次行程除了入住的地方和攻略是一致的，其他的都没有按照攻略来。</p>
<p>攻略是按照窝蜂上的推荐景点排序进行筛选的，但是到三亚的时候，当地居民推荐了我去其他景点，游客少的，消费更低一些的。</p>
<p>机票是在携程上买的，杭州出发到海口，海口动车到三亚（别问为啥不直飞，因为穷，哈哈哈）海口的火车站和飞机场在一个地方，掐着点的话，下飞机一个半小时就能到三亚了。担心飞机晚点问题，还有到机场需要去提行李，所以没有提前买动车票，到站买了最近一趟去三亚，所以下飞机后我们在火车站逗留了大概一个小时才出发去三亚。</p>
<h2 id="D1"><a href="#D1" class="headerlink" title="D1"></a>D1</h2><p>飞机是上午6点出发，8点55到海口，坐动车到三亚的时候已经是12点了，入住房间刚好，我们把房间定在三亚湾，190 一晚的海景房（一室一厅一厨一卫）感觉性价超级高，三亚的物价没有特别高，溜达的时候，有看到布丁酒店100多一晚的房间，但是不是在海边，具体房间是怎么样的，我也不太清楚，如果预算不够的话，可以住这种的。</p>
<p>因为出门就能到海边，虽然肚子又点饿，我们没有马上去觅食，而是去海边小坐了一会，没有坐太久，因为大中午的实在太热了，哈哈。在沙滩上看到了几个皮肤十分黑的男人在光着屁股晒太阳，以为是外国黑人，还在感叹他们奔放的时候发现其实是三亚本地人，脸上3条黑线</p>
<p>三亚湾上街购物和吃放也很方便，过一条马路就能到热闹的地方去，因为没有在淘宝上挑到自己喜欢的草帽，所以没有带，三亚很晒，所以在逛当地礼品店的时候买了一个，15块钱，和淘宝的价格差不多，没有很宰客，后面又买了一个自拍杆，20块，比淘宝上买略贵一些。</p>
<p>中午随便吃的重庆小面，2人吃了30多，这个比在杭州吃的时候贵一丢丢，在杭州吃可能 20多就搞定了。也说不上来，可能这个不是三亚本地的吃食吧，所以要贵一些，三亚的海鲜和热带水果还是很便宜的。</p>
<p>因为第一天早上为了赶飞机，3点多就起来了，我们两个都有点累，本来这一天也没有很特别的行程安排，所以我们就在酒店睡了一下午，晚上的时候本来想随意吃点，逛到了海鲜加工市场，就在市场里买了活海鲜加工着吃，2个人一共吃了300块，因为没有挑加工店，随意没有特别好吃也没有特别难吃，如果你们去的话，还是建议去第一海鲜市场，挑个开的时间长的加工店，</p>
<p>晚上我们吃完饭又去沙滩上坐了会，穿着拖鞋去海棠踏浪。快到10点的时候准备回房间，在沿着海滩边上的路牙上有好多大姐大妈在按摩，20块钱可以按20分钟，挺舒服的。</p>
<p><img src="/images/travel/yz.jpeg" alt="三亚路牙子"></p>
<h2 id="D2"><a href="#D2" class="headerlink" title="D2"></a>D2</h2><p>第二天，我们睡到9点起，打算坐公交车去亚龙湾潜水，在等公交的时候有个大叔问我们去哪，可以送。开始以为是黄牛，有点不太想搭理他。他和我们说可以送我们去亚龙湾，带我们去售票点买票，他们是通过带人去售票店买票积分，然后领礼品的。他和我们说潜水的话，亚龙湾398可以潜，水上项目想多玩点的话，可以去西岛，西岛的套票是 980 可以玩18项。送我们去西岛的话只要每人5块的路费</p>
<p>我们想着，反正也来了，就去多玩点吧，亚龙湾是在三亚的海岸边，海水可能也会比较浑浊，出海到岛上潜水体验应该能好点。于是我们坐了他老婆的车到西岛售票处，车子沿着海边开了半个小时左右，5块一个人的路费真是良心价。</p>
<p>到西岛后，我们买了980 的套票，里面包括珊瑚礁潜水，保礁潜水，香蕉船，飞鱼船，快艇，观光艇，划伞，中午的自助餐，鱼疗和台风体验等小项目，也不是所有的项目都好玩，一半一半吧，反正这么买套票我觉得是十分划算的</p>
<p>我们上岛第一个玩的项目是潜水，潜水有潜水服，但是你还是要穿自己的泳衣在里面，玩其他水上项目也会把衣服弄湿，所以潜完之后，你可以不换衣服，直接去玩其他水上项目了。</p>
<p>潜水很好玩，潜水前教练会教你一些简单的手势动作，全程教练牵着你移动，所以即使不会游泳也没有关系。潜水的时候最好自己带着鱼食，吸引小鱼。虽然我没有买，但是和我一起潜的其他同学买了，蹭了一把鱼食，小鱼在自己周边游动，十分有趣，壮观</p>
<p>潜完水，我们衣服没换去吃了自助餐，然后去划伞，划伞这个项目说不上好玩不好玩，就是快艇拉着你在海上兜一圈，不是很刺激，看起来很好玩，实际也没有特别好玩，如果没买套票的话，不是很建议单买着玩</p>
<p>然后我们去坐了香蕉船，飞羽船，快艇，基本上都是你坐在气垫小船上被快艇拉着在海上兜一圈，速度比较快，挺刺激的。（香蕉船千万别坐第一排，海水很咸，十分辣眼睛，一路海水打在脸上眼睛上，全程睁不开眼睛，飞鱼船可以坐第一排，不会有很多水贱上来，第一排视野还算开阔的）</p>
<p>水上项目都在一个地方，我们玩了全部的水上项目基本也到下午3点钟了，去做了鱼疗足浴，其实是热带小鱼吃你的角质，脚放进去会痒痒的，但是还满舒服的。然后坐环岛电瓶去了牛岛，因为赶着要在6点前离岛，我们就再牛岛上随意逛了下，拍了几张照片。</p>
<p>出岛的时候人比较多，我们排队差不多排了半个小时，晚上回去的时候我问了下，打车去三亚湾要60多，不是很划算，我们去坐了公交车，在等公交的时候我买了芒果，10块钱2小袋，我数了一下，一共有11个手掌心这么大的芒果，而且十分甜，很好吃。</p>
<p>到酒店的时候差不多7点多，我们洗个澡出门觅食，找到一条小吃街，在解放路上，我们住的地方过去需要走15分钟，也算方便，吃了海鲜烧烤和清补凉臭豆腐，买了泡椒鸡爪，一个人50块钱管够了</p>
<p>吃完饭，我们照例去海滩边逛了下，躺一会，晚上的海滩真的太舒服了，让人想融化在沙滩上。等老了真心可以在海滩边买一套房子养老，哈哈哈。晚上的海滩很热闹，很多游客在踩水，拍婚纱照，还有当地的老人歌舞团的聚会活动，到处是欢声笑语。从海滩边回来，我们在路牙边做了马杀鸡，好多老阿姨按摩，20块钱可以按20分钟，不贵，很舒服，按完然后回去睡觉<br><img src="/images/travel/hb.jpeg" alt="三亚路牙子"></p>
<h2 id="D3"><a href="#D3" class="headerlink" title="D3"></a>D3</h2><p>前一天玩水玩的比较累，第二天10点才起来，按照原来的计划，是想去南山文化旅游区，那边的108米的海上观音很出名，但是后来没有去，也幸好没去，30多度在外面逛露天的景点实在不太合适，昨天玩水一起认识的几个小伙伴去了，他们和我说让我别去，他们就逛了10几分钟就走了，因为实在太热了</p>
<p>在我们不知道要去哪里的时候，昨天带我们去西岛的大姐发微信和我说，我们可以去热带雨林，20块钱一个人带我们玩一天，在景点买票就行。而且雨林里有丛林飞跃，是我很想玩的项目，于是我们去了呀渃哒，大姐和我们说这个在海南话里是 1，2，3 的意思。呀渃哒 的门票加丛林飞跃项目是 300块一人，后来我们又加了踏步戏水的项目，每人150。踏步戏水不是很建议玩，感觉比较像是团建，因为大家的身体素质不一样，景区不太敢开放太冒险的路段，所以不是很刺激，没有特别好玩。丛林飞跃就是玉林滑索项目，索道从一个山头到另一个山头，一共有130米，速度不是很快，但是在玉林中飞过，眺看整个玉林的样子真是很舒服，值得一玩。可惜就是不让带手机，索道的终点会有人给你拍照，照片是要钱的，要不要照片就看你个人意愿了，反正我是不太喜欢。</p>
<p>丛林飞跃之后可以在玉林里闲逛一会，景区会给散客一个电子讲解器，讲解到是挺详细的，反正我是没有耐心听下来，全程拍照瞎晃。只记住槟榔树在海南是一个很重要的文化，以前小伙子要爬49颗槟榔树才能取到老婆。</p>
<p>雨林很舒服，有身处大自然的感觉，值得去，反正我是觉得一天雨林一天海滩的玩耍方案挺合适的，到是海滩和雨林的景点是比较多的，除了我玩的几个，你们可以自由选择下</p>
<p>晚上到酒店，我们又重复了前一天的活动，小吃，海滩，马杀鸡</p>
<p><img src="/images/travel/rx.jpeg" alt="三亚路牙子"></p>
<h2 id="D4"><a href="#D4" class="headerlink" title="D4"></a>D4</h2><p>第四天，我们晚上11点的飞机，而且需要从三亚坐动车到海口机场，所以我们12点退了房子，打算继续在海滩边玩到下午5，6点再出发。不过现实总是没有想象的美好，30度的海滩，也热，我们差不多在海滩边逗留了1个小时，去吃了午饭买了些菠萝和泡面就公交到动车站避暑了。</p>
<p>我们没有提前买动车票，总是买的就近一般有座位的，4点从三亚触发，到海口的检完票的时候差不多8点了。逛了免税店，买了2千的面膜和洗面奶，9刚好9点多。在机场吃了泡面，玩机场农药就开始回城机票检票了</p>
<p>总得来说第四天，没有很紧张的行程，就是瞎逛，买东西，吃东西。三亚的景点都离得比价远，去一个景点公交都差不多要2个小时的样子，来回需要4个小时在路上。如果要赶着玩的话其实可以把行李寄存起来再玩一个景点。但是想着太累了，我们还是把时间留下去逛免税店了。</p>
<p><img src="/images/travel/by.jpeg" alt="三亚路牙子"></p>
<h2 id="装备"><a href="#装备" class="headerlink" title="装备"></a>装备</h2><p>以下我罗列的非必要，但是很有用，哈哈哈</p>
<table>
<thead>
<tr>
<th style="text-align:center">防晒</th>
<th style="text-align:center">记录旅程</th>
<th style="text-align:center">玩水</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">防晒霜</td>
<td style="text-align:center">自拍杆</td>
<td style="text-align:center">手机防水袋</td>
</tr>
<tr>
<td style="text-align:center">防晒外套</td>
<td style="text-align:center">美美的衣服</td>
<td style="text-align:center">拖鞋</td>
</tr>
<tr>
<td style="text-align:center">帽子</td>
<td style="text-align:center">墨镜</td>
<td style="text-align:center">钱</td>
</tr>
</tbody>
</table>
<h2 id="你可能想要知道的东西"><a href="#你可能想要知道的东西" class="headerlink" title="你可能想要知道的东西"></a>你可能想要知道的东西</h2><ol>
<li>我们190订的海景房，是在爱彼迎上定的，这个平台主打民宿所以比携程上便宜，平台注册链接 <a href="https://zh.airbnb.com/c/09425c" target="_blank" rel="external">https://zh.airbnb.com/c/09425c</a></li>
<li>三亚水果很便宜，最便宜的是在槟榔谷，10块钱能买5个菠萝。市区0块钱只能买3个，如果想买没有削皮的菠萝，可以去就近的菜市场</li>
<li>马杀鸡在三亚湾的海岸上，20块1次，可以按20分钟</li>
<li>如果你有其他的想问，可以私我像我，我的微信：646321933</li>
</ol>
<blockquote>
<p>我们的行程是4天3夜，如果有时间的话，建议还是6天5夜，这样能把大部分的景点覆盖到，蜈支洲岛，分界洲，南山文化旅游区，槟榔谷，国家森林公园都可以去走一走。三亚是个很舒服的城市，在三亚，你会感觉整个时间都慢下来，很舒服很放松，你会喜欢的</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2018/03/05/cookie-share/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/05/cookie-share/" itemprop="url">
                  web 浏览器指纹跨域共享
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-05T17:41:49+08:00">
                2018-03-05
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2018/03/05/cookie-share/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/03/05/cookie-share/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>概念：设备id 即设备指纹，用来表示用户设备的唯一性</p>
</blockquote>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近在做用户行为分析项目的开发，需要采集用户的设备信息，需要用设备指纹来唯一表示用户操作设备。web 存储都和浏览器相关，我们无法通过js 来标识一台电脑，只能以浏览器作为设备维度来采集设备信息。即用户电脑中一个浏览器就是一个设备。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>web 变量存储，我们第一时间想到的就是 cookie，sessionStorage，localStorage，但是这3种存储方式都和访问资源的域名相关。我们总不能每次访问一个网站就新建一个设备指纹吧，所以我们需要通过一个方法来跨域共享设备指纹</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>我们想到的方案是，通过嵌套 iframe 加载一个静态页面，在 iframe 上加载的域名上存储设备id，通过跨域共享变量获取设备id，共享变量的原理是采用了iframe 的 contentWindow通讯，通过 postMessage 获取事件状态，调用封装好的回调函数进行数据处理</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>SDK 采集端，调用方初始化的时候调用方法</p>
<pre><code>collect.setIframe = function () {
      var that = this
      var iframe = document.createElement(&apos;iframe&apos;)
      iframe.src = &quot;http://localhost:82/&quot;
      iframe.style = &apos;display:none&apos;
      document.body.appendChild(iframe)
      iframe.onload = function () {
        iframe.contentWindow.postMessage(&apos;loaded&apos;,&apos;*&apos;);
      }

      //监听message事件
      window.addEventListener(&quot;message&quot;, function(){
            that.deviceId = event.data.deviceId

            console.log(&apos;获取设备id&apos;,that.deviceId)

            sessionStorage.setItem(&apos;PageSessionID&apos;,helper.upid())
            helper.send(that.getParames(), that.eventUrl);
            helper.sendDevice(that.getDevice(), that.deviceUrl);
      }, false);
}
</code></pre><p>嵌套在 iframe 静态页面里的脚本</p>
<pre><code>&lt;script&gt;

     var getDeviceId = function() {
             return &apos;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&apos;.replace(/[xy]/g, function (c) {
                     var r = Math.random() * 16 | 0, v = c == &apos;x&apos; ? r : (r &amp; 0x3 | 0x8);
                     return v.toString(16);
             });
     };

     var hasCreated = false
     var _deviceId = &apos;&apos;
     if(document.cookie){
             document.cookie.split(&apos;;&apos;).forEach(function(i){
                     if(i.indexOf(&apos;deviceId&apos;)&gt;-1){
                             hasCreated = true
                             _deviceId = i.split(&apos;=&apos;)[1]
                     }
             })
     }

     if(!_deviceId &amp;&amp; (sessionStorage.getItem(&apos;deviceId&apos;)||localStorage.getItem(&apos;deviceId&apos;))){
             hasCreated = true
             _deviceId = sessionStorage.getItem(&apos;deviceId&apos;)||localStorage.getItem(&apos;deviceId&apos;)
     }


     if(!hasCreated) {
             _deviceId =  getDeviceId()
             document.cookie = &apos;deviceId=&apos; + _deviceId
             sessionStorage.setItem(&apos;deviceId&apos;,_deviceId)
             localStorage.setItem(&apos;deviceId&apos;,_deviceId)
     }

     //回调函数
     function receiveMessageFromIndex ( event ) {
             console.log( &apos;receiveMessageFromIndex&apos;, event )
             parent.postMessage( {deviceId: _deviceId}, &apos;*&apos;);
     }
     //监听message事件
     window.addEventListener(&quot;message&quot;, receiveMessageFromIndex, false);

 &lt;/script&gt;
</code></pre><h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><p><a href="http://cxh.me/2014/11/25/flash-shared-cookie/" target="_blank" rel="external">跨浏览器cookie</a><br><a href="http://www.freebuf.com/articles/web/139984.html" target="_blank" rel="external">跨浏览器指纹识别</a><br><a href="https://paper.seebug.org/229/" target="_blank" rel="external">浏览器指纹追踪</a><br><a href="https://rockjins.js.org/2017/05/05/2017-05-05-iframe-cross-domain-Communication" target="_blank" rel="external">使用postMessage解决iframe跨域通信问题</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage" target="_blank" rel="external">window.postMessage</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2018/02/26/cookie-set/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/26/cookie-set/" itemprop="url">
                  跨域问题导致设置 cookie 不生效的问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-26T16:18:09+08:00">
                2018-02-26
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2018/02/26/cookie-set/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/02/26/cookie-set/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们看下跨域不生效的问题，首先抛出两个问题：</p>
<blockquote>
<ol>
<li>我们如何设置 cookie ？</li>
<li>又如何确定 cookie 设置是否生效了 ？</li>
</ol>
</blockquote>
<p>首先，我们实现一个简单的接口,新建一个 test.js 文件，将如下代码复制进去，通过 <code>node test.js</code> 启动服务，在本地就可以通过 <code>http://localhost:3000/rest/collect/event/h5/v1/</code> 来访问了我们创建的接口了（node 环境安装的教程网上有很多详细的教程，本文不再赘述）</p>
<pre>
var express = require('express');
var app = express();
var URL = require('url')
var path = require('path');


app.post('/rest/collect/event/h5/v1/', function(req, res) {
        res.cookie('token','11111112222222224444444444')
        res.cookie('httpOnly-token','11111112222222224444444444',{ httpOnly: true })

        function User() {
                this.name;
                this.city;
                this.age;
        }

        var user = new User();

        if(params.id == '1') {

                user.name = "ligh";
                user.age = "1";
                user.city = "北京市";

        }else{
                user.name = "SPTING";
                user.age = "1";
                user.city = "杭州市";
        }

        var response = {status:1,data:user};
        res.send(JSON.stringify(response));
});

app.listen(3000);
console.log('Listening on port 3000...');
</pre>

<p>访问效果如下</p>
<p><img src="/images/cookie/3.jpeg" alt="接口访问效果如下"></p>
<p>在前端代码中访问我们的接口<br><img src="/images/cookie/4.jpeg" alt="cookie设置"><br><img src="/images/cookie/5.jpeg" alt="cookie查看"><br>在浏览器中我们可以看到请求的 Resopnse Headers 里，有两个 <code>set-cookie</code>头部，区别在于一个带有 <code>HttpOnly</code>的标识，我们打开浏览器的调试窗口<code>Application</code>我们可以看到，两个数值都被设置到浏览器里了，<code>httpOnly</code>的值在浏览器调试窗口的<code>http</code>一栏，打了个小勾，说明这个变量是只能通过 http 请求来获取到这个cookie ，前端无法通过 js 的 <code>document.cookie</code>来获取到<br><img src="/images/cookie/7.jpeg" alt="就是无法操作的cookie"><br>讲到这块内容，我们顺便讲下 cookie 设置的其他参数的作用</p>
<p><img src="/images/cookie/6.jpeg" alt="其他参数"><br>cookie 和域名相关的哟，<code>Domain</code> 变量表示 cookie 生效的域名，<code>expries</code>和<code>max-age</code>表示 cookie 的有效时间</p>
<h4 id="问题描述及解决"><a href="#问题描述及解决" class="headerlink" title="问题描述及解决"></a>问题描述及解决</h4><p>在开发阶段我自己用node 简单的写了一个接口，便于联调前端传参问题，希望通过 http 的set-cookie 存储变量， 但是却始终没有把 cookie 成功设置到浏览器里，经过排查发现是跨域导致的 cookie 设置不生效<br><img src="/images/cookie/1.jpeg" alt="cookie设置"><br><img src="/images/cookie/2.jpeg" alt="cookie查看"></p>
<p>不生效的原因是我本地项目启动在 <code>http://localhost:70</code>,但是调用的接口在 <code>http://localhost:3000</code>上，端口不一样，存在跨域的问题，所以虽然在 Response Header 里看到了<code>set-cookie</code>的操作，但是在浏览器的 <code>application</code>里看到，并没有被设置进来，解决办法，通过nginx 代理（最长用的跨域解决办法）</p>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>跨域的问题在开发过程中比较常见，我们经常会碰到，简单来说<code>只要请求资源的协议，域名，端口不一致，都会导致跨域</code>，网上的解决方法也比较多，比较成熟，本文不做扩展，附带几个链接供大家参考</p>
<p><a href="http://harttle.land/2016/12/30/cors-preflight.html" target="_blank" rel="external">跨域中的预检测请求</a><br><a href="https://www.jianshu.com/p/13d53acc124f" target="_blank" rel="external">CORS 跨域中的 Cookie</a><br><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="external">跨域资源共享 CORS 详解</a><br><a href="http://harttle.land/2015/10/10/cross-origin.html" target="_blank" rel="external">Web开发中跨域的几种解决方案</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2017/05/18/nginx-basic/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/18/nginx-basic/" itemprop="url">
                  你需要知道的 nginx 基础配置
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-18T14:23:31+08:00">
                2017-05-18
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2017/05/18/nginx-basic/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/05/18/nginx-basic/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="初探nginx"><a href="#初探nginx" class="headerlink" title="初探nginx"></a>初探nginx</h2><blockquote>
<p>今天给大家讲下nginx的基础配置,很多小伙伴在开发的过程中会使用到 nginx ,但是确对 nginx 的配置其实并不了解,今天我给大家讲下基础的配置项.nginx 的功能很多,但是说到 nginx 大家最先想到的是反向代理和负载均衡.</p>
</blockquote>
<p>“负载均衡”在开发环境体现的不太明显,主要是为了解决生产环境的客户端请求很多的时候,动态的去分散给各个服务器,缓解服务器压力,充 分利用资源.而说到 “反向代理”,你的第一反应应该是”正向代理”,简称”代理”,你可以把代理想象成客户端和服务端的中介,代理的种类很多,比较常见的是,客户端对服务端进行请求的时候,代理会对请求的内容进行下载缓存,从而提高客户端的请求速度,代理还有多重代理,加密处理等功能,”反向代理”的作用和正项代理的功能相辅相成,原理也类似,反向代理将字符串和相应的服务器和端口匹配上,从而获取用户想要获取的内容,那么这两者的区分是什么呢,”正向代理”作用于客户端,”反向代理”作用于服务器.</p>
<h2 id="生动的-nginx-反向代理解释"><a href="#生动的-nginx-反向代理解释" class="headerlink" title="生动的 nginx 反向代理解释"></a>生动的 nginx 反向代理解释</h2><p>为了让大家能够更加深刻的理解代理和反向代理的模式,我们引用下知乎上<a href="https://www.zhihu.com/question/24723688/answer/160252724" target="_blank" rel="external">车小胖</a>的回答</p>
<blockquote>
<p>有了第三方订餐外卖平台（代理），老王懒得动身前往饭店，老王打个电话或用APP，先选好某个饭店，再点好菜，外卖小哥会送上门来。由于某个品牌的饭店口碑特别好，食客络绎不绝涌入，第三方订餐电话也不绝于耳，但是限于饭店接待能力有限，无法提供及时服务，很多食客等得不耐烦了，纷纷铩羽而归，饭店老总看着煮熟的鸭子飞走了，心疼不已。痛定思痛，老总又成立了几个连锁饭店，形成一个集群，对外提供统一标准的菜品服务，电话订餐电话400-xxx-7777，当食客涌入饭店总台，总台将食客用大巴运到各个连锁店，这样食客既不需要排队，各连锁店都能高速运转起来，一举两得，老总乐开了花，并为此种运作模式起名为“反向代理”（Reverse Proxy)。</p>
</blockquote>
<h2 id="nginx-基础配置"><a href="#nginx-基础配置" class="headerlink" title="nginx 基础配置"></a>nginx 基础配置</h2><p>好了,了解了 nginx 的一些概念之后,我们要开始切入今天的主题,”ngix 的基础配置”,安装好 nginx 配置之后,你对 nginx 的配置都写在 nginx.conf 的文件里,从 nginx 的配置指令作用域来讲,我们分为 5 个作用域块,分别是:</p>
<ul>
<li>全局作用域块</li>
<li>event 作用域块</li>
<li>http 指令作用域块</li>
<li>server 指令作用域块</li>
<li>location 指令作用域块</li>
</ul>
<p><img src="/images/nginx/nd.jpeg" alt="nginx基础配置"></p>
<p>在 “全局作用域块” 作用域块中配置通用的nginx 配置,比如 nginx 的用户组信息,nginx 的并发进程数,日志存放位置等,nginx 的用户组信息配置,用来控制启动 nginx 的权限,服务并发一般情况下是越多越好,但是当超过硬件的承受范围时会适得其反,所以一般我们会配置为 auto,这样 nginx 会去检查硬件的信息,启用适当的进程数量.</p>
<p>日志存放位置你也可以配置在 http 作用域块,”http 作用域块”作用域通常是配置请求相关的内容,比如数据的传输,对同一个接口的请求次数上线,配置请求的潮湿时间,还有是否要对请求进行 gzip 压缩等.在之前讲 web性能优化的时候,我记得和大家讲过 gzip 压缩是提高 web 性能优化的一种手段,gzip 能对 http 请求的请求头和请求体进行压缩,从而达到优化.但是不是所有的请求都要去压缩,有些压缩之后的请求体积可能会更大,从而达不到压缩的效果.那怎么办呢,在 nginx 的配置中,你可以进行配置,设置当请求大于一定值的时候,才触发 gzip 压缩 gzip 的内容这里就深入讲解了,想要了解的同学可以去谷歌下,或则在下次 nginx 的高级配置的分享的时候我们再来细讲.</p>
<p>在 event 模块我们通常会配置进程的连接数量,就是每一个worker进程能并发处理（发起）的最大连接数.在 “server 指令作用域块” 我们可以进行独立项目的代理配置,</p>
<p>一个 http 指令中可以包含多个 server ,每一个 server 你可以看做是一个虚拟机,部署过网站的同学应该知道,若果你没有做代理,你的服务器只能部署一个项目的内容,默认是80端口,使用代理,能将客户端的请求根据端口作为区分,发散到不同的项目中.nginx 这一点,能让我们更好的利用服务器资源</p>
<p>在server 指令中,我们同样可以配置多个 location 指令,location 指令能将我们的字符串请求解析到对应的IP和端口,从而去获取正确的资源,location 也可以进行特殊配置,定制 网站的 404 ,500 等页面.</p>
<h2 id="nginx-的项目配置示例"><a href="#nginx-的项目配置示例" class="headerlink" title="nginx 的项目配置示例"></a>nginx 的项目配置示例</h2><p><img src="/images/nginx/l1.jpeg" alt="nginx作用域"><br><img src="/images/nginx/l2.jpeg" alt="nginx作用域"><br>我们简单的看下,我目前使用到的两个项目的 nginx 配置,在fengdai_pc 项目中我们通过 listen 来配置项目监听端口,通过 root 来配置前端项目文件的地址,我们还通过 location 来配置了几个模块代理,account 和 funds ,定制了 404 页面,在 另一个 nginx 配置项目中我们做了https 配置,配置了域名 <code>baibatianpc.com</code>,并且指定了证书的位置,这样配置后,我们能通过 访问 <a href="https://baibatianpc.com/" target="_blank" rel="external">https://baibatianpc.com/</a> 来查看我们的项目.这里对于如何搭建 https 环境就不细讲了,不同的开发系统证书的获取和配置方式也不太一样,想要深入了解的同学继续谷歌.</p>
<h2 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h2><p>好了,我们今天讲了nginx 的基础配置,我们现在来复习一下,我们今天讲的知识点有哪些</p>
<ol>
<li>nginx 常用的功能的概念,负载均衡,反向代理</li>
<li>nginx 指令配置的5个作用域空间</li>
<li>nginx 的每个配置作用域的基础配置项目</li>
<li>简单的两个项目配置示例</li>
</ol>
<p>你都掌握了吗,联系我进行交流,WeChat:646321933</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2017/01/09/webpack/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/09/webpack/" itemprop="url">
                  你需要知道的 webpack 配置
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-09T21:27:52+08:00">
                2017-01-09
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2017/01/09/webpack/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/01/09/webpack/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>好久没有写文章，最近在做项目自动化构建工具的迁移，花了一点时间去研究 <code>webpack</code> ，<code>webpack</code> 的入门其实简单，但是现有的资料比较零碎，按照我的学习路径整理了下，希望对大家能有所帮助。</p>
<blockquote>
<p>接下来我将从3个部分来给大家介绍<code>webpack</code>,分别是 webpack 的基础配置，哪些常用的加载器，我在项目自动化构建工具改造的过程中雨大了那些问题</p>
</blockquote>
<h3 id="webpack-基础配置"><a href="#webpack-基础配置" class="headerlink" title="webpack 基础配置"></a>webpack 基础配置</h3><p>首先我们需要理解四个重要的概念</p>
<ol>
<li>入口（你需要打包的文件声明），你的项目需要什么依赖没在这里进行声明，require 你需要的依赖，webpack 会直接和间接的找到依赖文件进行打包，可传字符串，数组，对象<pre>
     // 配置了3个入口文件
     entry: [
             './config/dependencies.js',
             './config/index.js',
             './config/cssImport.js'
     ]
</pre></li>
<li>出口（你打包资源后到哪个目录哪个文件），声明依赖打包后的文件输出的目录及命名方式，可传字符串，数组，对象<pre>
     //声明了依赖压缩打包之后会被添加到 build 目录的 bundle.js 文件里
     output: {
             path: path.join(__dirname, '../build'),
             filename: 'bundle.js',
     },
</pre></li>
<li>loader（模块加载器）能将各种资源的依赖模块打包成webpack 能够理解的 js 模块，从而进行你需要的操作，如 css 预编译，图片压缩，路径转换等<pre>
     loaders: [
                 {
                     test: /\.js?$/,
                     exclude: /(node_modules|bower_components)/,
                     loader: 'babel-loader', // 'babel-loader' is also a legal name to reference
                     query: {
                             presets: ['es2015']
                     }
             }]
</pre></li>
<li><p>插件（插件用于扩展 loader 的能力）你可以用插件进行定义环境变量对代码进行打包压缩。</p>
<pre>
     //声明
     const ImageminPlugin = require("imagemin-webpack-plugin").default
     const CopyWebpackPlugin = require('copy-webpack-plugin')

     //从imgSrc 目录压缩图片，压缩完拷贝到 build/img 目录下
     plugins: [
             new CopyWebpackPlugin([
                     { from: 'imgSrc' ,to:'img'}
             ]),
             new ImageminPlugin(
                     { test: /\.(jpe?g|png|gif|svg)$/i }
                     )
     ]
</pre>

</li>
</ol>
<p><a href="https://doc.webpack-china.org/concepts/" target="_blank" rel="external">概念方面如果有不清晰的可以看下 webpack 的中文文档</a></p>
<h3 id="webpack-的常用加载器"><a href="#webpack-的常用加载器" class="headerlink" title="webpack 的常用加载器"></a>webpack 的常用加载器</h3><p>loader 用于常用的源代码进行装换，常用的有js编译，css 预编译，图片压缩等，这些都是项目中比较常见的，大家平时不需要记忆，只要能大概知道有这么一个东西，需要用到的时候去查阅就行，<a href="https://doc.webpack-china.org/loaders/" target="_blank" rel="external">loader 官方收录文档</a></p>
<h3 id="在项目迁移中遇到的问题"><a href="#在项目迁移中遇到的问题" class="headerlink" title="在项目迁移中遇到的问题"></a>在项目迁移中遇到的问题</h3><p>由于各种历史原因，我们的项目目录结构凌乱，项目依赖多，结构复杂，使用着 <code>angular + gulp</code> 进行开发，自动化构建工具还处于刀耕火种的年代，发版本的时候通过前端给包，不安全，不规范。新的一年我们尝试去改变这种现状，洗完通过运维直接拉去前端代码，这样能充分的保证前端代码的一致性。</p>
<h4 id="目前的项目结构的控诉"><a href="#目前的项目结构的控诉" class="headerlink" title="目前的项目结构的控诉"></a>目前的项目结构的控诉</h4><ol>
<li>项目所有问文件处于一个平级状态</li>
<li>有3个依赖包文件夹分别是 framwork，lib，node_modules(各种历史遗留问题)</li>
<li>源图片imgSrc和压缩后的img在同一个目录</li>
<li>人工手动打包的时候要很小心的删除不必要的文件</li>
</ol>
<h4 id="现有的改进方案"><a href="#现有的改进方案" class="headerlink" title="现有的改进方案"></a>现有的改进方案</h4><ol>
<li>创建 build 文件夹，nginx 代理 到 build 目录</li>
<li>config 中配置 webpack 构建打包任务，以及各种依赖的入口文件</li>
<li>ib &amp;&amp; framwork 移到 build 文件</li>
<li>less 中对图片的引用路径需要变动，因为img 的路径变动了，tpls 也变动了，所以在视图中直接引用的不需要变化</li>
<li>gulpfile 中的 js 压缩，less 编译，图片压缩内容迁移到 webpack 任务中</li>
<li>通过 npm run dev 进行编译构建</li>
<li>图片压缩</li>
<li>依赖及模块文件变化时实时构建项目</li>
<li>弃用 gulpfile 编译构建</li>
</ol>
<p>创建 <code>build</code> 文件夹，<code>nginx</code> 代理 到 <code>build</code></p>
<blockquote>
<p>目录，配置生产环境依赖目录，运维可以直接将代理指向该目录，不需要人工手动剔除多余的目录</p>
</blockquote>
<p>config 中配置 webpack 构建打包任务，以及各种依赖的入口文件</p>
<blockquote>
<p>建立config 目录，存放 webpack 配置文件目录，及各种依赖声明目录，我们一共声明了3个依赖入口文件，分别是npm 管理的生产依赖文件，css 文件，项目逻辑js文件。css 和 生产依赖的内容比较烧，我们手动 require 一下，但是我们项目是已经经过近两年的迭代开发，逻辑代码 js 文件繁多，目录结构负责，所以我们需要写一个简单的 node 脚本，递归查询项目目录结构，动态 require 写入到我们的js入口文件中，node 脚本 如下</p>
</blockquote>
<pre>
        var files = fs.readdirSync('js')
        var jsPath = 'js'

        fs.unlink('config/index.js')

        var getFileName = function (files,dirPath) {

        files.forEach(function (filename) {
                var fullname = path.join(dirPath,filename)
                var stats = fs.statSync(fullname)

                if (stats.isDirectory()){
                        var subFiles = fs.readdirSync(fullname)
                        getFileName(subFiles,fullname)
                } else {
                        let file = './../'+dirPath+'/'+filename
                        fs.writeFile('./config/index.js', 'require (\"'+file +'\")\n', {
                                flag: 'a'
                        }, function(err){
                                 if(err) throw err
                        })
                }
        })
}

getFileName(files,jsPath)
</pre>

<p>配置我们的入口和输入</p>
<pre>
        entry: [
                './config/dependencies.js',
                './config/index.js',
                './config/cssImport.js'
        ],
        output: {
                path: path.join(__dirname, '../build'),
                filename: '[name].js',
        },
</pre>

<p>然后是对我们的gulp task 进行迁移，我们需要配置 js 语法编译，css 预处理，图片压缩的功能。js 编译只需要使用 <code>babel-loader</code> ,通过 <code>npm install babel-loader</code> 安装加载器，指定匹配的文件及需要忽略的文件，指定转化语法，设定转码规则，就配置成功了</p>
<pre>
        {
            test: /\.js?$/,
            exclude: /(node_modules|bower_components)/,
            loader: 'babel-loader', // 'babel-loader' is also a legal name to reference
            query: {
                presets: ['es2015']
            }
        }
</pre>

<p>css 预编译，我们使用了 less 做为 css 开发工具，编译的时候需要用到的 loader 比较多，通过<code>less-loader</code>,<code>css-loader</code>,<code>style-loader</code>的链式调用，将样式作用于DOM</p>
<pre>
        rules: [{
            test: /\.less$/,
            use: [{
                loader: "style-loader" // creates style nodes from JS strings
            }, {
                loader: "css-loader" // translates CSS into CommonJS
            }, {
                loader: "less-loader" // compiles Less to CSS
            }]
        }]
</pre>

<p>或则</p>
<pre>
loaders: [
            {
                test: /\.less$/,
                use: ['style-loader',
                    {
                        loader: 'css-loader',
                        options: {
                            //支持@important引入css
                            importLoaders: 1
                        }
                    },
                    {
                        loader: 'postcss-loader',
                        options: {
                            plugins: function() {
                                return [
                                //一定要写在require("autoprefixer")前面，否则require("autoprefixer")无效
                                require('postcss-import')(),
                                require("autoprefixer")({
                                "browsers": ["Android >= 4.1", "iOS >= 7.0", "ie >= 8"]})]
                            }
                        }
                    },
                    'less-loader']
                }]
</pre>

<p>图片压缩我们选择了两个插件分别是<code>imagemin-webpack-plugin</code>和<code>copy-webpack-plugin</code>，imagemin 实现图片压缩，copy 实现图片资源拷贝，具体配置如下</p>
<pre>
//插件引用
const ImageminPlugin = require("imagemin-webpack-plugin").default
const CopyWebpackPlugin = require('copy-webpack-plugin')

//插件使用
plugins: [
                new CopyWebpackPlugin([
                        { from: 'imgSrc' ,to:'img'}
                ]),
                new ImageminPlugin(
                        { test: /\.(jpe?g|png|gif|svg)$/i }
                        )
        ]
</pre>

<p>了解完细节我们看下一个整体的配置</p>
<pre>
/**
 * Created by bailinlin on 2018/1/4.
 */
const fs = require ("fs")
const path = require ("path")

const ImageminPlugin = require("imagemin-webpack-plugin").default
const CopyWebpackPlugin = require('copy-webpack-plugin')


var files = fs.readdirSync('js')
var jsPath = 'js'

fs.unlink('config/index.js')

var getFileName = function (files,dirPath) {

        files.forEach(function (filename) {
                var fullname = path.join(dirPath,filename)
                var stats = fs.statSync(fullname)

                if (stats.isDirectory()){
                        var subFiles = fs.readdirSync(fullname)
                        getFileName(subFiles,fullname)
                } else {
                        let file = './../'+dirPath+'/'+filename
                        fs.writeFile('./config/index.js', 'require (\"'+file +'\")\n', {
                                flag: 'a'
                        }, function(err){
                                 if(err) throw err
                        })
                }
        })
}

getFileName(files,jsPath)

module.exports = {
        entry: [
                './config/dependencies.js',
                './config/index.js',
                './config/cssImport.js'
        ],
        output: {
                path: path.join(__dirname, '../build'),
                filename: 'bundle.js',
        },
        module: {
                loaders: [
                    {
                        test: /\.js?$/,
                    exclude: /(node_modules|bower_components)/,
            loader: 'babel-loader', // 'babel-loader' is also a legal name to reference
            query: {
                presets: ['es2015']
            }
                },{
                test: /\.less$/,
                use: ['style-loader',
                {
                loader: 'css-loader',
                options: {
                 //支持@important引入css
                    importLoaders: 1
                }
                },{
                loader: 'postcss-loader',
                options: {
                plugins: function() {
                    return [
                    //一定要写在require("autoprefixer")前面，否则require("autoprefixer")无效
                    require('postcss-import')(),
                    require("autoprefixer")({
                    "browsers": ["Android >= 4.1", "iOS >= 7.0", "ie >= 8"]})]
                     }
                     }
                    },
                    'less-loader']
                },{
                    test: /\.(jpe?g|png|gif|svg)$/i,
                    use: [
                    {
                        loader: 'url-loader',
                        options: {
                            limit: 8192
                        }
                    }]
                }]
        },
        plugins: [
                new CopyWebpackPlugin([
                        { from: 'imgSrc' ,to:'img'}
                ]),
                new ImageminPlugin(
                        { test: /\.(jpe?g|png|gif|svg)$/i }
                        )
        ]
}

</pre>

<h4 id="实现热编译"><a href="#实现热编译" class="headerlink" title="实现热编译"></a>实现热编译</h4><p>实现完配置之后我们要考虑另一个问题了，我们希望修改完之后能实时编译预览，不用每次都手动的跑一边命令，我们可以选择 webpack 提供的 node 服务，<code>webpack-dev-server</code>,在配置文件里新增一个 webpack.server.js 的文件，在文件中 require 需要的依赖，<code>webpack-dev-server</code> 可以指定服务启动的目录，及服务监听的端口，我们的配置如下</p>
<pre>
/**
 * Created by bailinlin on 2018/1/4.
 */
var path = require("path")
var webpack = require("webpack")
var webpackDevServer = require("webpack-dev-server")
var webpackCfg = require("./webpack.config.js")

var compiler = webpack(webpackCfg)

//init server
var app = new webpackDevServer(compiler, {
        contentBase        : path.join(__dirname, '../build'),
        noInfo             : true,
        hot                : true,
        historyApiFallback : true,
        stats              : { colors : true },
        //注意此处publicPath必填
        publicPath: webpackCfg.output.publicPath
})

app.listen(9090, "localhost", function (err) {
        if (err) {
                console.log(err)
        }
})

console.log("listen at http://localhost:9090")
</pre>

<h4 id="启动我们的服务"><a href="#启动我们的服务" class="headerlink" title="启动我们的服务"></a>启动我们的服务</h4><p>配置完成之后，我们需要启动我们的服务，你可以再你的控制台中直接输入 <code>node config/webpack.server.js</code> 来启动服务，<code>webpack --config config/webpack.config.js</code> 来进行编译构建，也可以在 package.json 文件中配置 script 如</p>
<p><pre><br>“scripts”: {<br>    “start”:”node config/webpack.server.js”,<br>    “build”: “webpack –config config/webpack.config.js”<br>  },<br></pre><br>这样你就可以通过 <code>npm start</code> 和 <code>npm run build</code>来控制你的服务启动和项目构建</p>
<p>参考文章列表</p>
<blockquote>
<p>如果你还想更深入理解，你可以继续阅读这些扩展文章<br><a href="https://doc.webpack-china.org/concepts/" target="_blank" rel="external">理解概念</a><br><a href="https://doc.webpack-china.org/configuration/#-" target="_blank" rel="external">配置讲解</a><br><a href="https://doc.webpack-china.org/loaders/" target="_blank" rel="external">常会用到的loaders</a><br><a href="http://blog.csdn.net/lancewu0907/article/details/76513231" target="_blank" rel="external">webpack打包原理</a><br><a href="https://www.zhihu.com/question/46661735" target="_blank" rel="external">webpack全局变量</a><br><a href="https://github.com/webpack-contrib/css-loader/issues/74" target="_blank" rel="external">less 图片解析问题</a><br><a href="https://juejin.im/entry/5767a975df0eea0062ffe193" target="_blank" rel="external">其他优秀的配置文章</a><br><a href="https://github.com/kingvid-chan/webpack2-lessons/tree/master/lesson2" target="_blank" rel="external">《使用webpack-dev-server实现热更新》</a><br><a href="https://github.com/Klathmon/imagemin-webpack-plugin" target="_blank" rel="external">imagemin-webpack-plugin</a><br><a href="https://github.com/webpack-contrib/copy-webpack-plugin" target="_blank" rel="external">copy-webpack-plugin</a></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://bailinlin.github.com/2016/11/01/learn-wxapp/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="bailinlin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/bbt.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="白霸天的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="白霸天的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/01/learn-wxapp/" itemprop="url">
                  你需要知道的小程序开发基础
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-01T20:38:15+08:00">
                2016-11-01
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/11/01/learn-wxapp/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/01/learn-wxapp/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>微信小程序出来已有段时间，虽还在内测阶段。利用空闲时间，我把蜂贷微信项目部分迁移到小程序上。</p>
<p>##1.目录结构</p>
<p>   小程序的主体由三个文件组成，这三个文件要放在项目的根目录下，分别是</p>
<ol>
<li>app.js 配置小程序的逻辑</li>
<li>app.json 公共设置</li>
<li><p>app.wxss 公共样式</p>
<p>小程序可以自定义 page，但是 page 需要在 app.json 中做出声明，不然IDE会报错，找不到页面。小程序的页面由四个文件组成，分别是</p>
</li>
<li><p>.js文件 页面逻辑</p>
</li>
<li>.wxml 视图层文件，页面结构</li>
<li>.wxss 样式文件，页面样式表</li>
<li>.json 文件，配置文件，页面配置</li>
</ol>
<h2 id="2-小程序配置"><a href="#2-小程序配置" class="headerlink" title="2.小程序配置"></a>2.小程序配置</h2><p>app.json 决定页面文件的路径、窗口表现、设置网络超时时间、设置多少 tab 。</p>
<p>在 pages 对象里定义页面路径，pages 接受由字符串组成的数组，pages数组的第一个元素就是小程序的首页。</p>
<ol>
<li>window 用于设置小程序的状态栏、导航条、标题、窗口背景色。</li>
<li>tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。</li>
<li>networkTimeout 用来设置各种网络请求超时时间</li>
<li>debug 是布尔类型，用来配置是否在开发者工具中开启 debug 模式</li>
</ol>
<h2 id="3-小程序视图"><a href="#3-小程序视图" class="headerlink" title="3.小程序视图"></a>3.小程序视图</h2><p>在小程序中，你不能继续用 html 中的标签来构造你的页面，MANA 框架有特定的容器组件，view，scroll-view  以及 swiper。</p>
<ol>
<li>view 是视图容器，类似于 html 中的 div ，但是不同的是，用 view 包裹的内容，在超出设备窗口的时候，它实现的效果如 css 样式设置的 overflow：hidden</li>
<li>如果你需要实现类似通讯录或则聊天列表的滚动效果，你需要使用 scroll-view 滚动容器组件，它实现的效果如 css 样式设置的 overflow:scroll 。</li>
<li>swiper 是滑块视图组件，如果你要实现类似轮播图的效果的话，他是你的不二之选，你能通过属性配置来控制是否显示圆点，是否自动播放，切换时间，以及切换间隔时间等。<br>小程序的MANA也实现了数据的绑定，写法类似于 Angular 和 Vue，通过双括号的形式 如： 即可，值得注意的是，如果你写在容器（为了便于描述和理解，下文会以标签来描述）于之间的话，你直接把变量写在双括号里即可，如：<view></view> ，但是如果你给标签的属性绑定变量，你需要将双括号放在双引号内，如：<view wx:if="””&gt;</view">,类似于Angular 和 Vue，你也能在双括号内进行简单的运算，如：<view hidden="”{flag?true:false}”"></view>。</view></li>
</ol>
<p>细心的同学可能发现了在介绍数据绑定的时候我们用了wx:if  的属性，这是 MANA 提供的条件渲染，通过判断 wx:if 传布尔值（非布尔类型进行隐士转化）来控制是否渲染标签中的内容。在 MANA 中还有一个属性能控制内容的显隐，不同的是，wx:if 只有在为 true 的时候才回去渲染标签中的内容，而 hidden 始终会渲染内容，只是根据条件来控制内容的显示与否。</p>
<p>此外MANA 也为我们提供了较为实用的列表渲染，wx:for 接受一个数组,在页面中能根据数组中的值来渲染页面列表</p>
<p>除了使用列表渲染来复用一块视图外，你还可以通过模版来进行复用，你能在 template 中定义一块代码片段，然后在不同的页面中引用，如：</p>
<pre><code>&lt;template name=&quot;odd&quot;&gt;
  &lt;view&gt; odd &lt;/view&gt;
&lt;/template&gt;
&lt;template name=&quot;even&quot;&gt;
  &lt;view&gt; even &lt;/view&gt;
&lt;/template&gt;

&lt;block wx:for=&quot;{{[1, 2, 3, 4, 5]}}&quot;&gt;
    &lt;template is=&quot;{{item % 2 == 0 ? 'even' : 'odd'}}&quot;/&gt;
&lt;/block&gt;
</code></pre><p>除了 template 外，MANA 还提供了另外两种方式来进行应用和复用，import 和 include ，import 有作用域的概念，他只会引用目标文件中定义的模版。include可以将目标文件除了<template>的整个代码引入，相当于是拷贝到include位置上。</template></p>
<p>除MANA 同样也定义了常用的事件分类，如</p>
<ol>
<li>touchstart 手指触摸动作开始</li>
<li>touchmove 手指触摸后移动</li>
<li>touchcancel 手指触摸动作被打断，如来电提醒，弹窗</li>
<li>touchend 手指触摸动作结束</li>
<li>tap 手指触摸后马上离开</li>
<li>longtap 手指触摸后，超过350ms再离开<h2 id="4-组件样式"><a href="#4-组件样式" class="headerlink" title="4.组件样式"></a>4.组件样式</h2></li>
</ol>
<p>定义在 app.wxss 中的样式为全局样式，作用于每一个页面。在 page 的 wxss 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 app.wxss 中相同的选择器。如果你写过 css ，那你就能轻松驾驭 wxss,wxss 在选择器上做了限制，目前支持的选择器有：</p>
<ol>
<li>.class 如：.intro    选择所有拥有 class=”intro” 的组件</li>
<li><code>#id</code> 如：<code>#firstname</code>    选择拥有 id=”firstname” 的组件</li>
<li>element  如：    view    选择所有 view 组件</li>
<li>element, 如： element    view checkbox    选择所有文档的 view 组件和所有的 checkbox 组件</li>
<li>::after     如：view::after    在 view 组件后边插入内容</li>
<li>::before     如：view::before    在 view 组件前边插入内容</li>
</ol>
<p>开发过移动端的前端er 都知道，苹果手机有物理像素和逻辑像素的区别，比如设备的像素是350px，设计稿的像素是750px；一般在开发过程中，我们会使用自动化构建工具去做像素转化，或则是使用预处理器定义像素转化函数进行处理，在小程序的开发中，大可不必这么麻烦，小程序提供了一个 rpx 的单位，你可以直接写上你在设计稿中测量的数值即可，小程序开发工具在编译过程中会自动帮你做转换。</p>
<p>在下次小程序分享《小程序开发踩坑（二）》的时候，会教大家如何与后端进行数据交互，欢迎感兴趣的小伙伴订阅博客。</p>
<p><img src="/img/bVEXHS" alt="蜂贷微信端"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/bbt.jpeg"
               alt="bailinlin" />
          <p class="site-author-name" itemprop="name">bailinlin</p>
          <p class="site-description motion-element" itemprop="description">前端,白霸天,博客</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">14</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bailinlin</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"baibatian"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  








  
  

  

  

  

  


</body>
</html>
